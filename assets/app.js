(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __pow = Math.pow;
  var __defNormalProp = (obj, key2, value2) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
  var __spreadValues = (a5, b3) => {
    for (var prop in b3 || (b3 = {}))
      if (__hasOwnProp.call(b3, prop))
        __defNormalProp(a5, prop, b3[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b3)) {
        if (__propIsEnum.call(b3, prop))
          __defNormalProp(a5, prop, b3[prop]);
      }
    return a5;
  };
  var __spreadProps = (a5, b3) => __defProps(a5, __getOwnPropDescs(b3));
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod2) => function __require() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key2 of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key2) && key2 !== except)
          __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));
  var __publicField = (obj, key2, value2) => __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value2);
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value2) => {
        try {
          step(generator.next(value2));
        } catch (e5) {
          reject(e5);
        }
      };
      var rejected = (value2) => {
        try {
          step(generator.throw(value2));
        } catch (e5) {
          reject(e5);
        }
      };
      var step = (x3) => x3.done ? resolve(x3.value) : Promise.resolve(x3.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // node_modules/bezier-easing/src/index.js
  var require_src = __commonJS({
    "node_modules/bezier-easing/src/index.js"(exports2, module2) {
      var NEWTON_ITERATIONS = 4;
      var NEWTON_MIN_SLOPE = 1e-3;
      var SUBDIVISION_PRECISION = 1e-7;
      var SUBDIVISION_MAX_ITERATIONS = 10;
      var kSplineTableSize = 11;
      var kSampleStepSize = 1 / (kSplineTableSize - 1);
      var float32ArraySupported = typeof Float32Array === "function";
      function A3(aA1, aA2) {
        return 1 - 3 * aA2 + 3 * aA1;
      }
      function B3(aA1, aA2) {
        return 3 * aA2 - 6 * aA1;
      }
      function C3(aA1) {
        return 3 * aA1;
      }
      function calcBezier(aT, aA1, aA2) {
        return ((A3(aA1, aA2) * aT + B3(aA1, aA2)) * aT + C3(aA1)) * aT;
      }
      function getSlope(aT, aA1, aA2) {
        return 3 * A3(aA1, aA2) * aT * aT + 2 * B3(aA1, aA2) * aT + C3(aA1);
      }
      function binarySubdivide(aX, aA, aB, mX1, mX2) {
        var currentX, currentT, i6 = 0;
        do {
          currentT = aA + (aB - aA) / 2;
          currentX = calcBezier(currentT, mX1, mX2) - aX;
          if (currentX > 0) {
            aB = currentT;
          } else {
            aA = currentT;
          }
        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i6 < SUBDIVISION_MAX_ITERATIONS);
        return currentT;
      }
      function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
        for (var i6 = 0; i6 < NEWTON_ITERATIONS; ++i6) {
          var currentSlope = getSlope(aGuessT, mX1, mX2);
          if (currentSlope === 0) {
            return aGuessT;
          }
          var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
          aGuessT -= currentX / currentSlope;
        }
        return aGuessT;
      }
      function LinearEasing(x3) {
        return x3;
      }
      module2.exports = function bezier(mX1, mY1, mX2, mY2) {
        if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
          throw new Error("bezier x values must be in [0, 1] range");
        }
        if (mX1 === mY1 && mX2 === mY2) {
          return LinearEasing;
        }
        var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
        for (var i6 = 0; i6 < kSplineTableSize; ++i6) {
          sampleValues[i6] = calcBezier(i6 * kSampleStepSize, mX1, mX2);
        }
        function getTForX(aX) {
          var intervalStart = 0;
          var currentSample = 1;
          var lastSample = kSplineTableSize - 1;
          for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
            intervalStart += kSampleStepSize;
          }
          --currentSample;
          var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
          var guessForT = intervalStart + dist * kSampleStepSize;
          var initialSlope = getSlope(guessForT, mX1, mX2);
          if (initialSlope >= NEWTON_MIN_SLOPE) {
            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
          } else if (initialSlope === 0) {
            return guessForT;
          } else {
            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
          }
        }
        return function BezierEasing2(x3) {
          if (x3 === 0) {
            return 0;
          }
          if (x3 === 1) {
            return 1;
          }
          return calcBezier(getTForX(x3), mY1, mY2);
        };
      };
    }
  });

  // node_modules/lottie-web/build/player/lottie.js
  var require_lottie = __commonJS({
    "node_modules/lottie-web/build/player/lottie.js"(exports, module) {
      typeof navigator !== "undefined" && function(global, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.lottie = factory());
      }(exports, function() {
        "use strict";
        var svgNS = "http://www.w3.org/2000/svg";
        var locationHref = "";
        var _useWebWorker = false;
        var initialDefaultFrame = -999999;
        var setWebWorker = function setWebWorker2(flag) {
          _useWebWorker = !!flag;
        };
        var getWebWorker = function getWebWorker2() {
          return _useWebWorker;
        };
        var setLocationHref = function setLocationHref2(value2) {
          locationHref = value2;
        };
        var getLocationHref = function getLocationHref2() {
          return locationHref;
        };
        function createTag(type) {
          return document.createElement(type);
        }
        function extendPrototype(sources, destination) {
          var i6;
          var len = sources.length;
          var sourcePrototype;
          for (i6 = 0; i6 < len; i6 += 1) {
            sourcePrototype = sources[i6].prototype;
            for (var attr in sourcePrototype) {
              if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr)) destination.prototype[attr] = sourcePrototype[attr];
            }
          }
        }
        function getDescriptor(object, prop) {
          return Object.getOwnPropertyDescriptor(object, prop);
        }
        function createProxyFunction(prototype) {
          function ProxyFunction() {
          }
          ProxyFunction.prototype = prototype;
          return ProxyFunction;
        }
        var audioControllerFactory = function() {
          function AudioController(audioFactory) {
            this.audios = [];
            this.audioFactory = audioFactory;
            this._volume = 1;
            this._isMuted = false;
          }
          AudioController.prototype = {
            addAudio: function addAudio(audio) {
              this.audios.push(audio);
            },
            pause: function pause() {
              var i6;
              var len = this.audios.length;
              for (i6 = 0; i6 < len; i6 += 1) {
                this.audios[i6].pause();
              }
            },
            resume: function resume() {
              var i6;
              var len = this.audios.length;
              for (i6 = 0; i6 < len; i6 += 1) {
                this.audios[i6].resume();
              }
            },
            setRate: function setRate(rateValue) {
              var i6;
              var len = this.audios.length;
              for (i6 = 0; i6 < len; i6 += 1) {
                this.audios[i6].setRate(rateValue);
              }
            },
            createAudio: function createAudio(assetPath) {
              if (this.audioFactory) {
                return this.audioFactory(assetPath);
              }
              if (window.Howl) {
                return new window.Howl({
                  src: [assetPath]
                });
              }
              return {
                isPlaying: false,
                play: function play() {
                  this.isPlaying = true;
                },
                seek: function seek() {
                  this.isPlaying = false;
                },
                playing: function playing() {
                },
                rate: function rate() {
                },
                setVolume: function setVolume() {
                }
              };
            },
            setAudioFactory: function setAudioFactory(audioFactory) {
              this.audioFactory = audioFactory;
            },
            setVolume: function setVolume(value2) {
              this._volume = value2;
              this._updateVolume();
            },
            mute: function mute() {
              this._isMuted = true;
              this._updateVolume();
            },
            unmute: function unmute() {
              this._isMuted = false;
              this._updateVolume();
            },
            getVolume: function getVolume() {
              return this._volume;
            },
            _updateVolume: function _updateVolume() {
              var i6;
              var len = this.audios.length;
              for (i6 = 0; i6 < len; i6 += 1) {
                this.audios[i6].volume(this._volume * (this._isMuted ? 0 : 1));
              }
            }
          };
          return function() {
            return new AudioController();
          };
        }();
        var createTypedArray = function() {
          function createRegularArray(type, len) {
            var i6 = 0;
            var arr = [];
            var value2;
            switch (type) {
              case "int16":
              case "uint8c":
                value2 = 1;
                break;
              default:
                value2 = 1.1;
                break;
            }
            for (i6 = 0; i6 < len; i6 += 1) {
              arr.push(value2);
            }
            return arr;
          }
          function createTypedArrayFactory(type, len) {
            if (type === "float32") {
              return new Float32Array(len);
            }
            if (type === "int16") {
              return new Int16Array(len);
            }
            if (type === "uint8c") {
              return new Uint8ClampedArray(len);
            }
            return createRegularArray(type, len);
          }
          if (typeof Uint8ClampedArray === "function" && typeof Float32Array === "function") {
            return createTypedArrayFactory;
          }
          return createRegularArray;
        }();
        function createSizedArray(len) {
          return Array.apply(null, {
            length: len
          });
        }
        function _typeof$6(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof$6 = function _typeof3(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof$6 = function _typeof3(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof$6(obj);
        }
        var subframeEnabled = true;
        var expressionsPlugin = null;
        var expressionsInterfaces = null;
        var idPrefix$1 = "";
        var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        var _shouldRoundValues = false;
        var bmPow = Math.pow;
        var bmSqrt = Math.sqrt;
        var bmFloor = Math.floor;
        var bmMax = Math.max;
        var bmMin = Math.min;
        var BMMath = {};
        (function() {
          var propertyNames = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"];
          var i6;
          var len = propertyNames.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            BMMath[propertyNames[i6]] = Math[propertyNames[i6]];
          }
        })();
        function ProjectInterface$1() {
          return {};
        }
        BMMath.random = Math.random;
        BMMath.abs = function(val2) {
          var tOfVal = _typeof$6(val2);
          if (tOfVal === "object" && val2.length) {
            var absArr = createSizedArray(val2.length);
            var i6;
            var len = val2.length;
            for (i6 = 0; i6 < len; i6 += 1) {
              absArr[i6] = Math.abs(val2[i6]);
            }
            return absArr;
          }
          return Math.abs(val2);
        };
        var defaultCurveSegments = 150;
        var degToRads = Math.PI / 180;
        var roundCorner = 0.5519;
        function roundValues(flag) {
          _shouldRoundValues = !!flag;
        }
        function bmRnd(value2) {
          if (_shouldRoundValues) {
            return Math.round(value2);
          }
          return value2;
        }
        function styleDiv(element) {
          element.style.position = "absolute";
          element.style.top = 0;
          element.style.left = 0;
          element.style.display = "block";
          element.style.transformOrigin = "0 0";
          element.style.webkitTransformOrigin = "0 0";
          element.style.backfaceVisibility = "visible";
          element.style.webkitBackfaceVisibility = "visible";
          element.style.transformStyle = "preserve-3d";
          element.style.webkitTransformStyle = "preserve-3d";
          element.style.mozTransformStyle = "preserve-3d";
        }
        function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {
          this.type = type;
          this.currentTime = currentTime;
          this.totalTime = totalTime;
          this.direction = frameMultiplier < 0 ? -1 : 1;
        }
        function BMCompleteEvent(type, frameMultiplier) {
          this.type = type;
          this.direction = frameMultiplier < 0 ? -1 : 1;
        }
        function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {
          this.type = type;
          this.currentLoop = currentLoop;
          this.totalLoops = totalLoops;
          this.direction = frameMultiplier < 0 ? -1 : 1;
        }
        function BMSegmentStartEvent(type, firstFrame, totalFrames) {
          this.type = type;
          this.firstFrame = firstFrame;
          this.totalFrames = totalFrames;
        }
        function BMDestroyEvent(type, target) {
          this.type = type;
          this.target = target;
        }
        function BMRenderFrameErrorEvent(nativeError, currentTime) {
          this.type = "renderFrameError";
          this.nativeError = nativeError;
          this.currentTime = currentTime;
        }
        function BMConfigErrorEvent(nativeError) {
          this.type = "configError";
          this.nativeError = nativeError;
        }
        function BMAnimationConfigErrorEvent(type, nativeError) {
          this.type = type;
          this.nativeError = nativeError;
        }
        var createElementID = /* @__PURE__ */ function() {
          var _count = 0;
          return function createID() {
            _count += 1;
            return idPrefix$1 + "__lottie_element_" + _count;
          };
        }();
        function HSVtoRGB(h2, s4, v2) {
          var r6;
          var g3;
          var b3;
          var i6;
          var f3;
          var p3;
          var q3;
          var t4;
          i6 = Math.floor(h2 * 6);
          f3 = h2 * 6 - i6;
          p3 = v2 * (1 - s4);
          q3 = v2 * (1 - f3 * s4);
          t4 = v2 * (1 - (1 - f3) * s4);
          switch (i6 % 6) {
            case 0:
              r6 = v2;
              g3 = t4;
              b3 = p3;
              break;
            case 1:
              r6 = q3;
              g3 = v2;
              b3 = p3;
              break;
            case 2:
              r6 = p3;
              g3 = v2;
              b3 = t4;
              break;
            case 3:
              r6 = p3;
              g3 = q3;
              b3 = v2;
              break;
            case 4:
              r6 = t4;
              g3 = p3;
              b3 = v2;
              break;
            case 5:
              r6 = v2;
              g3 = p3;
              b3 = q3;
              break;
            default:
              break;
          }
          return [r6, g3, b3];
        }
        function RGBtoHSV(r6, g3, b3) {
          var max = Math.max(r6, g3, b3);
          var min = Math.min(r6, g3, b3);
          var d3 = max - min;
          var h2;
          var s4 = max === 0 ? 0 : d3 / max;
          var v2 = max / 255;
          switch (max) {
            case min:
              h2 = 0;
              break;
            case r6:
              h2 = g3 - b3 + d3 * (g3 < b3 ? 6 : 0);
              h2 /= 6 * d3;
              break;
            case g3:
              h2 = b3 - r6 + d3 * 2;
              h2 /= 6 * d3;
              break;
            case b3:
              h2 = r6 - g3 + d3 * 4;
              h2 /= 6 * d3;
              break;
            default:
              break;
          }
          return [h2, s4, v2];
        }
        function addSaturationToRGB(color, offset) {
          var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
          hsv[1] += offset;
          if (hsv[1] > 1) {
            hsv[1] = 1;
          } else if (hsv[1] <= 0) {
            hsv[1] = 0;
          }
          return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
        }
        function addBrightnessToRGB(color, offset) {
          var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
          hsv[2] += offset;
          if (hsv[2] > 1) {
            hsv[2] = 1;
          } else if (hsv[2] < 0) {
            hsv[2] = 0;
          }
          return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
        }
        function addHueToRGB(color, offset) {
          var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
          hsv[0] += offset / 360;
          if (hsv[0] > 1) {
            hsv[0] -= 1;
          } else if (hsv[0] < 0) {
            hsv[0] += 1;
          }
          return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
        }
        var rgbToHex = function() {
          var colorMap = [];
          var i6;
          var hex;
          for (i6 = 0; i6 < 256; i6 += 1) {
            hex = i6.toString(16);
            colorMap[i6] = hex.length === 1 ? "0" + hex : hex;
          }
          return function(r6, g3, b3) {
            if (r6 < 0) {
              r6 = 0;
            }
            if (g3 < 0) {
              g3 = 0;
            }
            if (b3 < 0) {
              b3 = 0;
            }
            return "#" + colorMap[r6] + colorMap[g3] + colorMap[b3];
          };
        }();
        var setSubframeEnabled = function setSubframeEnabled2(flag) {
          subframeEnabled = !!flag;
        };
        var getSubframeEnabled = function getSubframeEnabled2() {
          return subframeEnabled;
        };
        var setExpressionsPlugin = function setExpressionsPlugin2(value2) {
          expressionsPlugin = value2;
        };
        var getExpressionsPlugin = function getExpressionsPlugin2() {
          return expressionsPlugin;
        };
        var setExpressionInterfaces = function setExpressionInterfaces2(value2) {
          expressionsInterfaces = value2;
        };
        var getExpressionInterfaces = function getExpressionInterfaces2() {
          return expressionsInterfaces;
        };
        var setDefaultCurveSegments = function setDefaultCurveSegments2(value2) {
          defaultCurveSegments = value2;
        };
        var getDefaultCurveSegments = function getDefaultCurveSegments2() {
          return defaultCurveSegments;
        };
        var setIdPrefix = function setIdPrefix2(value2) {
          idPrefix$1 = value2;
        };
        var getIdPrefix = function getIdPrefix2() {
          return idPrefix$1;
        };
        function createNS(type) {
          return document.createElementNS(svgNS, type);
        }
        function _typeof$5(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof$5 = function _typeof3(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof$5 = function _typeof3(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof$5(obj);
        }
        var dataManager = /* @__PURE__ */ function() {
          var _counterId = 1;
          var processes = [];
          var workerFn;
          var workerInstance;
          var workerProxy = {
            onmessage: function onmessage() {
            },
            postMessage: function postMessage(path) {
              workerFn({
                data: path
              });
            }
          };
          var _workerSelf = {
            postMessage: function postMessage(data2) {
              workerProxy.onmessage({
                data: data2
              });
            }
          };
          function createWorker(fn) {
            if (window.Worker && window.Blob && getWebWorker()) {
              var blob = new Blob(["var _workerSelf = self; self.onmessage = ", fn.toString()], {
                type: "text/javascript"
              });
              var url = URL.createObjectURL(blob);
              return new Worker(url);
            }
            workerFn = fn;
            return workerProxy;
          }
          function setupWorker() {
            if (!workerInstance) {
              workerInstance = createWorker(function workerStart(e5) {
                function dataFunctionManager() {
                  function completeLayers(layers, comps) {
                    var layerData;
                    var i6;
                    var len = layers.length;
                    var j3;
                    var jLen;
                    var k3;
                    var kLen;
                    for (i6 = 0; i6 < len; i6 += 1) {
                      layerData = layers[i6];
                      if ("ks" in layerData && !layerData.completed) {
                        layerData.completed = true;
                        if (layerData.hasMask) {
                          var maskProps = layerData.masksProperties;
                          jLen = maskProps.length;
                          for (j3 = 0; j3 < jLen; j3 += 1) {
                            if (maskProps[j3].pt.k.i) {
                              convertPathsToAbsoluteValues(maskProps[j3].pt.k);
                            } else {
                              kLen = maskProps[j3].pt.k.length;
                              for (k3 = 0; k3 < kLen; k3 += 1) {
                                if (maskProps[j3].pt.k[k3].s) {
                                  convertPathsToAbsoluteValues(maskProps[j3].pt.k[k3].s[0]);
                                }
                                if (maskProps[j3].pt.k[k3].e) {
                                  convertPathsToAbsoluteValues(maskProps[j3].pt.k[k3].e[0]);
                                }
                              }
                            }
                          }
                        }
                        if (layerData.ty === 0) {
                          layerData.layers = findCompLayers(layerData.refId, comps);
                          completeLayers(layerData.layers, comps);
                        } else if (layerData.ty === 4) {
                          completeShapes(layerData.shapes);
                        } else if (layerData.ty === 5) {
                          completeText(layerData);
                        }
                      }
                    }
                  }
                  function completeChars(chars, assets) {
                    if (chars) {
                      var i6 = 0;
                      var len = chars.length;
                      for (i6 = 0; i6 < len; i6 += 1) {
                        if (chars[i6].t === 1) {
                          chars[i6].data.layers = findCompLayers(chars[i6].data.refId, assets);
                          completeLayers(chars[i6].data.layers, assets);
                        }
                      }
                    }
                  }
                  function findComp(id, comps) {
                    var i6 = 0;
                    var len = comps.length;
                    while (i6 < len) {
                      if (comps[i6].id === id) {
                        return comps[i6];
                      }
                      i6 += 1;
                    }
                    return null;
                  }
                  function findCompLayers(id, comps) {
                    var comp2 = findComp(id, comps);
                    if (comp2) {
                      if (!comp2.layers.__used) {
                        comp2.layers.__used = true;
                        return comp2.layers;
                      }
                      return JSON.parse(JSON.stringify(comp2.layers));
                    }
                    return null;
                  }
                  function completeShapes(arr) {
                    var i6;
                    var len = arr.length;
                    var j3;
                    var jLen;
                    for (i6 = len - 1; i6 >= 0; i6 -= 1) {
                      if (arr[i6].ty === "sh") {
                        if (arr[i6].ks.k.i) {
                          convertPathsToAbsoluteValues(arr[i6].ks.k);
                        } else {
                          jLen = arr[i6].ks.k.length;
                          for (j3 = 0; j3 < jLen; j3 += 1) {
                            if (arr[i6].ks.k[j3].s) {
                              convertPathsToAbsoluteValues(arr[i6].ks.k[j3].s[0]);
                            }
                            if (arr[i6].ks.k[j3].e) {
                              convertPathsToAbsoluteValues(arr[i6].ks.k[j3].e[0]);
                            }
                          }
                        }
                      } else if (arr[i6].ty === "gr") {
                        completeShapes(arr[i6].it);
                      }
                    }
                  }
                  function convertPathsToAbsoluteValues(path) {
                    var i6;
                    var len = path.i.length;
                    for (i6 = 0; i6 < len; i6 += 1) {
                      path.i[i6][0] += path.v[i6][0];
                      path.i[i6][1] += path.v[i6][1];
                      path.o[i6][0] += path.v[i6][0];
                      path.o[i6][1] += path.v[i6][1];
                    }
                  }
                  function checkVersion(minimum, animVersionString) {
                    var animVersion = animVersionString ? animVersionString.split(".") : [100, 100, 100];
                    if (minimum[0] > animVersion[0]) {
                      return true;
                    }
                    if (animVersion[0] > minimum[0]) {
                      return false;
                    }
                    if (minimum[1] > animVersion[1]) {
                      return true;
                    }
                    if (animVersion[1] > minimum[1]) {
                      return false;
                    }
                    if (minimum[2] > animVersion[2]) {
                      return true;
                    }
                    if (animVersion[2] > minimum[2]) {
                      return false;
                    }
                    return null;
                  }
                  var checkText = /* @__PURE__ */ function() {
                    var minimumVersion = [4, 4, 14];
                    function updateTextLayer(textLayer) {
                      var documentData = textLayer.t.d;
                      textLayer.t.d = {
                        k: [{
                          s: documentData,
                          t: 0
                        }]
                      };
                    }
                    function iterateLayers(layers) {
                      var i6;
                      var len = layers.length;
                      for (i6 = 0; i6 < len; i6 += 1) {
                        if (layers[i6].ty === 5) {
                          updateTextLayer(layers[i6]);
                        }
                      }
                    }
                    return function(animationData2) {
                      if (checkVersion(minimumVersion, animationData2.v)) {
                        iterateLayers(animationData2.layers);
                        if (animationData2.assets) {
                          var i6;
                          var len = animationData2.assets.length;
                          for (i6 = 0; i6 < len; i6 += 1) {
                            if (animationData2.assets[i6].layers) {
                              iterateLayers(animationData2.assets[i6].layers);
                            }
                          }
                        }
                      }
                    };
                  }();
                  var checkChars = /* @__PURE__ */ function() {
                    var minimumVersion = [4, 7, 99];
                    return function(animationData2) {
                      if (animationData2.chars && !checkVersion(minimumVersion, animationData2.v)) {
                        var i6;
                        var len = animationData2.chars.length;
                        for (i6 = 0; i6 < len; i6 += 1) {
                          var charData = animationData2.chars[i6];
                          if (charData.data && charData.data.shapes) {
                            completeShapes(charData.data.shapes);
                            charData.data.ip = 0;
                            charData.data.op = 99999;
                            charData.data.st = 0;
                            charData.data.sr = 1;
                            charData.data.ks = {
                              p: {
                                k: [0, 0],
                                a: 0
                              },
                              s: {
                                k: [100, 100],
                                a: 0
                              },
                              a: {
                                k: [0, 0],
                                a: 0
                              },
                              r: {
                                k: 0,
                                a: 0
                              },
                              o: {
                                k: 100,
                                a: 0
                              }
                            };
                            if (!animationData2.chars[i6].t) {
                              charData.data.shapes.push({
                                ty: "no"
                              });
                              charData.data.shapes[0].it.push({
                                p: {
                                  k: [0, 0],
                                  a: 0
                                },
                                s: {
                                  k: [100, 100],
                                  a: 0
                                },
                                a: {
                                  k: [0, 0],
                                  a: 0
                                },
                                r: {
                                  k: 0,
                                  a: 0
                                },
                                o: {
                                  k: 100,
                                  a: 0
                                },
                                sk: {
                                  k: 0,
                                  a: 0
                                },
                                sa: {
                                  k: 0,
                                  a: 0
                                },
                                ty: "tr"
                              });
                            }
                          }
                        }
                      }
                    };
                  }();
                  var checkPathProperties = /* @__PURE__ */ function() {
                    var minimumVersion = [5, 7, 15];
                    function updateTextLayer(textLayer) {
                      var pathData = textLayer.t.p;
                      if (typeof pathData.a === "number") {
                        pathData.a = {
                          a: 0,
                          k: pathData.a
                        };
                      }
                      if (typeof pathData.p === "number") {
                        pathData.p = {
                          a: 0,
                          k: pathData.p
                        };
                      }
                      if (typeof pathData.r === "number") {
                        pathData.r = {
                          a: 0,
                          k: pathData.r
                        };
                      }
                    }
                    function iterateLayers(layers) {
                      var i6;
                      var len = layers.length;
                      for (i6 = 0; i6 < len; i6 += 1) {
                        if (layers[i6].ty === 5) {
                          updateTextLayer(layers[i6]);
                        }
                      }
                    }
                    return function(animationData2) {
                      if (checkVersion(minimumVersion, animationData2.v)) {
                        iterateLayers(animationData2.layers);
                        if (animationData2.assets) {
                          var i6;
                          var len = animationData2.assets.length;
                          for (i6 = 0; i6 < len; i6 += 1) {
                            if (animationData2.assets[i6].layers) {
                              iterateLayers(animationData2.assets[i6].layers);
                            }
                          }
                        }
                      }
                    };
                  }();
                  var checkColors = /* @__PURE__ */ function() {
                    var minimumVersion = [4, 1, 9];
                    function iterateShapes(shapes) {
                      var i6;
                      var len = shapes.length;
                      var j3;
                      var jLen;
                      for (i6 = 0; i6 < len; i6 += 1) {
                        if (shapes[i6].ty === "gr") {
                          iterateShapes(shapes[i6].it);
                        } else if (shapes[i6].ty === "fl" || shapes[i6].ty === "st") {
                          if (shapes[i6].c.k && shapes[i6].c.k[0].i) {
                            jLen = shapes[i6].c.k.length;
                            for (j3 = 0; j3 < jLen; j3 += 1) {
                              if (shapes[i6].c.k[j3].s) {
                                shapes[i6].c.k[j3].s[0] /= 255;
                                shapes[i6].c.k[j3].s[1] /= 255;
                                shapes[i6].c.k[j3].s[2] /= 255;
                                shapes[i6].c.k[j3].s[3] /= 255;
                              }
                              if (shapes[i6].c.k[j3].e) {
                                shapes[i6].c.k[j3].e[0] /= 255;
                                shapes[i6].c.k[j3].e[1] /= 255;
                                shapes[i6].c.k[j3].e[2] /= 255;
                                shapes[i6].c.k[j3].e[3] /= 255;
                              }
                            }
                          } else {
                            shapes[i6].c.k[0] /= 255;
                            shapes[i6].c.k[1] /= 255;
                            shapes[i6].c.k[2] /= 255;
                            shapes[i6].c.k[3] /= 255;
                          }
                        }
                      }
                    }
                    function iterateLayers(layers) {
                      var i6;
                      var len = layers.length;
                      for (i6 = 0; i6 < len; i6 += 1) {
                        if (layers[i6].ty === 4) {
                          iterateShapes(layers[i6].shapes);
                        }
                      }
                    }
                    return function(animationData2) {
                      if (checkVersion(minimumVersion, animationData2.v)) {
                        iterateLayers(animationData2.layers);
                        if (animationData2.assets) {
                          var i6;
                          var len = animationData2.assets.length;
                          for (i6 = 0; i6 < len; i6 += 1) {
                            if (animationData2.assets[i6].layers) {
                              iterateLayers(animationData2.assets[i6].layers);
                            }
                          }
                        }
                      }
                    };
                  }();
                  var checkShapes = /* @__PURE__ */ function() {
                    var minimumVersion = [4, 4, 18];
                    function completeClosingShapes(arr) {
                      var i6;
                      var len = arr.length;
                      var j3;
                      var jLen;
                      for (i6 = len - 1; i6 >= 0; i6 -= 1) {
                        if (arr[i6].ty === "sh") {
                          if (arr[i6].ks.k.i) {
                            arr[i6].ks.k.c = arr[i6].closed;
                          } else {
                            jLen = arr[i6].ks.k.length;
                            for (j3 = 0; j3 < jLen; j3 += 1) {
                              if (arr[i6].ks.k[j3].s) {
                                arr[i6].ks.k[j3].s[0].c = arr[i6].closed;
                              }
                              if (arr[i6].ks.k[j3].e) {
                                arr[i6].ks.k[j3].e[0].c = arr[i6].closed;
                              }
                            }
                          }
                        } else if (arr[i6].ty === "gr") {
                          completeClosingShapes(arr[i6].it);
                        }
                      }
                    }
                    function iterateLayers(layers) {
                      var layerData;
                      var i6;
                      var len = layers.length;
                      var j3;
                      var jLen;
                      var k3;
                      var kLen;
                      for (i6 = 0; i6 < len; i6 += 1) {
                        layerData = layers[i6];
                        if (layerData.hasMask) {
                          var maskProps = layerData.masksProperties;
                          jLen = maskProps.length;
                          for (j3 = 0; j3 < jLen; j3 += 1) {
                            if (maskProps[j3].pt.k.i) {
                              maskProps[j3].pt.k.c = maskProps[j3].cl;
                            } else {
                              kLen = maskProps[j3].pt.k.length;
                              for (k3 = 0; k3 < kLen; k3 += 1) {
                                if (maskProps[j3].pt.k[k3].s) {
                                  maskProps[j3].pt.k[k3].s[0].c = maskProps[j3].cl;
                                }
                                if (maskProps[j3].pt.k[k3].e) {
                                  maskProps[j3].pt.k[k3].e[0].c = maskProps[j3].cl;
                                }
                              }
                            }
                          }
                        }
                        if (layerData.ty === 4) {
                          completeClosingShapes(layerData.shapes);
                        }
                      }
                    }
                    return function(animationData2) {
                      if (checkVersion(minimumVersion, animationData2.v)) {
                        iterateLayers(animationData2.layers);
                        if (animationData2.assets) {
                          var i6;
                          var len = animationData2.assets.length;
                          for (i6 = 0; i6 < len; i6 += 1) {
                            if (animationData2.assets[i6].layers) {
                              iterateLayers(animationData2.assets[i6].layers);
                            }
                          }
                        }
                      }
                    };
                  }();
                  function completeData(animationData2) {
                    if (animationData2.__complete) {
                      return;
                    }
                    checkColors(animationData2);
                    checkText(animationData2);
                    checkChars(animationData2);
                    checkPathProperties(animationData2);
                    checkShapes(animationData2);
                    completeLayers(animationData2.layers, animationData2.assets);
                    completeChars(animationData2.chars, animationData2.assets);
                    animationData2.__complete = true;
                  }
                  function completeText(data2) {
                    if (data2.t.a.length === 0 && !("m" in data2.t.p)) {
                    }
                  }
                  var moduleOb = {};
                  moduleOb.completeData = completeData;
                  moduleOb.checkColors = checkColors;
                  moduleOb.checkChars = checkChars;
                  moduleOb.checkPathProperties = checkPathProperties;
                  moduleOb.checkShapes = checkShapes;
                  moduleOb.completeLayers = completeLayers;
                  return moduleOb;
                }
                if (!_workerSelf.dataManager) {
                  _workerSelf.dataManager = dataFunctionManager();
                }
                if (!_workerSelf.assetLoader) {
                  _workerSelf.assetLoader = /* @__PURE__ */ function() {
                    function formatResponse(xhr) {
                      var contentTypeHeader = xhr.getResponseHeader("content-type");
                      if (contentTypeHeader && xhr.responseType === "json" && contentTypeHeader.indexOf("json") !== -1) {
                        return xhr.response;
                      }
                      if (xhr.response && _typeof$5(xhr.response) === "object") {
                        return xhr.response;
                      }
                      if (xhr.response && typeof xhr.response === "string") {
                        return JSON.parse(xhr.response);
                      }
                      if (xhr.responseText) {
                        return JSON.parse(xhr.responseText);
                      }
                      return null;
                    }
                    function loadAsset(path, fullPath, callback, errorCallback) {
                      var response;
                      var xhr = new XMLHttpRequest();
                      try {
                        xhr.responseType = "json";
                      } catch (err) {
                      }
                      xhr.onreadystatechange = function() {
                        if (xhr.readyState === 4) {
                          if (xhr.status === 200) {
                            response = formatResponse(xhr);
                            callback(response);
                          } else {
                            try {
                              response = formatResponse(xhr);
                              callback(response);
                            } catch (err) {
                              if (errorCallback) {
                                errorCallback(err);
                              }
                            }
                          }
                        }
                      };
                      try {
                        xhr.open(["G", "E", "T"].join(""), path, true);
                      } catch (error) {
                        xhr.open(["G", "E", "T"].join(""), fullPath + "/" + path, true);
                      }
                      xhr.send();
                    }
                    return {
                      load: loadAsset
                    };
                  }();
                }
                if (e5.data.type === "loadAnimation") {
                  _workerSelf.assetLoader.load(e5.data.path, e5.data.fullPath, function(data2) {
                    _workerSelf.dataManager.completeData(data2);
                    _workerSelf.postMessage({
                      id: e5.data.id,
                      payload: data2,
                      status: "success"
                    });
                  }, function() {
                    _workerSelf.postMessage({
                      id: e5.data.id,
                      status: "error"
                    });
                  });
                } else if (e5.data.type === "complete") {
                  var animation = e5.data.animation;
                  _workerSelf.dataManager.completeData(animation);
                  _workerSelf.postMessage({
                    id: e5.data.id,
                    payload: animation,
                    status: "success"
                  });
                } else if (e5.data.type === "loadData") {
                  _workerSelf.assetLoader.load(e5.data.path, e5.data.fullPath, function(data2) {
                    _workerSelf.postMessage({
                      id: e5.data.id,
                      payload: data2,
                      status: "success"
                    });
                  }, function() {
                    _workerSelf.postMessage({
                      id: e5.data.id,
                      status: "error"
                    });
                  });
                }
              });
              workerInstance.onmessage = function(event2) {
                var data2 = event2.data;
                var id = data2.id;
                var process2 = processes[id];
                processes[id] = null;
                if (data2.status === "success") {
                  process2.onComplete(data2.payload);
                } else if (process2.onError) {
                  process2.onError();
                }
              };
            }
          }
          function createProcess(onComplete, onError) {
            _counterId += 1;
            var id = "processId_" + _counterId;
            processes[id] = {
              onComplete,
              onError
            };
            return id;
          }
          function loadAnimation2(path, onComplete, onError) {
            setupWorker();
            var processId = createProcess(onComplete, onError);
            workerInstance.postMessage({
              type: "loadAnimation",
              path,
              fullPath: window.location.origin + window.location.pathname,
              id: processId
            });
          }
          function loadData(path, onComplete, onError) {
            setupWorker();
            var processId = createProcess(onComplete, onError);
            workerInstance.postMessage({
              type: "loadData",
              path,
              fullPath: window.location.origin + window.location.pathname,
              id: processId
            });
          }
          function completeAnimation(anim, onComplete, onError) {
            setupWorker();
            var processId = createProcess(onComplete, onError);
            workerInstance.postMessage({
              type: "complete",
              animation: anim,
              id: processId
            });
          }
          return {
            loadAnimation: loadAnimation2,
            loadData,
            completeAnimation
          };
        }();
        var ImagePreloader = function() {
          var proxyImage = function() {
            var canvas = createTag("canvas");
            canvas.width = 1;
            canvas.height = 1;
            var ctx = canvas.getContext("2d");
            ctx.fillStyle = "rgba(0,0,0,0)";
            ctx.fillRect(0, 0, 1, 1);
            return canvas;
          }();
          function imageLoaded() {
            this.loadedAssets += 1;
            if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
              if (this.imagesLoadedCb) {
                this.imagesLoadedCb(null);
              }
            }
          }
          function footageLoaded() {
            this.loadedFootagesCount += 1;
            if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
              if (this.imagesLoadedCb) {
                this.imagesLoadedCb(null);
              }
            }
          }
          function getAssetsPath(assetData, assetsPath, originalPath) {
            var path = "";
            if (assetData.e) {
              path = assetData.p;
            } else if (assetsPath) {
              var imagePath = assetData.p;
              if (imagePath.indexOf("images/") !== -1) {
                imagePath = imagePath.split("/")[1];
              }
              path = assetsPath + imagePath;
            } else {
              path = originalPath;
              path += assetData.u ? assetData.u : "";
              path += assetData.p;
            }
            return path;
          }
          function testImageLoaded(img) {
            var _count = 0;
            var intervalId = setInterval(function() {
              var box = img.getBBox();
              if (box.width || _count > 500) {
                this._imageLoaded();
                clearInterval(intervalId);
              }
              _count += 1;
            }.bind(this), 50);
          }
          function createImageData(assetData) {
            var path = getAssetsPath(assetData, this.assetsPath, this.path);
            var img = createNS("image");
            if (isSafari) {
              this.testImageLoaded(img);
            } else {
              img.addEventListener("load", this._imageLoaded, false);
            }
            img.addEventListener("error", function() {
              ob2.img = proxyImage;
              this._imageLoaded();
            }.bind(this), false);
            img.setAttributeNS("http://www.w3.org/1999/xlink", "href", path);
            if (this._elementHelper.append) {
              this._elementHelper.append(img);
            } else {
              this._elementHelper.appendChild(img);
            }
            var ob2 = {
              img,
              assetData
            };
            return ob2;
          }
          function createImgData(assetData) {
            var path = getAssetsPath(assetData, this.assetsPath, this.path);
            var img = createTag("img");
            img.crossOrigin = "anonymous";
            img.addEventListener("load", this._imageLoaded, false);
            img.addEventListener("error", function() {
              ob2.img = proxyImage;
              this._imageLoaded();
            }.bind(this), false);
            img.src = path;
            var ob2 = {
              img,
              assetData
            };
            return ob2;
          }
          function createFootageData(data2) {
            var ob2 = {
              assetData: data2
            };
            var path = getAssetsPath(data2, this.assetsPath, this.path);
            dataManager.loadData(path, function(footageData) {
              ob2.img = footageData;
              this._footageLoaded();
            }.bind(this), function() {
              ob2.img = {};
              this._footageLoaded();
            }.bind(this));
            return ob2;
          }
          function loadAssets(assets, cb) {
            this.imagesLoadedCb = cb;
            var i6;
            var len = assets.length;
            for (i6 = 0; i6 < len; i6 += 1) {
              if (!assets[i6].layers) {
                if (!assets[i6].t || assets[i6].t === "seq") {
                  this.totalImages += 1;
                  this.images.push(this._createImageData(assets[i6]));
                } else if (assets[i6].t === 3) {
                  this.totalFootages += 1;
                  this.images.push(this.createFootageData(assets[i6]));
                }
              }
            }
          }
          function setPath(path) {
            this.path = path || "";
          }
          function setAssetsPath(path) {
            this.assetsPath = path || "";
          }
          function getAsset(assetData) {
            var i6 = 0;
            var len = this.images.length;
            while (i6 < len) {
              if (this.images[i6].assetData === assetData) {
                return this.images[i6].img;
              }
              i6 += 1;
            }
            return null;
          }
          function destroy() {
            this.imagesLoadedCb = null;
            this.images.length = 0;
          }
          function loadedImages() {
            return this.totalImages === this.loadedAssets;
          }
          function loadedFootages() {
            return this.totalFootages === this.loadedFootagesCount;
          }
          function setCacheType(type, elementHelper) {
            if (type === "svg") {
              this._elementHelper = elementHelper;
              this._createImageData = this.createImageData.bind(this);
            } else {
              this._createImageData = this.createImgData.bind(this);
            }
          }
          function ImagePreloaderFactory() {
            this._imageLoaded = imageLoaded.bind(this);
            this._footageLoaded = footageLoaded.bind(this);
            this.testImageLoaded = testImageLoaded.bind(this);
            this.createFootageData = createFootageData.bind(this);
            this.assetsPath = "";
            this.path = "";
            this.totalImages = 0;
            this.totalFootages = 0;
            this.loadedAssets = 0;
            this.loadedFootagesCount = 0;
            this.imagesLoadedCb = null;
            this.images = [];
          }
          ImagePreloaderFactory.prototype = {
            loadAssets,
            setAssetsPath,
            setPath,
            loadedImages,
            loadedFootages,
            destroy,
            getAsset,
            createImgData,
            createImageData,
            imageLoaded,
            footageLoaded,
            setCacheType
          };
          return ImagePreloaderFactory;
        }();
        function BaseEvent() {
        }
        BaseEvent.prototype = {
          triggerEvent: function triggerEvent(eventName, args) {
            if (this._cbs[eventName]) {
              var callbacks = this._cbs[eventName];
              for (var i6 = 0; i6 < callbacks.length; i6 += 1) {
                callbacks[i6](args);
              }
            }
          },
          addEventListener: function addEventListener2(eventName, callback) {
            if (!this._cbs[eventName]) {
              this._cbs[eventName] = [];
            }
            this._cbs[eventName].push(callback);
            return function() {
              this.removeEventListener(eventName, callback);
            }.bind(this);
          },
          removeEventListener: function removeEventListener2(eventName, callback) {
            if (!callback) {
              this._cbs[eventName] = null;
            } else if (this._cbs[eventName]) {
              var i6 = 0;
              var len = this._cbs[eventName].length;
              while (i6 < len) {
                if (this._cbs[eventName][i6] === callback) {
                  this._cbs[eventName].splice(i6, 1);
                  i6 -= 1;
                  len -= 1;
                }
                i6 += 1;
              }
              if (!this._cbs[eventName].length) {
                this._cbs[eventName] = null;
              }
            }
          }
        };
        var markerParser = /* @__PURE__ */ function() {
          function parsePayloadLines(payload) {
            var lines = payload.split("\r\n");
            var keys = {};
            var line;
            var keysCount = 0;
            for (var i6 = 0; i6 < lines.length; i6 += 1) {
              line = lines[i6].split(":");
              if (line.length === 2) {
                keys[line[0]] = line[1].trim();
                keysCount += 1;
              }
            }
            if (keysCount === 0) {
              throw new Error();
            }
            return keys;
          }
          return function(_markers) {
            var markers = [];
            for (var i6 = 0; i6 < _markers.length; i6 += 1) {
              var _marker = _markers[i6];
              var markerData = {
                time: _marker.tm,
                duration: _marker.dr
              };
              try {
                markerData.payload = JSON.parse(_markers[i6].cm);
              } catch (_3) {
                try {
                  markerData.payload = parsePayloadLines(_markers[i6].cm);
                } catch (__) {
                  markerData.payload = {
                    name: _markers[i6].cm
                  };
                }
              }
              markers.push(markerData);
            }
            return markers;
          };
        }();
        var ProjectInterface = /* @__PURE__ */ function() {
          function registerComposition(comp2) {
            this.compositions.push(comp2);
          }
          return function() {
            function _thisProjectFunction(name2) {
              var i6 = 0;
              var len = this.compositions.length;
              while (i6 < len) {
                if (this.compositions[i6].data && this.compositions[i6].data.nm === name2) {
                  if (this.compositions[i6].prepareFrame && this.compositions[i6].data.xt) {
                    this.compositions[i6].prepareFrame(this.currentFrame);
                  }
                  return this.compositions[i6].compInterface;
                }
                i6 += 1;
              }
              return null;
            }
            _thisProjectFunction.compositions = [];
            _thisProjectFunction.currentFrame = 0;
            _thisProjectFunction.registerComposition = registerComposition;
            return _thisProjectFunction;
          };
        }();
        var renderers = {};
        var registerRenderer = function registerRenderer2(key2, value2) {
          renderers[key2] = value2;
        };
        function getRenderer(key2) {
          return renderers[key2];
        }
        function getRegisteredRenderer() {
          if (renderers.canvas) {
            return "canvas";
          }
          for (var key2 in renderers) {
            if (renderers[key2]) {
              return key2;
            }
          }
          return "";
        }
        function _typeof$4(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof$4 = function _typeof3(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof$4 = function _typeof3(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof$4(obj);
        }
        var AnimationItem = function AnimationItem2() {
          this._cbs = [];
          this.name = "";
          this.path = "";
          this.isLoaded = false;
          this.currentFrame = 0;
          this.currentRawFrame = 0;
          this.firstFrame = 0;
          this.totalFrames = 0;
          this.frameRate = 0;
          this.frameMult = 0;
          this.playSpeed = 1;
          this.playDirection = 1;
          this.playCount = 0;
          this.animationData = {};
          this.assets = [];
          this.isPaused = true;
          this.autoplay = false;
          this.loop = true;
          this.renderer = null;
          this.animationID = createElementID();
          this.assetsPath = "";
          this.timeCompleted = 0;
          this.segmentPos = 0;
          this.isSubframeEnabled = getSubframeEnabled();
          this.segments = [];
          this._idle = true;
          this._completedLoop = false;
          this.projectInterface = ProjectInterface();
          this.imagePreloader = new ImagePreloader();
          this.audioController = audioControllerFactory();
          this.markers = [];
          this.configAnimation = this.configAnimation.bind(this);
          this.onSetupError = this.onSetupError.bind(this);
          this.onSegmentComplete = this.onSegmentComplete.bind(this);
          this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame", 0, 0, 0);
          this.expressionsPlugin = getExpressionsPlugin();
        };
        extendPrototype([BaseEvent], AnimationItem);
        AnimationItem.prototype.setParams = function(params) {
          if (params.wrapper || params.container) {
            this.wrapper = params.wrapper || params.container;
          }
          var animType = "svg";
          if (params.animType) {
            animType = params.animType;
          } else if (params.renderer) {
            animType = params.renderer;
          }
          var RendererClass = getRenderer(animType);
          this.renderer = new RendererClass(this, params.rendererSettings);
          this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);
          this.renderer.setProjectInterface(this.projectInterface);
          this.animType = animType;
          if (params.loop === "" || params.loop === null || params.loop === void 0 || params.loop === true) {
            this.loop = true;
          } else if (params.loop === false) {
            this.loop = false;
          } else {
            this.loop = parseInt(params.loop, 10);
          }
          this.autoplay = "autoplay" in params ? params.autoplay : true;
          this.name = params.name ? params.name : "";
          this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, "autoloadSegments") ? params.autoloadSegments : true;
          this.assetsPath = params.assetsPath;
          this.initialSegment = params.initialSegment;
          if (params.audioFactory) {
            this.audioController.setAudioFactory(params.audioFactory);
          }
          if (params.animationData) {
            this.setupAnimation(params.animationData);
          } else if (params.path) {
            if (params.path.lastIndexOf("\\") !== -1) {
              this.path = params.path.substr(0, params.path.lastIndexOf("\\") + 1);
            } else {
              this.path = params.path.substr(0, params.path.lastIndexOf("/") + 1);
            }
            this.fileName = params.path.substr(params.path.lastIndexOf("/") + 1);
            this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json"));
            dataManager.loadAnimation(params.path, this.configAnimation, this.onSetupError);
          }
        };
        AnimationItem.prototype.onSetupError = function() {
          this.trigger("data_failed");
        };
        AnimationItem.prototype.setupAnimation = function(data2) {
          dataManager.completeAnimation(data2, this.configAnimation);
        };
        AnimationItem.prototype.setData = function(wrapper, animationData2) {
          if (animationData2) {
            if (_typeof$4(animationData2) !== "object") {
              animationData2 = JSON.parse(animationData2);
            }
          }
          var params = {
            wrapper,
            animationData: animationData2
          };
          var wrapperAttributes = wrapper.attributes;
          params.path = wrapperAttributes.getNamedItem("data-animation-path") ? wrapperAttributes.getNamedItem("data-animation-path").value : wrapperAttributes.getNamedItem("data-bm-path") ? wrapperAttributes.getNamedItem("data-bm-path").value : wrapperAttributes.getNamedItem("bm-path") ? wrapperAttributes.getNamedItem("bm-path").value : "";
          params.animType = wrapperAttributes.getNamedItem("data-anim-type") ? wrapperAttributes.getNamedItem("data-anim-type").value : wrapperAttributes.getNamedItem("data-bm-type") ? wrapperAttributes.getNamedItem("data-bm-type").value : wrapperAttributes.getNamedItem("bm-type") ? wrapperAttributes.getNamedItem("bm-type").value : wrapperAttributes.getNamedItem("data-bm-renderer") ? wrapperAttributes.getNamedItem("data-bm-renderer").value : wrapperAttributes.getNamedItem("bm-renderer") ? wrapperAttributes.getNamedItem("bm-renderer").value : getRegisteredRenderer() || "canvas";
          var loop2 = wrapperAttributes.getNamedItem("data-anim-loop") ? wrapperAttributes.getNamedItem("data-anim-loop").value : wrapperAttributes.getNamedItem("data-bm-loop") ? wrapperAttributes.getNamedItem("data-bm-loop").value : wrapperAttributes.getNamedItem("bm-loop") ? wrapperAttributes.getNamedItem("bm-loop").value : "";
          if (loop2 === "false") {
            params.loop = false;
          } else if (loop2 === "true") {
            params.loop = true;
          } else if (loop2 !== "") {
            params.loop = parseInt(loop2, 10);
          }
          var autoplay = wrapperAttributes.getNamedItem("data-anim-autoplay") ? wrapperAttributes.getNamedItem("data-anim-autoplay").value : wrapperAttributes.getNamedItem("data-bm-autoplay") ? wrapperAttributes.getNamedItem("data-bm-autoplay").value : wrapperAttributes.getNamedItem("bm-autoplay") ? wrapperAttributes.getNamedItem("bm-autoplay").value : true;
          params.autoplay = autoplay !== "false";
          params.name = wrapperAttributes.getNamedItem("data-name") ? wrapperAttributes.getNamedItem("data-name").value : wrapperAttributes.getNamedItem("data-bm-name") ? wrapperAttributes.getNamedItem("data-bm-name").value : wrapperAttributes.getNamedItem("bm-name") ? wrapperAttributes.getNamedItem("bm-name").value : "";
          var prerender = wrapperAttributes.getNamedItem("data-anim-prerender") ? wrapperAttributes.getNamedItem("data-anim-prerender").value : wrapperAttributes.getNamedItem("data-bm-prerender") ? wrapperAttributes.getNamedItem("data-bm-prerender").value : wrapperAttributes.getNamedItem("bm-prerender") ? wrapperAttributes.getNamedItem("bm-prerender").value : "";
          if (prerender === "false") {
            params.prerender = false;
          }
          if (!params.path) {
            this.trigger("destroy");
          } else {
            this.setParams(params);
          }
        };
        AnimationItem.prototype.includeLayers = function(data2) {
          if (data2.op > this.animationData.op) {
            this.animationData.op = data2.op;
            this.totalFrames = Math.floor(data2.op - this.animationData.ip);
          }
          var layers = this.animationData.layers;
          var i6;
          var len = layers.length;
          var newLayers = data2.layers;
          var j3;
          var jLen = newLayers.length;
          for (j3 = 0; j3 < jLen; j3 += 1) {
            i6 = 0;
            while (i6 < len) {
              if (layers[i6].id === newLayers[j3].id) {
                layers[i6] = newLayers[j3];
                break;
              }
              i6 += 1;
            }
          }
          if (data2.chars || data2.fonts) {
            this.renderer.globalData.fontManager.addChars(data2.chars);
            this.renderer.globalData.fontManager.addFonts(data2.fonts, this.renderer.globalData.defs);
          }
          if (data2.assets) {
            len = data2.assets.length;
            for (i6 = 0; i6 < len; i6 += 1) {
              this.animationData.assets.push(data2.assets[i6]);
            }
          }
          this.animationData.__complete = false;
          dataManager.completeAnimation(this.animationData, this.onSegmentComplete);
        };
        AnimationItem.prototype.onSegmentComplete = function(data2) {
          this.animationData = data2;
          var expressionsPlugin2 = getExpressionsPlugin();
          if (expressionsPlugin2) {
            expressionsPlugin2.initExpressions(this);
          }
          this.loadNextSegment();
        };
        AnimationItem.prototype.loadNextSegment = function() {
          var segments = this.animationData.segments;
          if (!segments || segments.length === 0 || !this.autoloadSegments) {
            this.trigger("data_ready");
            this.timeCompleted = this.totalFrames;
            return;
          }
          var segment = segments.shift();
          this.timeCompleted = segment.time * this.frameRate;
          var segmentPath = this.path + this.fileName + "_" + this.segmentPos + ".json";
          this.segmentPos += 1;
          dataManager.loadData(segmentPath, this.includeLayers.bind(this), function() {
            this.trigger("data_failed");
          }.bind(this));
        };
        AnimationItem.prototype.loadSegments = function() {
          var segments = this.animationData.segments;
          if (!segments) {
            this.timeCompleted = this.totalFrames;
          }
          this.loadNextSegment();
        };
        AnimationItem.prototype.imagesLoaded = function() {
          this.trigger("loaded_images");
          this.checkLoaded();
        };
        AnimationItem.prototype.preloadImages = function() {
          this.imagePreloader.setAssetsPath(this.assetsPath);
          this.imagePreloader.setPath(this.path);
          this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
        };
        AnimationItem.prototype.configAnimation = function(animData) {
          if (!this.renderer) {
            return;
          }
          try {
            this.animationData = animData;
            if (this.initialSegment) {
              this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);
              this.firstFrame = Math.round(this.initialSegment[0]);
            } else {
              this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
              this.firstFrame = Math.round(this.animationData.ip);
            }
            this.renderer.configAnimation(animData);
            if (!animData.assets) {
              animData.assets = [];
            }
            this.assets = this.animationData.assets;
            this.frameRate = this.animationData.fr;
            this.frameMult = this.animationData.fr / 1e3;
            this.renderer.searchExtraCompositions(animData.assets);
            this.markers = markerParser(animData.markers || []);
            this.trigger("config_ready");
            this.preloadImages();
            this.loadSegments();
            this.updaFrameModifier();
            this.waitForFontsLoaded();
            if (this.isPaused) {
              this.audioController.pause();
            }
          } catch (error) {
            this.triggerConfigError(error);
          }
        };
        AnimationItem.prototype.waitForFontsLoaded = function() {
          if (!this.renderer) {
            return;
          }
          if (this.renderer.globalData.fontManager.isLoaded) {
            this.checkLoaded();
          } else {
            setTimeout(this.waitForFontsLoaded.bind(this), 20);
          }
        };
        AnimationItem.prototype.checkLoaded = function() {
          if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== "canvas") && this.imagePreloader.loadedFootages()) {
            this.isLoaded = true;
            var expressionsPlugin2 = getExpressionsPlugin();
            if (expressionsPlugin2) {
              expressionsPlugin2.initExpressions(this);
            }
            this.renderer.initItems();
            setTimeout(function() {
              this.trigger("DOMLoaded");
            }.bind(this), 0);
            this.gotoFrame();
            if (this.autoplay) {
              this.play();
            }
          }
        };
        AnimationItem.prototype.resize = function(width2, height2) {
          var _width = typeof width2 === "number" ? width2 : void 0;
          var _height = typeof height2 === "number" ? height2 : void 0;
          this.renderer.updateContainerSize(_width, _height);
        };
        AnimationItem.prototype.setSubframe = function(flag) {
          this.isSubframeEnabled = !!flag;
        };
        AnimationItem.prototype.gotoFrame = function() {
          this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame;
          if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {
            this.currentFrame = this.timeCompleted;
          }
          this.trigger("enterFrame");
          this.renderFrame();
          this.trigger("drawnFrame");
        };
        AnimationItem.prototype.renderFrame = function() {
          if (this.isLoaded === false || !this.renderer) {
            return;
          }
          try {
            if (this.expressionsPlugin) {
              this.expressionsPlugin.resetFrame();
            }
            this.renderer.renderFrame(this.currentFrame + this.firstFrame);
          } catch (error) {
            this.triggerRenderFrameError(error);
          }
        };
        AnimationItem.prototype.play = function(name2) {
          if (name2 && this.name !== name2) {
            return;
          }
          if (this.isPaused === true) {
            this.isPaused = false;
            this.trigger("_play");
            this.audioController.resume();
            if (this._idle) {
              this._idle = false;
              this.trigger("_active");
            }
          }
        };
        AnimationItem.prototype.pause = function(name2) {
          if (name2 && this.name !== name2) {
            return;
          }
          if (this.isPaused === false) {
            this.isPaused = true;
            this.trigger("_pause");
            this._idle = true;
            this.trigger("_idle");
            this.audioController.pause();
          }
        };
        AnimationItem.prototype.togglePause = function(name2) {
          if (name2 && this.name !== name2) {
            return;
          }
          if (this.isPaused === true) {
            this.play();
          } else {
            this.pause();
          }
        };
        AnimationItem.prototype.stop = function(name2) {
          if (name2 && this.name !== name2) {
            return;
          }
          this.pause();
          this.playCount = 0;
          this._completedLoop = false;
          this.setCurrentRawFrameValue(0);
        };
        AnimationItem.prototype.getMarkerData = function(markerName) {
          var marker;
          for (var i6 = 0; i6 < this.markers.length; i6 += 1) {
            marker = this.markers[i6];
            if (marker.payload && marker.payload.name === markerName) {
              return marker;
            }
          }
          return null;
        };
        AnimationItem.prototype.goToAndStop = function(value2, isFrame, name2) {
          if (name2 && this.name !== name2) {
            return;
          }
          var numValue = Number(value2);
          if (isNaN(numValue)) {
            var marker = this.getMarkerData(value2);
            if (marker) {
              this.goToAndStop(marker.time, true);
            }
          } else if (isFrame) {
            this.setCurrentRawFrameValue(value2);
          } else {
            this.setCurrentRawFrameValue(value2 * this.frameModifier);
          }
          this.pause();
        };
        AnimationItem.prototype.goToAndPlay = function(value2, isFrame, name2) {
          if (name2 && this.name !== name2) {
            return;
          }
          var numValue = Number(value2);
          if (isNaN(numValue)) {
            var marker = this.getMarkerData(value2);
            if (marker) {
              if (!marker.duration) {
                this.goToAndStop(marker.time, true);
              } else {
                this.playSegments([marker.time, marker.time + marker.duration], true);
              }
            }
          } else {
            this.goToAndStop(numValue, isFrame, name2);
          }
          this.play();
        };
        AnimationItem.prototype.advanceTime = function(value2) {
          if (this.isPaused === true || this.isLoaded === false) {
            return;
          }
          var nextValue = this.currentRawFrame + value2 * this.frameModifier;
          var _isComplete = false;
          if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {
            if (!this.loop || this.playCount === this.loop) {
              if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {
                _isComplete = true;
                nextValue = this.totalFrames - 1;
              }
            } else if (nextValue >= this.totalFrames) {
              this.playCount += 1;
              if (!this.checkSegments(nextValue % this.totalFrames)) {
                this.setCurrentRawFrameValue(nextValue % this.totalFrames);
                this._completedLoop = true;
                this.trigger("loopComplete");
              }
            } else {
              this.setCurrentRawFrameValue(nextValue);
            }
          } else if (nextValue < 0) {
            if (!this.checkSegments(nextValue % this.totalFrames)) {
              if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {
                this.setCurrentRawFrameValue(this.totalFrames + nextValue % this.totalFrames);
                if (!this._completedLoop) {
                  this._completedLoop = true;
                } else {
                  this.trigger("loopComplete");
                }
              } else {
                _isComplete = true;
                nextValue = 0;
              }
            }
          } else {
            this.setCurrentRawFrameValue(nextValue);
          }
          if (_isComplete) {
            this.setCurrentRawFrameValue(nextValue);
            this.pause();
            this.trigger("complete");
          }
        };
        AnimationItem.prototype.adjustSegment = function(arr, offset) {
          this.playCount = 0;
          if (arr[1] < arr[0]) {
            if (this.frameModifier > 0) {
              if (this.playSpeed < 0) {
                this.setSpeed(-this.playSpeed);
              } else {
                this.setDirection(-1);
              }
            }
            this.totalFrames = arr[0] - arr[1];
            this.timeCompleted = this.totalFrames;
            this.firstFrame = arr[1];
            this.setCurrentRawFrameValue(this.totalFrames - 1e-3 - offset);
          } else if (arr[1] > arr[0]) {
            if (this.frameModifier < 0) {
              if (this.playSpeed < 0) {
                this.setSpeed(-this.playSpeed);
              } else {
                this.setDirection(1);
              }
            }
            this.totalFrames = arr[1] - arr[0];
            this.timeCompleted = this.totalFrames;
            this.firstFrame = arr[0];
            this.setCurrentRawFrameValue(1e-3 + offset);
          }
          this.trigger("segmentStart");
        };
        AnimationItem.prototype.setSegment = function(init5, end) {
          var pendingFrame = -1;
          if (this.isPaused) {
            if (this.currentRawFrame + this.firstFrame < init5) {
              pendingFrame = init5;
            } else if (this.currentRawFrame + this.firstFrame > end) {
              pendingFrame = end - init5;
            }
          }
          this.firstFrame = init5;
          this.totalFrames = end - init5;
          this.timeCompleted = this.totalFrames;
          if (pendingFrame !== -1) {
            this.goToAndStop(pendingFrame, true);
          }
        };
        AnimationItem.prototype.playSegments = function(arr, forceFlag) {
          if (forceFlag) {
            this.segments.length = 0;
          }
          if (_typeof$4(arr[0]) === "object") {
            var i6;
            var len = arr.length;
            for (i6 = 0; i6 < len; i6 += 1) {
              this.segments.push(arr[i6]);
            }
          } else {
            this.segments.push(arr);
          }
          if (this.segments.length && forceFlag) {
            this.adjustSegment(this.segments.shift(), 0);
          }
          if (this.isPaused) {
            this.play();
          }
        };
        AnimationItem.prototype.resetSegments = function(forceFlag) {
          this.segments.length = 0;
          this.segments.push([this.animationData.ip, this.animationData.op]);
          if (forceFlag) {
            this.checkSegments(0);
          }
        };
        AnimationItem.prototype.checkSegments = function(offset) {
          if (this.segments.length) {
            this.adjustSegment(this.segments.shift(), offset);
            return true;
          }
          return false;
        };
        AnimationItem.prototype.destroy = function(name2) {
          if (name2 && this.name !== name2 || !this.renderer) {
            return;
          }
          this.renderer.destroy();
          this.imagePreloader.destroy();
          this.trigger("destroy");
          this._cbs = null;
          this.onEnterFrame = null;
          this.onLoopComplete = null;
          this.onComplete = null;
          this.onSegmentStart = null;
          this.onDestroy = null;
          this.renderer = null;
          this.expressionsPlugin = null;
          this.imagePreloader = null;
          this.projectInterface = null;
        };
        AnimationItem.prototype.setCurrentRawFrameValue = function(value2) {
          this.currentRawFrame = value2;
          this.gotoFrame();
        };
        AnimationItem.prototype.setSpeed = function(val2) {
          this.playSpeed = val2;
          this.updaFrameModifier();
        };
        AnimationItem.prototype.setDirection = function(val2) {
          this.playDirection = val2 < 0 ? -1 : 1;
          this.updaFrameModifier();
        };
        AnimationItem.prototype.setLoop = function(isLooping) {
          this.loop = isLooping;
        };
        AnimationItem.prototype.setVolume = function(val2, name2) {
          if (name2 && this.name !== name2) {
            return;
          }
          this.audioController.setVolume(val2);
        };
        AnimationItem.prototype.getVolume = function() {
          return this.audioController.getVolume();
        };
        AnimationItem.prototype.mute = function(name2) {
          if (name2 && this.name !== name2) {
            return;
          }
          this.audioController.mute();
        };
        AnimationItem.prototype.unmute = function(name2) {
          if (name2 && this.name !== name2) {
            return;
          }
          this.audioController.unmute();
        };
        AnimationItem.prototype.updaFrameModifier = function() {
          this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
          this.audioController.setRate(this.playSpeed * this.playDirection);
        };
        AnimationItem.prototype.getPath = function() {
          return this.path;
        };
        AnimationItem.prototype.getAssetsPath = function(assetData) {
          var path = "";
          if (assetData.e) {
            path = assetData.p;
          } else if (this.assetsPath) {
            var imagePath = assetData.p;
            if (imagePath.indexOf("images/") !== -1) {
              imagePath = imagePath.split("/")[1];
            }
            path = this.assetsPath + imagePath;
          } else {
            path = this.path;
            path += assetData.u ? assetData.u : "";
            path += assetData.p;
          }
          return path;
        };
        AnimationItem.prototype.getAssetData = function(id) {
          var i6 = 0;
          var len = this.assets.length;
          while (i6 < len) {
            if (id === this.assets[i6].id) {
              return this.assets[i6];
            }
            i6 += 1;
          }
          return null;
        };
        AnimationItem.prototype.hide = function() {
          this.renderer.hide();
        };
        AnimationItem.prototype.show = function() {
          this.renderer.show();
        };
        AnimationItem.prototype.getDuration = function(isFrame) {
          return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;
        };
        AnimationItem.prototype.updateDocumentData = function(path, documentData, index2) {
          try {
            var element = this.renderer.getElementByPath(path);
            element.updateDocumentData(documentData, index2);
          } catch (error) {
          }
        };
        AnimationItem.prototype.trigger = function(name2) {
          if (this._cbs && this._cbs[name2]) {
            switch (name2) {
              case "enterFrame":
                this.triggerEvent(name2, new BMEnterFrameEvent(name2, this.currentFrame, this.totalFrames, this.frameModifier));
                break;
              case "drawnFrame":
                this.drawnFrameEvent.currentTime = this.currentFrame;
                this.drawnFrameEvent.totalTime = this.totalFrames;
                this.drawnFrameEvent.direction = this.frameModifier;
                this.triggerEvent(name2, this.drawnFrameEvent);
                break;
              case "loopComplete":
                this.triggerEvent(name2, new BMCompleteLoopEvent(name2, this.loop, this.playCount, this.frameMult));
                break;
              case "complete":
                this.triggerEvent(name2, new BMCompleteEvent(name2, this.frameMult));
                break;
              case "segmentStart":
                this.triggerEvent(name2, new BMSegmentStartEvent(name2, this.firstFrame, this.totalFrames));
                break;
              case "destroy":
                this.triggerEvent(name2, new BMDestroyEvent(name2, this));
                break;
              default:
                this.triggerEvent(name2);
            }
          }
          if (name2 === "enterFrame" && this.onEnterFrame) {
            this.onEnterFrame.call(this, new BMEnterFrameEvent(name2, this.currentFrame, this.totalFrames, this.frameMult));
          }
          if (name2 === "loopComplete" && this.onLoopComplete) {
            this.onLoopComplete.call(this, new BMCompleteLoopEvent(name2, this.loop, this.playCount, this.frameMult));
          }
          if (name2 === "complete" && this.onComplete) {
            this.onComplete.call(this, new BMCompleteEvent(name2, this.frameMult));
          }
          if (name2 === "segmentStart" && this.onSegmentStart) {
            this.onSegmentStart.call(this, new BMSegmentStartEvent(name2, this.firstFrame, this.totalFrames));
          }
          if (name2 === "destroy" && this.onDestroy) {
            this.onDestroy.call(this, new BMDestroyEvent(name2, this));
          }
        };
        AnimationItem.prototype.triggerRenderFrameError = function(nativeError) {
          var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);
          this.triggerEvent("error", error);
          if (this.onError) {
            this.onError.call(this, error);
          }
        };
        AnimationItem.prototype.triggerConfigError = function(nativeError) {
          var error = new BMConfigErrorEvent(nativeError, this.currentFrame);
          this.triggerEvent("error", error);
          if (this.onError) {
            this.onError.call(this, error);
          }
        };
        var animationManager = function() {
          var moduleOb = {};
          var registeredAnimations = [];
          var initTime = 0;
          var len = 0;
          var playingAnimationsNum = 0;
          var _stopped = true;
          var _isFrozen = false;
          function removeElement(ev) {
            var i6 = 0;
            var animItem = ev.target;
            while (i6 < len) {
              if (registeredAnimations[i6].animation === animItem) {
                registeredAnimations.splice(i6, 1);
                i6 -= 1;
                len -= 1;
                if (!animItem.isPaused) {
                  subtractPlayingCount();
                }
              }
              i6 += 1;
            }
          }
          function registerAnimation(element, animationData2) {
            if (!element) {
              return null;
            }
            var i6 = 0;
            while (i6 < len) {
              if (registeredAnimations[i6].elem === element && registeredAnimations[i6].elem !== null) {
                return registeredAnimations[i6].animation;
              }
              i6 += 1;
            }
            var animItem = new AnimationItem();
            setupAnimation(animItem, element);
            animItem.setData(element, animationData2);
            return animItem;
          }
          function getRegisteredAnimations() {
            var i6;
            var lenAnims = registeredAnimations.length;
            var animations = [];
            for (i6 = 0; i6 < lenAnims; i6 += 1) {
              animations.push(registeredAnimations[i6].animation);
            }
            return animations;
          }
          function addPlayingCount() {
            playingAnimationsNum += 1;
            activate();
          }
          function subtractPlayingCount() {
            playingAnimationsNum -= 1;
          }
          function setupAnimation(animItem, element) {
            animItem.addEventListener("destroy", removeElement);
            animItem.addEventListener("_active", addPlayingCount);
            animItem.addEventListener("_idle", subtractPlayingCount);
            registeredAnimations.push({
              elem: element,
              animation: animItem
            });
            len += 1;
          }
          function loadAnimation2(params) {
            var animItem = new AnimationItem();
            setupAnimation(animItem, null);
            animItem.setParams(params);
            return animItem;
          }
          function setSpeed(val2, animation) {
            var i6;
            for (i6 = 0; i6 < len; i6 += 1) {
              registeredAnimations[i6].animation.setSpeed(val2, animation);
            }
          }
          function setDirection(val2, animation) {
            var i6;
            for (i6 = 0; i6 < len; i6 += 1) {
              registeredAnimations[i6].animation.setDirection(val2, animation);
            }
          }
          function play(animation) {
            var i6;
            for (i6 = 0; i6 < len; i6 += 1) {
              registeredAnimations[i6].animation.play(animation);
            }
          }
          function resume(nowTime) {
            var elapsedTime = nowTime - initTime;
            var i6;
            for (i6 = 0; i6 < len; i6 += 1) {
              registeredAnimations[i6].animation.advanceTime(elapsedTime);
            }
            initTime = nowTime;
            if (playingAnimationsNum && !_isFrozen) {
              window.requestAnimationFrame(resume);
            } else {
              _stopped = true;
            }
          }
          function first(nowTime) {
            initTime = nowTime;
            window.requestAnimationFrame(resume);
          }
          function pause(animation) {
            var i6;
            for (i6 = 0; i6 < len; i6 += 1) {
              registeredAnimations[i6].animation.pause(animation);
            }
          }
          function goToAndStop(value2, isFrame, animation) {
            var i6;
            for (i6 = 0; i6 < len; i6 += 1) {
              registeredAnimations[i6].animation.goToAndStop(value2, isFrame, animation);
            }
          }
          function stop(animation) {
            var i6;
            for (i6 = 0; i6 < len; i6 += 1) {
              registeredAnimations[i6].animation.stop(animation);
            }
          }
          function togglePause(animation) {
            var i6;
            for (i6 = 0; i6 < len; i6 += 1) {
              registeredAnimations[i6].animation.togglePause(animation);
            }
          }
          function destroy(animation) {
            var i6;
            for (i6 = len - 1; i6 >= 0; i6 -= 1) {
              registeredAnimations[i6].animation.destroy(animation);
            }
          }
          function searchAnimations2(animationData2, standalone2, renderer2) {
            var animElements = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin")));
            var i6;
            var lenAnims = animElements.length;
            for (i6 = 0; i6 < lenAnims; i6 += 1) {
              if (renderer2) {
                animElements[i6].setAttribute("data-bm-type", renderer2);
              }
              registerAnimation(animElements[i6], animationData2);
            }
            if (standalone2 && lenAnims === 0) {
              if (!renderer2) {
                renderer2 = "svg";
              }
              var body = document.getElementsByTagName("body")[0];
              body.innerText = "";
              var div2 = createTag("div");
              div2.style.width = "100%";
              div2.style.height = "100%";
              div2.setAttribute("data-bm-type", renderer2);
              body.appendChild(div2);
              registerAnimation(div2, animationData2);
            }
          }
          function resize() {
            var i6;
            for (i6 = 0; i6 < len; i6 += 1) {
              registeredAnimations[i6].animation.resize();
            }
          }
          function activate() {
            if (!_isFrozen && playingAnimationsNum) {
              if (_stopped) {
                window.requestAnimationFrame(first);
                _stopped = false;
              }
            }
          }
          function freeze() {
            _isFrozen = true;
          }
          function unfreeze() {
            _isFrozen = false;
            activate();
          }
          function setVolume(val2, animation) {
            var i6;
            for (i6 = 0; i6 < len; i6 += 1) {
              registeredAnimations[i6].animation.setVolume(val2, animation);
            }
          }
          function mute(animation) {
            var i6;
            for (i6 = 0; i6 < len; i6 += 1) {
              registeredAnimations[i6].animation.mute(animation);
            }
          }
          function unmute(animation) {
            var i6;
            for (i6 = 0; i6 < len; i6 += 1) {
              registeredAnimations[i6].animation.unmute(animation);
            }
          }
          moduleOb.registerAnimation = registerAnimation;
          moduleOb.loadAnimation = loadAnimation2;
          moduleOb.setSpeed = setSpeed;
          moduleOb.setDirection = setDirection;
          moduleOb.play = play;
          moduleOb.pause = pause;
          moduleOb.stop = stop;
          moduleOb.togglePause = togglePause;
          moduleOb.searchAnimations = searchAnimations2;
          moduleOb.resize = resize;
          moduleOb.goToAndStop = goToAndStop;
          moduleOb.destroy = destroy;
          moduleOb.freeze = freeze;
          moduleOb.unfreeze = unfreeze;
          moduleOb.setVolume = setVolume;
          moduleOb.mute = mute;
          moduleOb.unmute = unmute;
          moduleOb.getRegisteredAnimations = getRegisteredAnimations;
          return moduleOb;
        }();
        var BezierFactory = function() {
          var ob2 = {};
          ob2.getBezierEasing = getBezierEasing;
          var beziers = {};
          function getBezierEasing(a5, b3, c4, d3, nm) {
            var str = nm || ("bez_" + a5 + "_" + b3 + "_" + c4 + "_" + d3).replace(/\./g, "p");
            if (beziers[str]) {
              return beziers[str];
            }
            var bezEasing = new BezierEasing2([a5, b3, c4, d3]);
            beziers[str] = bezEasing;
            return bezEasing;
          }
          var NEWTON_ITERATIONS = 4;
          var NEWTON_MIN_SLOPE = 1e-3;
          var SUBDIVISION_PRECISION = 1e-7;
          var SUBDIVISION_MAX_ITERATIONS = 10;
          var kSplineTableSize = 11;
          var kSampleStepSize = 1 / (kSplineTableSize - 1);
          var float32ArraySupported = typeof Float32Array === "function";
          function A3(aA1, aA2) {
            return 1 - 3 * aA2 + 3 * aA1;
          }
          function B3(aA1, aA2) {
            return 3 * aA2 - 6 * aA1;
          }
          function C3(aA1) {
            return 3 * aA1;
          }
          function calcBezier(aT, aA1, aA2) {
            return ((A3(aA1, aA2) * aT + B3(aA1, aA2)) * aT + C3(aA1)) * aT;
          }
          function getSlope(aT, aA1, aA2) {
            return 3 * A3(aA1, aA2) * aT * aT + 2 * B3(aA1, aA2) * aT + C3(aA1);
          }
          function binarySubdivide(aX, aA, aB, mX1, mX2) {
            var currentX, currentT, i6 = 0;
            do {
              currentT = aA + (aB - aA) / 2;
              currentX = calcBezier(currentT, mX1, mX2) - aX;
              if (currentX > 0) {
                aB = currentT;
              } else {
                aA = currentT;
              }
            } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i6 < SUBDIVISION_MAX_ITERATIONS);
            return currentT;
          }
          function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
            for (var i6 = 0; i6 < NEWTON_ITERATIONS; ++i6) {
              var currentSlope = getSlope(aGuessT, mX1, mX2);
              if (currentSlope === 0) return aGuessT;
              var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
              aGuessT -= currentX / currentSlope;
            }
            return aGuessT;
          }
          function BezierEasing2(points) {
            this._p = points;
            this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
            this._precomputed = false;
            this.get = this.get.bind(this);
          }
          BezierEasing2.prototype = {
            get: function get(x3) {
              var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];
              if (!this._precomputed) this._precompute();
              if (mX1 === mY1 && mX2 === mY2) return x3;
              if (x3 === 0) return 0;
              if (x3 === 1) return 1;
              return calcBezier(this._getTForX(x3), mY1, mY2);
            },
            // Private part
            _precompute: function _precompute() {
              var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];
              this._precomputed = true;
              if (mX1 !== mY1 || mX2 !== mY2) {
                this._calcSampleValues();
              }
            },
            _calcSampleValues: function _calcSampleValues() {
              var mX1 = this._p[0], mX2 = this._p[2];
              for (var i6 = 0; i6 < kSplineTableSize; ++i6) {
                this._mSampleValues[i6] = calcBezier(i6 * kSampleStepSize, mX1, mX2);
              }
            },
            /**
                 * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
                 */
            _getTForX: function _getTForX(aX) {
              var mX1 = this._p[0], mX2 = this._p[2], mSampleValues = this._mSampleValues;
              var intervalStart = 0;
              var currentSample = 1;
              var lastSample = kSplineTableSize - 1;
              for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
                intervalStart += kSampleStepSize;
              }
              --currentSample;
              var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
              var guessForT = intervalStart + dist * kSampleStepSize;
              var initialSlope = getSlope(guessForT, mX1, mX2);
              if (initialSlope >= NEWTON_MIN_SLOPE) {
                return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
              }
              if (initialSlope === 0) {
                return guessForT;
              }
              return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
            }
          };
          return ob2;
        }();
        var pooling = /* @__PURE__ */ function() {
          function _double(arr) {
            return arr.concat(createSizedArray(arr.length));
          }
          return {
            "double": _double
          };
        }();
        var poolFactory = /* @__PURE__ */ function() {
          return function(initialLength, _create, _release) {
            var _length = 0;
            var _maxLength = initialLength;
            var pool = createSizedArray(_maxLength);
            var ob2 = {
              newElement,
              release
            };
            function newElement() {
              var element;
              if (_length) {
                _length -= 1;
                element = pool[_length];
              } else {
                element = _create();
              }
              return element;
            }
            function release(element) {
              if (_length === _maxLength) {
                pool = pooling["double"](pool);
                _maxLength *= 2;
              }
              if (_release) {
                _release(element);
              }
              pool[_length] = element;
              _length += 1;
            }
            return ob2;
          };
        }();
        var bezierLengthPool = function() {
          function create() {
            return {
              addedLength: 0,
              percents: createTypedArray("float32", getDefaultCurveSegments()),
              lengths: createTypedArray("float32", getDefaultCurveSegments())
            };
          }
          return poolFactory(8, create);
        }();
        var segmentsLengthPool = function() {
          function create() {
            return {
              lengths: [],
              totalLength: 0
            };
          }
          function release(element) {
            var i6;
            var len = element.lengths.length;
            for (i6 = 0; i6 < len; i6 += 1) {
              bezierLengthPool.release(element.lengths[i6]);
            }
            element.lengths.length = 0;
          }
          return poolFactory(8, create, release);
        }();
        function bezFunction() {
          var math = Math;
          function pointOnLine2D(x1, y1, x22, y22, x3, y3) {
            var det1 = x1 * y22 + y1 * x3 + x22 * y3 - x3 * y22 - y3 * x1 - x22 * y1;
            return det1 > -1e-3 && det1 < 1e-3;
          }
          function pointOnLine3D(x1, y1, z1, x22, y22, z2, x3, y3, z3) {
            if (z1 === 0 && z2 === 0 && z3 === 0) {
              return pointOnLine2D(x1, y1, x22, y22, x3, y3);
            }
            var dist1 = math.sqrt(math.pow(x22 - x1, 2) + math.pow(y22 - y1, 2) + math.pow(z2 - z1, 2));
            var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2));
            var dist3 = math.sqrt(math.pow(x3 - x22, 2) + math.pow(y3 - y22, 2) + math.pow(z3 - z2, 2));
            var diffDist;
            if (dist1 > dist2) {
              if (dist1 > dist3) {
                diffDist = dist1 - dist2 - dist3;
              } else {
                diffDist = dist3 - dist2 - dist1;
              }
            } else if (dist3 > dist2) {
              diffDist = dist3 - dist2 - dist1;
            } else {
              diffDist = dist2 - dist1 - dist3;
            }
            return diffDist > -1e-4 && diffDist < 1e-4;
          }
          var getBezierLength = /* @__PURE__ */ function() {
            return function(pt1, pt2, pt3, pt4) {
              var curveSegments = getDefaultCurveSegments();
              var k3;
              var i6;
              var len;
              var ptCoord;
              var perc;
              var addedLength = 0;
              var ptDistance;
              var point = [];
              var lastPoint = [];
              var lengthData = bezierLengthPool.newElement();
              len = pt3.length;
              for (k3 = 0; k3 < curveSegments; k3 += 1) {
                perc = k3 / (curveSegments - 1);
                ptDistance = 0;
                for (i6 = 0; i6 < len; i6 += 1) {
                  ptCoord = bmPow(1 - perc, 3) * pt1[i6] + 3 * bmPow(1 - perc, 2) * perc * pt3[i6] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i6] + bmPow(perc, 3) * pt2[i6];
                  point[i6] = ptCoord;
                  if (lastPoint[i6] !== null) {
                    ptDistance += bmPow(point[i6] - lastPoint[i6], 2);
                  }
                  lastPoint[i6] = point[i6];
                }
                if (ptDistance) {
                  ptDistance = bmSqrt(ptDistance);
                  addedLength += ptDistance;
                }
                lengthData.percents[k3] = perc;
                lengthData.lengths[k3] = addedLength;
              }
              lengthData.addedLength = addedLength;
              return lengthData;
            };
          }();
          function getSegmentsLength(shapeData) {
            var segmentsLength = segmentsLengthPool.newElement();
            var closed = shapeData.c;
            var pathV = shapeData.v;
            var pathO = shapeData.o;
            var pathI = shapeData.i;
            var i6;
            var len = shapeData._length;
            var lengths = segmentsLength.lengths;
            var totalLength = 0;
            for (i6 = 0; i6 < len - 1; i6 += 1) {
              lengths[i6] = getBezierLength(pathV[i6], pathV[i6 + 1], pathO[i6], pathI[i6 + 1]);
              totalLength += lengths[i6].addedLength;
            }
            if (closed && len) {
              lengths[i6] = getBezierLength(pathV[i6], pathV[0], pathO[i6], pathI[0]);
              totalLength += lengths[i6].addedLength;
            }
            segmentsLength.totalLength = totalLength;
            return segmentsLength;
          }
          function BezierData(length2) {
            this.segmentLength = 0;
            this.points = new Array(length2);
          }
          function PointData(partial, point) {
            this.partialLength = partial;
            this.point = point;
          }
          var buildBezierData = /* @__PURE__ */ function() {
            var storedData = {};
            return function(pt1, pt2, pt3, pt4) {
              var bezierName = (pt1[0] + "_" + pt1[1] + "_" + pt2[0] + "_" + pt2[1] + "_" + pt3[0] + "_" + pt3[1] + "_" + pt4[0] + "_" + pt4[1]).replace(/\./g, "p");
              if (!storedData[bezierName]) {
                var curveSegments = getDefaultCurveSegments();
                var k3;
                var i6;
                var len;
                var ptCoord;
                var perc;
                var addedLength = 0;
                var ptDistance;
                var point;
                var lastPoint = null;
                if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) {
                  curveSegments = 2;
                }
                var bezierData = new BezierData(curveSegments);
                len = pt3.length;
                for (k3 = 0; k3 < curveSegments; k3 += 1) {
                  point = createSizedArray(len);
                  perc = k3 / (curveSegments - 1);
                  ptDistance = 0;
                  for (i6 = 0; i6 < len; i6 += 1) {
                    ptCoord = bmPow(1 - perc, 3) * pt1[i6] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i6] + pt3[i6]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i6] + pt4[i6]) + bmPow(perc, 3) * pt2[i6];
                    point[i6] = ptCoord;
                    if (lastPoint !== null) {
                      ptDistance += bmPow(point[i6] - lastPoint[i6], 2);
                    }
                  }
                  ptDistance = bmSqrt(ptDistance);
                  addedLength += ptDistance;
                  bezierData.points[k3] = new PointData(ptDistance, point);
                  lastPoint = point;
                }
                bezierData.segmentLength = addedLength;
                storedData[bezierName] = bezierData;
              }
              return storedData[bezierName];
            };
          }();
          function getDistancePerc(perc, bezierData) {
            var percents = bezierData.percents;
            var lengths = bezierData.lengths;
            var len = percents.length;
            var initPos = bmFloor((len - 1) * perc);
            var lengthPos = perc * bezierData.addedLength;
            var lPerc = 0;
            if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {
              return percents[initPos];
            }
            var dir = lengths[initPos] > lengthPos ? -1 : 1;
            var flag = true;
            while (flag) {
              if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {
                lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);
                flag = false;
              } else {
                initPos += dir;
              }
              if (initPos < 0 || initPos >= len - 1) {
                if (initPos === len - 1) {
                  return percents[initPos];
                }
                flag = false;
              }
            }
            return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;
          }
          function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
            var t1 = getDistancePerc(percent, bezierData);
            var u1 = 1 - t1;
            var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1e3) / 1e3;
            var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1e3) / 1e3;
            return [ptX, ptY];
          }
          var bezierSegmentPoints = createTypedArray("float32", 8);
          function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {
            if (startPerc < 0) {
              startPerc = 0;
            } else if (startPerc > 1) {
              startPerc = 1;
            }
            var t0 = getDistancePerc(startPerc, bezierData);
            endPerc = endPerc > 1 ? 1 : endPerc;
            var t1 = getDistancePerc(endPerc, bezierData);
            var i6;
            var len = pt1.length;
            var u0 = 1 - t0;
            var u1 = 1 - t1;
            var u0u0u0 = u0 * u0 * u0;
            var t0u0u0_3 = t0 * u0 * u0 * 3;
            var t0t0u0_3 = t0 * t0 * u0 * 3;
            var t0t0t0 = t0 * t0 * t0;
            var u0u0u1 = u0 * u0 * u1;
            var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1;
            var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1;
            var t0t0t1 = t0 * t0 * t1;
            var u0u1u1 = u0 * u1 * u1;
            var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1;
            var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1;
            var t0t1t1 = t0 * t1 * t1;
            var u1u1u1 = u1 * u1 * u1;
            var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1;
            var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1;
            var t1t1t1 = t1 * t1 * t1;
            for (i6 = 0; i6 < len; i6 += 1) {
              bezierSegmentPoints[i6 * 4] = math.round((u0u0u0 * pt1[i6] + t0u0u0_3 * pt3[i6] + t0t0u0_3 * pt4[i6] + t0t0t0 * pt2[i6]) * 1e3) / 1e3;
              bezierSegmentPoints[i6 * 4 + 1] = math.round((u0u0u1 * pt1[i6] + t0u0u1_3 * pt3[i6] + t0t0u1_3 * pt4[i6] + t0t0t1 * pt2[i6]) * 1e3) / 1e3;
              bezierSegmentPoints[i6 * 4 + 2] = math.round((u0u1u1 * pt1[i6] + t0u1u1_3 * pt3[i6] + t0t1u1_3 * pt4[i6] + t0t1t1 * pt2[i6]) * 1e3) / 1e3;
              bezierSegmentPoints[i6 * 4 + 3] = math.round((u1u1u1 * pt1[i6] + t1u1u1_3 * pt3[i6] + t1t1u1_3 * pt4[i6] + t1t1t1 * pt2[i6]) * 1e3) / 1e3;
            }
            return bezierSegmentPoints;
          }
          return {
            getSegmentsLength,
            getNewSegment,
            getPointInSegment,
            buildBezierData,
            pointOnLine2D,
            pointOnLine3D
          };
        }
        var bez = bezFunction();
        var initFrame = initialDefaultFrame;
        var mathAbs = Math.abs;
        function interpolateValue(frameNum, caching) {
          var offsetTime = this.offsetTime;
          var newValue;
          if (this.propType === "multidimensional") {
            newValue = createTypedArray("float32", this.pv.length);
          }
          var iterationIndex = caching.lastIndex;
          var i6 = iterationIndex;
          var len = this.keyframes.length - 1;
          var flag = true;
          var keyData;
          var nextKeyData;
          var keyframeMetadata;
          while (flag) {
            keyData = this.keyframes[i6];
            nextKeyData = this.keyframes[i6 + 1];
            if (i6 === len - 1 && frameNum >= nextKeyData.t - offsetTime) {
              if (keyData.h) {
                keyData = nextKeyData;
              }
              iterationIndex = 0;
              break;
            }
            if (nextKeyData.t - offsetTime > frameNum) {
              iterationIndex = i6;
              break;
            }
            if (i6 < len - 1) {
              i6 += 1;
            } else {
              iterationIndex = 0;
              flag = false;
            }
          }
          keyframeMetadata = this.keyframesMetadata[i6] || {};
          var k3;
          var kLen;
          var perc;
          var jLen;
          var j3;
          var fnc;
          var nextKeyTime = nextKeyData.t - offsetTime;
          var keyTime = keyData.t - offsetTime;
          var endValue;
          if (keyData.to) {
            if (!keyframeMetadata.bezierData) {
              keyframeMetadata.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);
            }
            var bezierData = keyframeMetadata.bezierData;
            if (frameNum >= nextKeyTime || frameNum < keyTime) {
              var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
              kLen = bezierData.points[ind].point.length;
              for (k3 = 0; k3 < kLen; k3 += 1) {
                newValue[k3] = bezierData.points[ind].point[k3];
              }
            } else {
              if (keyframeMetadata.__fnct) {
                fnc = keyframeMetadata.__fnct;
              } else {
                fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;
                keyframeMetadata.__fnct = fnc;
              }
              perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
              var distanceInLine = bezierData.segmentLength * perc;
              var segmentPerc;
              var addedLength = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i6 ? caching._lastAddedLength : 0;
              j3 = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i6 ? caching._lastPoint : 0;
              flag = true;
              jLen = bezierData.points.length;
              while (flag) {
                addedLength += bezierData.points[j3].partialLength;
                if (distanceInLine === 0 || perc === 0 || j3 === bezierData.points.length - 1) {
                  kLen = bezierData.points[j3].point.length;
                  for (k3 = 0; k3 < kLen; k3 += 1) {
                    newValue[k3] = bezierData.points[j3].point[k3];
                  }
                  break;
                } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j3 + 1].partialLength) {
                  segmentPerc = (distanceInLine - addedLength) / bezierData.points[j3 + 1].partialLength;
                  kLen = bezierData.points[j3].point.length;
                  for (k3 = 0; k3 < kLen; k3 += 1) {
                    newValue[k3] = bezierData.points[j3].point[k3] + (bezierData.points[j3 + 1].point[k3] - bezierData.points[j3].point[k3]) * segmentPerc;
                  }
                  break;
                }
                if (j3 < jLen - 1) {
                  j3 += 1;
                } else {
                  flag = false;
                }
              }
              caching._lastPoint = j3;
              caching._lastAddedLength = addedLength - bezierData.points[j3].partialLength;
              caching._lastKeyframeIndex = i6;
            }
          } else {
            var outX;
            var outY;
            var inX;
            var inY;
            var keyValue;
            len = keyData.s.length;
            endValue = nextKeyData.s || keyData.e;
            if (this.sh && keyData.h !== 1) {
              if (frameNum >= nextKeyTime) {
                newValue[0] = endValue[0];
                newValue[1] = endValue[1];
                newValue[2] = endValue[2];
              } else if (frameNum <= keyTime) {
                newValue[0] = keyData.s[0];
                newValue[1] = keyData.s[1];
                newValue[2] = keyData.s[2];
              } else {
                var quatStart = createQuaternion(keyData.s);
                var quatEnd = createQuaternion(endValue);
                var time2 = (frameNum - keyTime) / (nextKeyTime - keyTime);
                quaternionToEuler(newValue, slerp(quatStart, quatEnd, time2));
              }
            } else {
              for (i6 = 0; i6 < len; i6 += 1) {
                if (keyData.h !== 1) {
                  if (frameNum >= nextKeyTime) {
                    perc = 1;
                  } else if (frameNum < keyTime) {
                    perc = 0;
                  } else {
                    if (keyData.o.x.constructor === Array) {
                      if (!keyframeMetadata.__fnct) {
                        keyframeMetadata.__fnct = [];
                      }
                      if (!keyframeMetadata.__fnct[i6]) {
                        outX = keyData.o.x[i6] === void 0 ? keyData.o.x[0] : keyData.o.x[i6];
                        outY = keyData.o.y[i6] === void 0 ? keyData.o.y[0] : keyData.o.y[i6];
                        inX = keyData.i.x[i6] === void 0 ? keyData.i.x[0] : keyData.i.x[i6];
                        inY = keyData.i.y[i6] === void 0 ? keyData.i.y[0] : keyData.i.y[i6];
                        fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                        keyframeMetadata.__fnct[i6] = fnc;
                      } else {
                        fnc = keyframeMetadata.__fnct[i6];
                      }
                    } else if (!keyframeMetadata.__fnct) {
                      outX = keyData.o.x;
                      outY = keyData.o.y;
                      inX = keyData.i.x;
                      inY = keyData.i.y;
                      fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                      keyData.keyframeMetadata = fnc;
                    } else {
                      fnc = keyframeMetadata.__fnct;
                    }
                    perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
                  }
                }
                endValue = nextKeyData.s || keyData.e;
                keyValue = keyData.h === 1 ? keyData.s[i6] : keyData.s[i6] + (endValue[i6] - keyData.s[i6]) * perc;
                if (this.propType === "multidimensional") {
                  newValue[i6] = keyValue;
                } else {
                  newValue = keyValue;
                }
              }
            }
          }
          caching.lastIndex = iterationIndex;
          return newValue;
        }
        function slerp(a5, b3, t4) {
          var out = [];
          var ax = a5[0];
          var ay = a5[1];
          var az = a5[2];
          var aw = a5[3];
          var bx = b3[0];
          var by = b3[1];
          var bz = b3[2];
          var bw = b3[3];
          var omega;
          var cosom;
          var sinom;
          var scale0;
          var scale1;
          cosom = ax * bx + ay * by + az * bz + aw * bw;
          if (cosom < 0) {
            cosom = -cosom;
            bx = -bx;
            by = -by;
            bz = -bz;
            bw = -bw;
          }
          if (1 - cosom > 1e-6) {
            omega = Math.acos(cosom);
            sinom = Math.sin(omega);
            scale0 = Math.sin((1 - t4) * omega) / sinom;
            scale1 = Math.sin(t4 * omega) / sinom;
          } else {
            scale0 = 1 - t4;
            scale1 = t4;
          }
          out[0] = scale0 * ax + scale1 * bx;
          out[1] = scale0 * ay + scale1 * by;
          out[2] = scale0 * az + scale1 * bz;
          out[3] = scale0 * aw + scale1 * bw;
          return out;
        }
        function quaternionToEuler(out, quat) {
          var qx = quat[0];
          var qy = quat[1];
          var qz = quat[2];
          var qw = quat[3];
          var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);
          var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);
          var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);
          out[0] = heading / degToRads;
          out[1] = attitude / degToRads;
          out[2] = bank / degToRads;
        }
        function createQuaternion(values) {
          var heading = values[0] * degToRads;
          var attitude = values[1] * degToRads;
          var bank = values[2] * degToRads;
          var c1 = Math.cos(heading / 2);
          var c22 = Math.cos(attitude / 2);
          var c32 = Math.cos(bank / 2);
          var s1 = Math.sin(heading / 2);
          var s22 = Math.sin(attitude / 2);
          var s32 = Math.sin(bank / 2);
          var w3 = c1 * c22 * c32 - s1 * s22 * s32;
          var x3 = s1 * s22 * c32 + c1 * c22 * s32;
          var y3 = s1 * c22 * c32 + c1 * s22 * s32;
          var z2 = c1 * s22 * c32 - s1 * c22 * s32;
          return [x3, y3, z2, w3];
        }
        function getValueAtCurrentTime() {
          var frameNum = this.comp.renderedFrame - this.offsetTime;
          var initTime = this.keyframes[0].t - this.offsetTime;
          var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
          if (!(frameNum === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= endTime && frameNum >= endTime || this._caching.lastFrame < initTime && frameNum < initTime))) {
            if (this._caching.lastFrame >= frameNum) {
              this._caching._lastKeyframeIndex = -1;
              this._caching.lastIndex = 0;
            }
            var renderResult = this.interpolateValue(frameNum, this._caching);
            this.pv = renderResult;
          }
          this._caching.lastFrame = frameNum;
          return this.pv;
        }
        function setVValue(val2) {
          var multipliedValue;
          if (this.propType === "unidimensional") {
            multipliedValue = val2 * this.mult;
            if (mathAbs(this.v - multipliedValue) > 1e-5) {
              this.v = multipliedValue;
              this._mdf = true;
            }
          } else {
            var i6 = 0;
            var len = this.v.length;
            while (i6 < len) {
              multipliedValue = val2[i6] * this.mult;
              if (mathAbs(this.v[i6] - multipliedValue) > 1e-5) {
                this.v[i6] = multipliedValue;
                this._mdf = true;
              }
              i6 += 1;
            }
          }
        }
        function processEffectsSequence() {
          if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {
            return;
          }
          if (this.lock) {
            this.setVValue(this.pv);
            return;
          }
          this.lock = true;
          this._mdf = this._isFirstFrame;
          var i6;
          var len = this.effectsSequence.length;
          var finalValue = this.kf ? this.pv : this.data.k;
          for (i6 = 0; i6 < len; i6 += 1) {
            finalValue = this.effectsSequence[i6](finalValue);
          }
          this.setVValue(finalValue);
          this._isFirstFrame = false;
          this.lock = false;
          this.frameId = this.elem.globalData.frameId;
        }
        function addEffect(effectFunction) {
          this.effectsSequence.push(effectFunction);
          this.container.addDynamicProperty(this);
        }
        function ValueProperty(elem2, data2, mult, container) {
          this.propType = "unidimensional";
          this.mult = mult || 1;
          this.data = data2;
          this.v = mult ? data2.k * mult : data2.k;
          this.pv = data2.k;
          this._mdf = false;
          this.elem = elem2;
          this.container = container;
          this.comp = elem2.comp;
          this.k = false;
          this.kf = false;
          this.vel = 0;
          this.effectsSequence = [];
          this._isFirstFrame = true;
          this.getValue = processEffectsSequence;
          this.setVValue = setVValue;
          this.addEffect = addEffect;
        }
        function MultiDimensionalProperty(elem2, data2, mult, container) {
          this.propType = "multidimensional";
          this.mult = mult || 1;
          this.data = data2;
          this._mdf = false;
          this.elem = elem2;
          this.container = container;
          this.comp = elem2.comp;
          this.k = false;
          this.kf = false;
          this.frameId = -1;
          var i6;
          var len = data2.k.length;
          this.v = createTypedArray("float32", len);
          this.pv = createTypedArray("float32", len);
          this.vel = createTypedArray("float32", len);
          for (i6 = 0; i6 < len; i6 += 1) {
            this.v[i6] = data2.k[i6] * this.mult;
            this.pv[i6] = data2.k[i6];
          }
          this._isFirstFrame = true;
          this.effectsSequence = [];
          this.getValue = processEffectsSequence;
          this.setVValue = setVValue;
          this.addEffect = addEffect;
        }
        function KeyframedValueProperty(elem2, data2, mult, container) {
          this.propType = "unidimensional";
          this.keyframes = data2.k;
          this.keyframesMetadata = [];
          this.offsetTime = elem2.data.st;
          this.frameId = -1;
          this._caching = {
            lastFrame: initFrame,
            lastIndex: 0,
            value: 0,
            _lastKeyframeIndex: -1
          };
          this.k = true;
          this.kf = true;
          this.data = data2;
          this.mult = mult || 1;
          this.elem = elem2;
          this.container = container;
          this.comp = elem2.comp;
          this.v = initFrame;
          this.pv = initFrame;
          this._isFirstFrame = true;
          this.getValue = processEffectsSequence;
          this.setVValue = setVValue;
          this.interpolateValue = interpolateValue;
          this.effectsSequence = [getValueAtCurrentTime.bind(this)];
          this.addEffect = addEffect;
        }
        function KeyframedMultidimensionalProperty(elem2, data2, mult, container) {
          this.propType = "multidimensional";
          var i6;
          var len = data2.k.length;
          var s4;
          var e5;
          var to;
          var ti;
          for (i6 = 0; i6 < len - 1; i6 += 1) {
            if (data2.k[i6].to && data2.k[i6].s && data2.k[i6 + 1] && data2.k[i6 + 1].s) {
              s4 = data2.k[i6].s;
              e5 = data2.k[i6 + 1].s;
              to = data2.k[i6].to;
              ti = data2.k[i6].ti;
              if (s4.length === 2 && !(s4[0] === e5[0] && s4[1] === e5[1]) && bez.pointOnLine2D(s4[0], s4[1], e5[0], e5[1], s4[0] + to[0], s4[1] + to[1]) && bez.pointOnLine2D(s4[0], s4[1], e5[0], e5[1], e5[0] + ti[0], e5[1] + ti[1]) || s4.length === 3 && !(s4[0] === e5[0] && s4[1] === e5[1] && s4[2] === e5[2]) && bez.pointOnLine3D(s4[0], s4[1], s4[2], e5[0], e5[1], e5[2], s4[0] + to[0], s4[1] + to[1], s4[2] + to[2]) && bez.pointOnLine3D(s4[0], s4[1], s4[2], e5[0], e5[1], e5[2], e5[0] + ti[0], e5[1] + ti[1], e5[2] + ti[2])) {
                data2.k[i6].to = null;
                data2.k[i6].ti = null;
              }
              if (s4[0] === e5[0] && s4[1] === e5[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {
                if (s4.length === 2 || s4[2] === e5[2] && to[2] === 0 && ti[2] === 0) {
                  data2.k[i6].to = null;
                  data2.k[i6].ti = null;
                }
              }
            }
          }
          this.effectsSequence = [getValueAtCurrentTime.bind(this)];
          this.data = data2;
          this.keyframes = data2.k;
          this.keyframesMetadata = [];
          this.offsetTime = elem2.data.st;
          this.k = true;
          this.kf = true;
          this._isFirstFrame = true;
          this.mult = mult || 1;
          this.elem = elem2;
          this.container = container;
          this.comp = elem2.comp;
          this.getValue = processEffectsSequence;
          this.setVValue = setVValue;
          this.interpolateValue = interpolateValue;
          this.frameId = -1;
          var arrLen = data2.k[0].s.length;
          this.v = createTypedArray("float32", arrLen);
          this.pv = createTypedArray("float32", arrLen);
          for (i6 = 0; i6 < arrLen; i6 += 1) {
            this.v[i6] = initFrame;
            this.pv[i6] = initFrame;
          }
          this._caching = {
            lastFrame: initFrame,
            lastIndex: 0,
            value: createTypedArray("float32", arrLen)
          };
          this.addEffect = addEffect;
        }
        var PropertyFactory = /* @__PURE__ */ function() {
          function getProp(elem2, data2, type, mult, container) {
            if (data2.sid) {
              data2 = elem2.globalData.slotManager.getProp(data2);
            }
            var p3;
            if (!data2.k.length) {
              p3 = new ValueProperty(elem2, data2, mult, container);
            } else if (typeof data2.k[0] === "number") {
              p3 = new MultiDimensionalProperty(elem2, data2, mult, container);
            } else {
              switch (type) {
                case 0:
                  p3 = new KeyframedValueProperty(elem2, data2, mult, container);
                  break;
                case 1:
                  p3 = new KeyframedMultidimensionalProperty(elem2, data2, mult, container);
                  break;
                default:
                  break;
              }
            }
            if (p3.effectsSequence.length) {
              container.addDynamicProperty(p3);
            }
            return p3;
          }
          var ob2 = {
            getProp
          };
          return ob2;
        }();
        function DynamicPropertyContainer() {
        }
        DynamicPropertyContainer.prototype = {
          addDynamicProperty: function addDynamicProperty(prop) {
            if (this.dynamicProperties.indexOf(prop) === -1) {
              this.dynamicProperties.push(prop);
              this.container.addDynamicProperty(this);
              this._isAnimated = true;
            }
          },
          iterateDynamicProperties: function iterateDynamicProperties() {
            this._mdf = false;
            var i6;
            var len = this.dynamicProperties.length;
            for (i6 = 0; i6 < len; i6 += 1) {
              this.dynamicProperties[i6].getValue();
              if (this.dynamicProperties[i6]._mdf) {
                this._mdf = true;
              }
            }
          },
          initDynamicPropertyContainer: function initDynamicPropertyContainer(container) {
            this.container = container;
            this.dynamicProperties = [];
            this._mdf = false;
            this._isAnimated = false;
          }
        };
        var pointPool = function() {
          function create() {
            return createTypedArray("float32", 2);
          }
          return poolFactory(8, create);
        }();
        function ShapePath() {
          this.c = false;
          this._length = 0;
          this._maxLength = 8;
          this.v = createSizedArray(this._maxLength);
          this.o = createSizedArray(this._maxLength);
          this.i = createSizedArray(this._maxLength);
        }
        ShapePath.prototype.setPathData = function(closed, len) {
          this.c = closed;
          this.setLength(len);
          var i6 = 0;
          while (i6 < len) {
            this.v[i6] = pointPool.newElement();
            this.o[i6] = pointPool.newElement();
            this.i[i6] = pointPool.newElement();
            i6 += 1;
          }
        };
        ShapePath.prototype.setLength = function(len) {
          while (this._maxLength < len) {
            this.doubleArrayLength();
          }
          this._length = len;
        };
        ShapePath.prototype.doubleArrayLength = function() {
          this.v = this.v.concat(createSizedArray(this._maxLength));
          this.i = this.i.concat(createSizedArray(this._maxLength));
          this.o = this.o.concat(createSizedArray(this._maxLength));
          this._maxLength *= 2;
        };
        ShapePath.prototype.setXYAt = function(x3, y3, type, pos, replace) {
          var arr;
          this._length = Math.max(this._length, pos + 1);
          if (this._length >= this._maxLength) {
            this.doubleArrayLength();
          }
          switch (type) {
            case "v":
              arr = this.v;
              break;
            case "i":
              arr = this.i;
              break;
            case "o":
              arr = this.o;
              break;
            default:
              arr = [];
              break;
          }
          if (!arr[pos] || arr[pos] && !replace) {
            arr[pos] = pointPool.newElement();
          }
          arr[pos][0] = x3;
          arr[pos][1] = y3;
        };
        ShapePath.prototype.setTripleAt = function(vX, vY, oX, oY, iX, iY, pos, replace) {
          this.setXYAt(vX, vY, "v", pos, replace);
          this.setXYAt(oX, oY, "o", pos, replace);
          this.setXYAt(iX, iY, "i", pos, replace);
        };
        ShapePath.prototype.reverse = function() {
          var newPath = new ShapePath();
          newPath.setPathData(this.c, this._length);
          var vertices = this.v;
          var outPoints = this.o;
          var inPoints = this.i;
          var init5 = 0;
          if (this.c) {
            newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);
            init5 = 1;
          }
          var cnt = this._length - 1;
          var len = this._length;
          var i6;
          for (i6 = init5; i6 < len; i6 += 1) {
            newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i6, false);
            cnt -= 1;
          }
          return newPath;
        };
        ShapePath.prototype.length = function() {
          return this._length;
        };
        var shapePool = function() {
          function create() {
            return new ShapePath();
          }
          function release(shapePath) {
            var len = shapePath._length;
            var i6;
            for (i6 = 0; i6 < len; i6 += 1) {
              pointPool.release(shapePath.v[i6]);
              pointPool.release(shapePath.i[i6]);
              pointPool.release(shapePath.o[i6]);
              shapePath.v[i6] = null;
              shapePath.i[i6] = null;
              shapePath.o[i6] = null;
            }
            shapePath._length = 0;
            shapePath.c = false;
          }
          function clone(shape) {
            var cloned = factory.newElement();
            var i6;
            var len = shape._length === void 0 ? shape.v.length : shape._length;
            cloned.setLength(len);
            cloned.c = shape.c;
            for (i6 = 0; i6 < len; i6 += 1) {
              cloned.setTripleAt(shape.v[i6][0], shape.v[i6][1], shape.o[i6][0], shape.o[i6][1], shape.i[i6][0], shape.i[i6][1], i6);
            }
            return cloned;
          }
          var factory = poolFactory(4, create, release);
          factory.clone = clone;
          return factory;
        }();
        function ShapeCollection() {
          this._length = 0;
          this._maxLength = 4;
          this.shapes = createSizedArray(this._maxLength);
        }
        ShapeCollection.prototype.addShape = function(shapeData) {
          if (this._length === this._maxLength) {
            this.shapes = this.shapes.concat(createSizedArray(this._maxLength));
            this._maxLength *= 2;
          }
          this.shapes[this._length] = shapeData;
          this._length += 1;
        };
        ShapeCollection.prototype.releaseShapes = function() {
          var i6;
          for (i6 = 0; i6 < this._length; i6 += 1) {
            shapePool.release(this.shapes[i6]);
          }
          this._length = 0;
        };
        var shapeCollectionPool = function() {
          var ob2 = {
            newShapeCollection,
            release
          };
          var _length = 0;
          var _maxLength = 4;
          var pool = createSizedArray(_maxLength);
          function newShapeCollection() {
            var shapeCollection;
            if (_length) {
              _length -= 1;
              shapeCollection = pool[_length];
            } else {
              shapeCollection = new ShapeCollection();
            }
            return shapeCollection;
          }
          function release(shapeCollection) {
            var i6;
            var len = shapeCollection._length;
            for (i6 = 0; i6 < len; i6 += 1) {
              shapePool.release(shapeCollection.shapes[i6]);
            }
            shapeCollection._length = 0;
            if (_length === _maxLength) {
              pool = pooling["double"](pool);
              _maxLength *= 2;
            }
            pool[_length] = shapeCollection;
            _length += 1;
          }
          return ob2;
        }();
        var ShapePropertyFactory = function() {
          var initFrame2 = -999999;
          function interpolateShape(frameNum, previousValue, caching) {
            var iterationIndex = caching.lastIndex;
            var keyPropS;
            var keyPropE;
            var isHold;
            var j3;
            var k3;
            var jLen;
            var kLen;
            var perc;
            var vertexValue;
            var kf = this.keyframes;
            if (frameNum < kf[0].t - this.offsetTime) {
              keyPropS = kf[0].s[0];
              isHold = true;
              iterationIndex = 0;
            } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {
              keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];
              isHold = true;
            } else {
              var i6 = iterationIndex;
              var len = kf.length - 1;
              var flag = true;
              var keyData;
              var nextKeyData;
              var keyframeMetadata;
              while (flag) {
                keyData = kf[i6];
                nextKeyData = kf[i6 + 1];
                if (nextKeyData.t - this.offsetTime > frameNum) {
                  break;
                }
                if (i6 < len - 1) {
                  i6 += 1;
                } else {
                  flag = false;
                }
              }
              keyframeMetadata = this.keyframesMetadata[i6] || {};
              isHold = keyData.h === 1;
              iterationIndex = i6;
              if (!isHold) {
                if (frameNum >= nextKeyData.t - this.offsetTime) {
                  perc = 1;
                } else if (frameNum < keyData.t - this.offsetTime) {
                  perc = 0;
                } else {
                  var fnc;
                  if (keyframeMetadata.__fnct) {
                    fnc = keyframeMetadata.__fnct;
                  } else {
                    fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;
                    keyframeMetadata.__fnct = fnc;
                  }
                  perc = fnc((frameNum - (keyData.t - this.offsetTime)) / (nextKeyData.t - this.offsetTime - (keyData.t - this.offsetTime)));
                }
                keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];
              }
              keyPropS = keyData.s[0];
            }
            jLen = previousValue._length;
            kLen = keyPropS.i[0].length;
            caching.lastIndex = iterationIndex;
            for (j3 = 0; j3 < jLen; j3 += 1) {
              for (k3 = 0; k3 < kLen; k3 += 1) {
                vertexValue = isHold ? keyPropS.i[j3][k3] : keyPropS.i[j3][k3] + (keyPropE.i[j3][k3] - keyPropS.i[j3][k3]) * perc;
                previousValue.i[j3][k3] = vertexValue;
                vertexValue = isHold ? keyPropS.o[j3][k3] : keyPropS.o[j3][k3] + (keyPropE.o[j3][k3] - keyPropS.o[j3][k3]) * perc;
                previousValue.o[j3][k3] = vertexValue;
                vertexValue = isHold ? keyPropS.v[j3][k3] : keyPropS.v[j3][k3] + (keyPropE.v[j3][k3] - keyPropS.v[j3][k3]) * perc;
                previousValue.v[j3][k3] = vertexValue;
              }
            }
          }
          function interpolateShapeCurrentTime() {
            var frameNum = this.comp.renderedFrame - this.offsetTime;
            var initTime = this.keyframes[0].t - this.offsetTime;
            var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
            var lastFrame = this._caching.lastFrame;
            if (!(lastFrame !== initFrame2 && (lastFrame < initTime && frameNum < initTime || lastFrame > endTime && frameNum > endTime))) {
              this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;
              this.interpolateShape(frameNum, this.pv, this._caching);
            }
            this._caching.lastFrame = frameNum;
            return this.pv;
          }
          function resetShape() {
            this.paths = this.localShapeCollection;
          }
          function shapesEqual(shape1, shape2) {
            if (shape1._length !== shape2._length || shape1.c !== shape2.c) {
              return false;
            }
            var i6;
            var len = shape1._length;
            for (i6 = 0; i6 < len; i6 += 1) {
              if (shape1.v[i6][0] !== shape2.v[i6][0] || shape1.v[i6][1] !== shape2.v[i6][1] || shape1.o[i6][0] !== shape2.o[i6][0] || shape1.o[i6][1] !== shape2.o[i6][1] || shape1.i[i6][0] !== shape2.i[i6][0] || shape1.i[i6][1] !== shape2.i[i6][1]) {
                return false;
              }
            }
            return true;
          }
          function setVValue2(newPath) {
            if (!shapesEqual(this.v, newPath)) {
              this.v = shapePool.clone(newPath);
              this.localShapeCollection.releaseShapes();
              this.localShapeCollection.addShape(this.v);
              this._mdf = true;
              this.paths = this.localShapeCollection;
            }
          }
          function processEffectsSequence2() {
            if (this.elem.globalData.frameId === this.frameId) {
              return;
            }
            if (!this.effectsSequence.length) {
              this._mdf = false;
              return;
            }
            if (this.lock) {
              this.setVValue(this.pv);
              return;
            }
            this.lock = true;
            this._mdf = false;
            var finalValue;
            if (this.kf) {
              finalValue = this.pv;
            } else if (this.data.ks) {
              finalValue = this.data.ks.k;
            } else {
              finalValue = this.data.pt.k;
            }
            var i6;
            var len = this.effectsSequence.length;
            for (i6 = 0; i6 < len; i6 += 1) {
              finalValue = this.effectsSequence[i6](finalValue);
            }
            this.setVValue(finalValue);
            this.lock = false;
            this.frameId = this.elem.globalData.frameId;
          }
          function ShapeProperty(elem2, data2, type) {
            this.propType = "shape";
            this.comp = elem2.comp;
            this.container = elem2;
            this.elem = elem2;
            this.data = data2;
            this.k = false;
            this.kf = false;
            this._mdf = false;
            var pathData = type === 3 ? data2.pt.k : data2.ks.k;
            this.v = shapePool.clone(pathData);
            this.pv = shapePool.clone(this.v);
            this.localShapeCollection = shapeCollectionPool.newShapeCollection();
            this.paths = this.localShapeCollection;
            this.paths.addShape(this.v);
            this.reset = resetShape;
            this.effectsSequence = [];
          }
          function addEffect2(effectFunction) {
            this.effectsSequence.push(effectFunction);
            this.container.addDynamicProperty(this);
          }
          ShapeProperty.prototype.interpolateShape = interpolateShape;
          ShapeProperty.prototype.getValue = processEffectsSequence2;
          ShapeProperty.prototype.setVValue = setVValue2;
          ShapeProperty.prototype.addEffect = addEffect2;
          function KeyframedShapeProperty(elem2, data2, type) {
            this.propType = "shape";
            this.comp = elem2.comp;
            this.elem = elem2;
            this.container = elem2;
            this.offsetTime = elem2.data.st;
            this.keyframes = type === 3 ? data2.pt.k : data2.ks.k;
            this.keyframesMetadata = [];
            this.k = true;
            this.kf = true;
            var len = this.keyframes[0].s[0].i.length;
            this.v = shapePool.newElement();
            this.v.setPathData(this.keyframes[0].s[0].c, len);
            this.pv = shapePool.clone(this.v);
            this.localShapeCollection = shapeCollectionPool.newShapeCollection();
            this.paths = this.localShapeCollection;
            this.paths.addShape(this.v);
            this.lastFrame = initFrame2;
            this.reset = resetShape;
            this._caching = {
              lastFrame: initFrame2,
              lastIndex: 0
            };
            this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];
          }
          KeyframedShapeProperty.prototype.getValue = processEffectsSequence2;
          KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;
          KeyframedShapeProperty.prototype.setVValue = setVValue2;
          KeyframedShapeProperty.prototype.addEffect = addEffect2;
          var EllShapeProperty = function() {
            var cPoint = roundCorner;
            function EllShapePropertyFactory(elem2, data2) {
              this.v = shapePool.newElement();
              this.v.setPathData(true, 4);
              this.localShapeCollection = shapeCollectionPool.newShapeCollection();
              this.paths = this.localShapeCollection;
              this.localShapeCollection.addShape(this.v);
              this.d = data2.d;
              this.elem = elem2;
              this.comp = elem2.comp;
              this.frameId = -1;
              this.initDynamicPropertyContainer(elem2);
              this.p = PropertyFactory.getProp(elem2, data2.p, 1, 0, this);
              this.s = PropertyFactory.getProp(elem2, data2.s, 1, 0, this);
              if (this.dynamicProperties.length) {
                this.k = true;
              } else {
                this.k = false;
                this.convertEllToPath();
              }
            }
            EllShapePropertyFactory.prototype = {
              reset: resetShape,
              getValue: function getValue() {
                if (this.elem.globalData.frameId === this.frameId) {
                  return;
                }
                this.frameId = this.elem.globalData.frameId;
                this.iterateDynamicProperties();
                if (this._mdf) {
                  this.convertEllToPath();
                }
              },
              convertEllToPath: function convertEllToPath() {
                var p0 = this.p.v[0];
                var p1 = this.p.v[1];
                var s0 = this.s.v[0] / 2;
                var s1 = this.s.v[1] / 2;
                var _cw = this.d !== 3;
                var _v = this.v;
                _v.v[0][0] = p0;
                _v.v[0][1] = p1 - s1;
                _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;
                _v.v[1][1] = p1;
                _v.v[2][0] = p0;
                _v.v[2][1] = p1 + s1;
                _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;
                _v.v[3][1] = p1;
                _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
                _v.i[0][1] = p1 - s1;
                _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;
                _v.i[1][1] = p1 - s1 * cPoint;
                _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
                _v.i[2][1] = p1 + s1;
                _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;
                _v.i[3][1] = p1 + s1 * cPoint;
                _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
                _v.o[0][1] = p1 - s1;
                _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;
                _v.o[1][1] = p1 + s1 * cPoint;
                _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
                _v.o[2][1] = p1 + s1;
                _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;
                _v.o[3][1] = p1 - s1 * cPoint;
              }
            };
            extendPrototype([DynamicPropertyContainer], EllShapePropertyFactory);
            return EllShapePropertyFactory;
          }();
          var StarShapeProperty = function() {
            function StarShapePropertyFactory(elem2, data2) {
              this.v = shapePool.newElement();
              this.v.setPathData(true, 0);
              this.elem = elem2;
              this.comp = elem2.comp;
              this.data = data2;
              this.frameId = -1;
              this.d = data2.d;
              this.initDynamicPropertyContainer(elem2);
              if (data2.sy === 1) {
                this.ir = PropertyFactory.getProp(elem2, data2.ir, 0, 0, this);
                this.is = PropertyFactory.getProp(elem2, data2.is, 0, 0.01, this);
                this.convertToPath = this.convertStarToPath;
              } else {
                this.convertToPath = this.convertPolygonToPath;
              }
              this.pt = PropertyFactory.getProp(elem2, data2.pt, 0, 0, this);
              this.p = PropertyFactory.getProp(elem2, data2.p, 1, 0, this);
              this.r = PropertyFactory.getProp(elem2, data2.r, 0, degToRads, this);
              this.or = PropertyFactory.getProp(elem2, data2.or, 0, 0, this);
              this.os = PropertyFactory.getProp(elem2, data2.os, 0, 0.01, this);
              this.localShapeCollection = shapeCollectionPool.newShapeCollection();
              this.localShapeCollection.addShape(this.v);
              this.paths = this.localShapeCollection;
              if (this.dynamicProperties.length) {
                this.k = true;
              } else {
                this.k = false;
                this.convertToPath();
              }
            }
            StarShapePropertyFactory.prototype = {
              reset: resetShape,
              getValue: function getValue() {
                if (this.elem.globalData.frameId === this.frameId) {
                  return;
                }
                this.frameId = this.elem.globalData.frameId;
                this.iterateDynamicProperties();
                if (this._mdf) {
                  this.convertToPath();
                }
              },
              convertStarToPath: function convertStarToPath() {
                var numPts = Math.floor(this.pt.v) * 2;
                var angle = Math.PI * 2 / numPts;
                var longFlag = true;
                var longRad = this.or.v;
                var shortRad = this.ir.v;
                var longRound = this.os.v;
                var shortRound = this.is.v;
                var longPerimSegment = 2 * Math.PI * longRad / (numPts * 2);
                var shortPerimSegment = 2 * Math.PI * shortRad / (numPts * 2);
                var i6;
                var rad;
                var roundness;
                var perimSegment;
                var currentAng = -Math.PI / 2;
                currentAng += this.r.v;
                var dir = this.data.d === 3 ? -1 : 1;
                this.v._length = 0;
                for (i6 = 0; i6 < numPts; i6 += 1) {
                  rad = longFlag ? longRad : shortRad;
                  roundness = longFlag ? longRound : shortRound;
                  perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
                  var x3 = rad * Math.cos(currentAng);
                  var y3 = rad * Math.sin(currentAng);
                  var ox = x3 === 0 && y3 === 0 ? 0 : y3 / Math.sqrt(x3 * x3 + y3 * y3);
                  var oy = x3 === 0 && y3 === 0 ? 0 : -x3 / Math.sqrt(x3 * x3 + y3 * y3);
                  x3 += +this.p.v[0];
                  y3 += +this.p.v[1];
                  this.v.setTripleAt(x3, y3, x3 - ox * perimSegment * roundness * dir, y3 - oy * perimSegment * roundness * dir, x3 + ox * perimSegment * roundness * dir, y3 + oy * perimSegment * roundness * dir, i6, true);
                  longFlag = !longFlag;
                  currentAng += angle * dir;
                }
              },
              convertPolygonToPath: function convertPolygonToPath() {
                var numPts = Math.floor(this.pt.v);
                var angle = Math.PI * 2 / numPts;
                var rad = this.or.v;
                var roundness = this.os.v;
                var perimSegment = 2 * Math.PI * rad / (numPts * 4);
                var i6;
                var currentAng = -Math.PI * 0.5;
                var dir = this.data.d === 3 ? -1 : 1;
                currentAng += this.r.v;
                this.v._length = 0;
                for (i6 = 0; i6 < numPts; i6 += 1) {
                  var x3 = rad * Math.cos(currentAng);
                  var y3 = rad * Math.sin(currentAng);
                  var ox = x3 === 0 && y3 === 0 ? 0 : y3 / Math.sqrt(x3 * x3 + y3 * y3);
                  var oy = x3 === 0 && y3 === 0 ? 0 : -x3 / Math.sqrt(x3 * x3 + y3 * y3);
                  x3 += +this.p.v[0];
                  y3 += +this.p.v[1];
                  this.v.setTripleAt(x3, y3, x3 - ox * perimSegment * roundness * dir, y3 - oy * perimSegment * roundness * dir, x3 + ox * perimSegment * roundness * dir, y3 + oy * perimSegment * roundness * dir, i6, true);
                  currentAng += angle * dir;
                }
                this.paths.length = 0;
                this.paths[0] = this.v;
              }
            };
            extendPrototype([DynamicPropertyContainer], StarShapePropertyFactory);
            return StarShapePropertyFactory;
          }();
          var RectShapeProperty = function() {
            function RectShapePropertyFactory(elem2, data2) {
              this.v = shapePool.newElement();
              this.v.c = true;
              this.localShapeCollection = shapeCollectionPool.newShapeCollection();
              this.localShapeCollection.addShape(this.v);
              this.paths = this.localShapeCollection;
              this.elem = elem2;
              this.comp = elem2.comp;
              this.frameId = -1;
              this.d = data2.d;
              this.initDynamicPropertyContainer(elem2);
              this.p = PropertyFactory.getProp(elem2, data2.p, 1, 0, this);
              this.s = PropertyFactory.getProp(elem2, data2.s, 1, 0, this);
              this.r = PropertyFactory.getProp(elem2, data2.r, 0, 0, this);
              if (this.dynamicProperties.length) {
                this.k = true;
              } else {
                this.k = false;
                this.convertRectToPath();
              }
            }
            RectShapePropertyFactory.prototype = {
              convertRectToPath: function convertRectToPath() {
                var p0 = this.p.v[0];
                var p1 = this.p.v[1];
                var v0 = this.s.v[0] / 2;
                var v1 = this.s.v[1] / 2;
                var round = bmMin(v0, v1, this.r.v);
                var cPoint = round * (1 - roundCorner);
                this.v._length = 0;
                if (this.d === 2 || this.d === 1) {
                  this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);
                  this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);
                  if (round !== 0) {
                    this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);
                    this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);
                    this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);
                    this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);
                    this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);
                    this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);
                  } else {
                    this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);
                    this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);
                  }
                } else {
                  this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);
                  if (round !== 0) {
                    this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);
                    this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);
                    this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);
                    this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);
                    this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);
                    this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);
                    this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);
                  } else {
                    this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);
                    this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);
                    this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);
                  }
                }
              },
              getValue: function getValue() {
                if (this.elem.globalData.frameId === this.frameId) {
                  return;
                }
                this.frameId = this.elem.globalData.frameId;
                this.iterateDynamicProperties();
                if (this._mdf) {
                  this.convertRectToPath();
                }
              },
              reset: resetShape
            };
            extendPrototype([DynamicPropertyContainer], RectShapePropertyFactory);
            return RectShapePropertyFactory;
          }();
          function getShapeProp(elem2, data2, type) {
            var prop;
            if (type === 3 || type === 4) {
              var dataProp = type === 3 ? data2.pt : data2.ks;
              var keys = dataProp.k;
              if (keys.length) {
                prop = new KeyframedShapeProperty(elem2, data2, type);
              } else {
                prop = new ShapeProperty(elem2, data2, type);
              }
            } else if (type === 5) {
              prop = new RectShapeProperty(elem2, data2);
            } else if (type === 6) {
              prop = new EllShapeProperty(elem2, data2);
            } else if (type === 7) {
              prop = new StarShapeProperty(elem2, data2);
            }
            if (prop.k) {
              elem2.addDynamicProperty(prop);
            }
            return prop;
          }
          function getConstructorFunction() {
            return ShapeProperty;
          }
          function getKeyframedConstructorFunction() {
            return KeyframedShapeProperty;
          }
          var ob2 = {};
          ob2.getShapeProp = getShapeProp;
          ob2.getConstructorFunction = getConstructorFunction;
          ob2.getKeyframedConstructorFunction = getKeyframedConstructorFunction;
          return ob2;
        }();
        var Matrix = /* @__PURE__ */ function() {
          var _cos2 = Math.cos;
          var _sin2 = Math.sin;
          var _tan = Math.tan;
          var _rnd = Math.round;
          function reset() {
            this.props[0] = 1;
            this.props[1] = 0;
            this.props[2] = 0;
            this.props[3] = 0;
            this.props[4] = 0;
            this.props[5] = 1;
            this.props[6] = 0;
            this.props[7] = 0;
            this.props[8] = 0;
            this.props[9] = 0;
            this.props[10] = 1;
            this.props[11] = 0;
            this.props[12] = 0;
            this.props[13] = 0;
            this.props[14] = 0;
            this.props[15] = 1;
            return this;
          }
          function rotate(angle) {
            if (angle === 0) {
              return this;
            }
            var mCos = _cos2(angle);
            var mSin = _sin2(angle);
            return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
          }
          function rotateX(angle) {
            if (angle === 0) {
              return this;
            }
            var mCos = _cos2(angle);
            var mSin = _sin2(angle);
            return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);
          }
          function rotateY(angle) {
            if (angle === 0) {
              return this;
            }
            var mCos = _cos2(angle);
            var mSin = _sin2(angle);
            return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);
          }
          function rotateZ(angle) {
            if (angle === 0) {
              return this;
            }
            var mCos = _cos2(angle);
            var mSin = _sin2(angle);
            return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
          }
          function shear(sx, sy) {
            return this._t(1, sy, sx, 1, 0, 0);
          }
          function skew(ax, ay) {
            return this.shear(_tan(ax), _tan(ay));
          }
          function skewFromAxis(ax, angle) {
            var mCos = _cos2(angle);
            var mSin = _sin2(angle);
            return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
          }
          function scale2(sx, sy, sz) {
            if (!sz && sz !== 0) {
              sz = 1;
            }
            if (sx === 1 && sy === 1 && sz === 1) {
              return this;
            }
            return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
          }
          function setTransform(a5, b3, c4, d3, e5, f3, g3, h2, i6, j3, k3, l6, m3, n6, o5, p3) {
            this.props[0] = a5;
            this.props[1] = b3;
            this.props[2] = c4;
            this.props[3] = d3;
            this.props[4] = e5;
            this.props[5] = f3;
            this.props[6] = g3;
            this.props[7] = h2;
            this.props[8] = i6;
            this.props[9] = j3;
            this.props[10] = k3;
            this.props[11] = l6;
            this.props[12] = m3;
            this.props[13] = n6;
            this.props[14] = o5;
            this.props[15] = p3;
            return this;
          }
          function translate2(tx, ty, tz) {
            tz = tz || 0;
            if (tx !== 0 || ty !== 0 || tz !== 0) {
              return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
            }
            return this;
          }
          function transform2(a22, b22, c22, d22, e22, f22, g22, h2, i22, j22, k22, l22, m22, n22, o22, p22) {
            var _p = this.props;
            if (a22 === 1 && b22 === 0 && c22 === 0 && d22 === 0 && e22 === 0 && f22 === 1 && g22 === 0 && h2 === 0 && i22 === 0 && j22 === 0 && k22 === 1 && l22 === 0) {
              _p[12] = _p[12] * a22 + _p[15] * m22;
              _p[13] = _p[13] * f22 + _p[15] * n22;
              _p[14] = _p[14] * k22 + _p[15] * o22;
              _p[15] *= p22;
              this._identityCalculated = false;
              return this;
            }
            var a1 = _p[0];
            var b1 = _p[1];
            var c1 = _p[2];
            var d1 = _p[3];
            var e1 = _p[4];
            var f1 = _p[5];
            var g1 = _p[6];
            var h1 = _p[7];
            var i1 = _p[8];
            var j1 = _p[9];
            var k1 = _p[10];
            var l1 = _p[11];
            var m1 = _p[12];
            var n1 = _p[13];
            var o1 = _p[14];
            var p1 = _p[15];
            _p[0] = a1 * a22 + b1 * e22 + c1 * i22 + d1 * m22;
            _p[1] = a1 * b22 + b1 * f22 + c1 * j22 + d1 * n22;
            _p[2] = a1 * c22 + b1 * g22 + c1 * k22 + d1 * o22;
            _p[3] = a1 * d22 + b1 * h2 + c1 * l22 + d1 * p22;
            _p[4] = e1 * a22 + f1 * e22 + g1 * i22 + h1 * m22;
            _p[5] = e1 * b22 + f1 * f22 + g1 * j22 + h1 * n22;
            _p[6] = e1 * c22 + f1 * g22 + g1 * k22 + h1 * o22;
            _p[7] = e1 * d22 + f1 * h2 + g1 * l22 + h1 * p22;
            _p[8] = i1 * a22 + j1 * e22 + k1 * i22 + l1 * m22;
            _p[9] = i1 * b22 + j1 * f22 + k1 * j22 + l1 * n22;
            _p[10] = i1 * c22 + j1 * g22 + k1 * k22 + l1 * o22;
            _p[11] = i1 * d22 + j1 * h2 + k1 * l22 + l1 * p22;
            _p[12] = m1 * a22 + n1 * e22 + o1 * i22 + p1 * m22;
            _p[13] = m1 * b22 + n1 * f22 + o1 * j22 + p1 * n22;
            _p[14] = m1 * c22 + n1 * g22 + o1 * k22 + p1 * o22;
            _p[15] = m1 * d22 + n1 * h2 + o1 * l22 + p1 * p22;
            this._identityCalculated = false;
            return this;
          }
          function multiply(matrix) {
            var matrixProps = matrix.props;
            return this.transform(matrixProps[0], matrixProps[1], matrixProps[2], matrixProps[3], matrixProps[4], matrixProps[5], matrixProps[6], matrixProps[7], matrixProps[8], matrixProps[9], matrixProps[10], matrixProps[11], matrixProps[12], matrixProps[13], matrixProps[14], matrixProps[15]);
          }
          function isIdentity() {
            if (!this._identityCalculated) {
              this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);
              this._identityCalculated = true;
            }
            return this._identity;
          }
          function equals(matr) {
            var i6 = 0;
            while (i6 < 16) {
              if (matr.props[i6] !== this.props[i6]) {
                return false;
              }
              i6 += 1;
            }
            return true;
          }
          function clone(matr) {
            var i6;
            for (i6 = 0; i6 < 16; i6 += 1) {
              matr.props[i6] = this.props[i6];
            }
            return matr;
          }
          function cloneFromProps(props) {
            var i6;
            for (i6 = 0; i6 < 16; i6 += 1) {
              this.props[i6] = props[i6];
            }
          }
          function applyToPoint(x3, y3, z2) {
            return {
              x: x3 * this.props[0] + y3 * this.props[4] + z2 * this.props[8] + this.props[12],
              y: x3 * this.props[1] + y3 * this.props[5] + z2 * this.props[9] + this.props[13],
              z: x3 * this.props[2] + y3 * this.props[6] + z2 * this.props[10] + this.props[14]
            };
          }
          function applyToX(x3, y3, z2) {
            return x3 * this.props[0] + y3 * this.props[4] + z2 * this.props[8] + this.props[12];
          }
          function applyToY(x3, y3, z2) {
            return x3 * this.props[1] + y3 * this.props[5] + z2 * this.props[9] + this.props[13];
          }
          function applyToZ(x3, y3, z2) {
            return x3 * this.props[2] + y3 * this.props[6] + z2 * this.props[10] + this.props[14];
          }
          function getInverseMatrix() {
            var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
            var a5 = this.props[5] / determinant;
            var b3 = -this.props[1] / determinant;
            var c4 = -this.props[4] / determinant;
            var d3 = this.props[0] / determinant;
            var e5 = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;
            var f3 = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;
            var inverseMatrix = new Matrix();
            inverseMatrix.props[0] = a5;
            inverseMatrix.props[1] = b3;
            inverseMatrix.props[4] = c4;
            inverseMatrix.props[5] = d3;
            inverseMatrix.props[12] = e5;
            inverseMatrix.props[13] = f3;
            return inverseMatrix;
          }
          function inversePoint(pt) {
            var inverseMatrix = this.getInverseMatrix();
            return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);
          }
          function inversePoints(pts) {
            var i6;
            var len = pts.length;
            var retPts = [];
            for (i6 = 0; i6 < len; i6 += 1) {
              retPts[i6] = inversePoint(pts[i6]);
            }
            return retPts;
          }
          function applyToTriplePoints(pt1, pt2, pt3) {
            var arr = createTypedArray("float32", 6);
            if (this.isIdentity()) {
              arr[0] = pt1[0];
              arr[1] = pt1[1];
              arr[2] = pt2[0];
              arr[3] = pt2[1];
              arr[4] = pt3[0];
              arr[5] = pt3[1];
            } else {
              var p0 = this.props[0];
              var p1 = this.props[1];
              var p4 = this.props[4];
              var p5 = this.props[5];
              var p12 = this.props[12];
              var p13 = this.props[13];
              arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;
              arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;
              arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;
              arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;
              arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;
              arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;
            }
            return arr;
          }
          function applyToPointArray(x3, y3, z2) {
            var arr;
            if (this.isIdentity()) {
              arr = [x3, y3, z2];
            } else {
              arr = [x3 * this.props[0] + y3 * this.props[4] + z2 * this.props[8] + this.props[12], x3 * this.props[1] + y3 * this.props[5] + z2 * this.props[9] + this.props[13], x3 * this.props[2] + y3 * this.props[6] + z2 * this.props[10] + this.props[14]];
            }
            return arr;
          }
          function applyToPointStringified(x3, y3) {
            if (this.isIdentity()) {
              return x3 + "," + y3;
            }
            var _p = this.props;
            return Math.round((x3 * _p[0] + y3 * _p[4] + _p[12]) * 100) / 100 + "," + Math.round((x3 * _p[1] + y3 * _p[5] + _p[13]) * 100) / 100;
          }
          function toCSS() {
            var i6 = 0;
            var props = this.props;
            var cssValue = "matrix3d(";
            var v2 = 1e4;
            while (i6 < 16) {
              cssValue += _rnd(props[i6] * v2) / v2;
              cssValue += i6 === 15 ? ")" : ",";
              i6 += 1;
            }
            return cssValue;
          }
          function roundMatrixProperty(val2) {
            var v2 = 1e4;
            if (val2 < 1e-6 && val2 > 0 || val2 > -1e-6 && val2 < 0) {
              return _rnd(val2 * v2) / v2;
            }
            return val2;
          }
          function to2dCSS() {
            var props = this.props;
            var _a = roundMatrixProperty(props[0]);
            var _b = roundMatrixProperty(props[1]);
            var _c = roundMatrixProperty(props[4]);
            var _d = roundMatrixProperty(props[5]);
            var _e2 = roundMatrixProperty(props[12]);
            var _f = roundMatrixProperty(props[13]);
            return "matrix(" + _a + "," + _b + "," + _c + "," + _d + "," + _e2 + "," + _f + ")";
          }
          return function() {
            this.reset = reset;
            this.rotate = rotate;
            this.rotateX = rotateX;
            this.rotateY = rotateY;
            this.rotateZ = rotateZ;
            this.skew = skew;
            this.skewFromAxis = skewFromAxis;
            this.shear = shear;
            this.scale = scale2;
            this.setTransform = setTransform;
            this.translate = translate2;
            this.transform = transform2;
            this.multiply = multiply;
            this.applyToPoint = applyToPoint;
            this.applyToX = applyToX;
            this.applyToY = applyToY;
            this.applyToZ = applyToZ;
            this.applyToPointArray = applyToPointArray;
            this.applyToTriplePoints = applyToTriplePoints;
            this.applyToPointStringified = applyToPointStringified;
            this.toCSS = toCSS;
            this.to2dCSS = to2dCSS;
            this.clone = clone;
            this.cloneFromProps = cloneFromProps;
            this.equals = equals;
            this.inversePoints = inversePoints;
            this.inversePoint = inversePoint;
            this.getInverseMatrix = getInverseMatrix;
            this._t = this.transform;
            this.isIdentity = isIdentity;
            this._identity = true;
            this._identityCalculated = false;
            this.props = createTypedArray("float32", 16);
            this.reset();
          };
        }();
        function _typeof$3(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof$3 = function _typeof3(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof$3 = function _typeof3(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof$3(obj);
        }
        var lottie = {};
        var standalone = "__[STANDALONE]__";
        var animationData = "__[ANIMATIONDATA]__";
        var renderer = "";
        function setLocation(href) {
          setLocationHref(href);
        }
        function searchAnimations() {
          if (standalone === true) {
            animationManager.searchAnimations(animationData, standalone, renderer);
          } else {
            animationManager.searchAnimations();
          }
        }
        function setSubframeRendering(flag) {
          setSubframeEnabled(flag);
        }
        function setPrefix(prefix) {
          setIdPrefix(prefix);
        }
        function loadAnimation(params) {
          if (standalone === true) {
            params.animationData = JSON.parse(animationData);
          }
          return animationManager.loadAnimation(params);
        }
        function setQuality(value2) {
          if (typeof value2 === "string") {
            switch (value2) {
              case "high":
                setDefaultCurveSegments(200);
                break;
              default:
              case "medium":
                setDefaultCurveSegments(50);
                break;
              case "low":
                setDefaultCurveSegments(10);
                break;
            }
          } else if (!isNaN(value2) && value2 > 1) {
            setDefaultCurveSegments(value2);
          }
          if (getDefaultCurveSegments() >= 50) {
            roundValues(false);
          } else {
            roundValues(true);
          }
        }
        function inBrowser() {
          return typeof navigator !== "undefined";
        }
        function installPlugin(type, plugin) {
          if (type === "expressions") {
            setExpressionsPlugin(plugin);
          }
        }
        function getFactory(name2) {
          switch (name2) {
            case "propertyFactory":
              return PropertyFactory;
            case "shapePropertyFactory":
              return ShapePropertyFactory;
            case "matrix":
              return Matrix;
            default:
              return null;
          }
        }
        lottie.play = animationManager.play;
        lottie.pause = animationManager.pause;
        lottie.setLocationHref = setLocation;
        lottie.togglePause = animationManager.togglePause;
        lottie.setSpeed = animationManager.setSpeed;
        lottie.setDirection = animationManager.setDirection;
        lottie.stop = animationManager.stop;
        lottie.searchAnimations = searchAnimations;
        lottie.registerAnimation = animationManager.registerAnimation;
        lottie.loadAnimation = loadAnimation;
        lottie.setSubframeRendering = setSubframeRendering;
        lottie.resize = animationManager.resize;
        lottie.goToAndStop = animationManager.goToAndStop;
        lottie.destroy = animationManager.destroy;
        lottie.setQuality = setQuality;
        lottie.inBrowser = inBrowser;
        lottie.installPlugin = installPlugin;
        lottie.freeze = animationManager.freeze;
        lottie.unfreeze = animationManager.unfreeze;
        lottie.setVolume = animationManager.setVolume;
        lottie.mute = animationManager.mute;
        lottie.unmute = animationManager.unmute;
        lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;
        lottie.useWebWorker = setWebWorker;
        lottie.setIDPrefix = setPrefix;
        lottie.__getFactory = getFactory;
        lottie.version = "5.12.2";
        function checkReady() {
          if (document.readyState === "complete") {
            clearInterval(readyStateCheckInterval);
            searchAnimations();
          }
        }
        function getQueryVariable(variable) {
          var vars = queryString.split("&");
          for (var i6 = 0; i6 < vars.length; i6 += 1) {
            var pair = vars[i6].split("=");
            if (decodeURIComponent(pair[0]) == variable) {
              return decodeURIComponent(pair[1]);
            }
          }
          return null;
        }
        var queryString = "";
        if (standalone) {
          var scripts = document.getElementsByTagName("script");
          var index = scripts.length - 1;
          var myScript = scripts[index] || {
            src: ""
          };
          queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : "";
          renderer = getQueryVariable("renderer");
        }
        var readyStateCheckInterval = setInterval(checkReady, 100);
        try {
          if (!((typeof exports === "undefined" ? "undefined" : _typeof$3(exports)) === "object" && typeof module !== "undefined") && !(typeof define === "function" && define.amd)) {
            window.bodymovin = lottie;
          }
        } catch (err) {
        }
        var ShapeModifiers = function() {
          var ob2 = {};
          var modifiers = {};
          ob2.registerModifier = registerModifier;
          ob2.getModifier = getModifier;
          function registerModifier(nm, factory) {
            if (!modifiers[nm]) {
              modifiers[nm] = factory;
            }
          }
          function getModifier(nm, elem2, data2) {
            return new modifiers[nm](elem2, data2);
          }
          return ob2;
        }();
        function ShapeModifier() {
        }
        ShapeModifier.prototype.initModifierProperties = function() {
        };
        ShapeModifier.prototype.addShapeToModifier = function() {
        };
        ShapeModifier.prototype.addShape = function(data2) {
          if (!this.closed) {
            data2.sh.container.addDynamicProperty(data2.sh);
            var shapeData = {
              shape: data2.sh,
              data: data2,
              localShapeCollection: shapeCollectionPool.newShapeCollection()
            };
            this.shapes.push(shapeData);
            this.addShapeToModifier(shapeData);
            if (this._isAnimated) {
              data2.setAsAnimated();
            }
          }
        };
        ShapeModifier.prototype.init = function(elem2, data2) {
          this.shapes = [];
          this.elem = elem2;
          this.initDynamicPropertyContainer(elem2);
          this.initModifierProperties(elem2, data2);
          this.frameId = initialDefaultFrame;
          this.closed = false;
          this.k = false;
          if (this.dynamicProperties.length) {
            this.k = true;
          } else {
            this.getValue(true);
          }
        };
        ShapeModifier.prototype.processKeys = function() {
          if (this.elem.globalData.frameId === this.frameId) {
            return;
          }
          this.frameId = this.elem.globalData.frameId;
          this.iterateDynamicProperties();
        };
        extendPrototype([DynamicPropertyContainer], ShapeModifier);
        function TrimModifier() {
        }
        extendPrototype([ShapeModifier], TrimModifier);
        TrimModifier.prototype.initModifierProperties = function(elem2, data2) {
          this.s = PropertyFactory.getProp(elem2, data2.s, 0, 0.01, this);
          this.e = PropertyFactory.getProp(elem2, data2.e, 0, 0.01, this);
          this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0, this);
          this.sValue = 0;
          this.eValue = 0;
          this.getValue = this.processKeys;
          this.m = data2.m;
          this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
        };
        TrimModifier.prototype.addShapeToModifier = function(shapeData) {
          shapeData.pathsData = [];
        };
        TrimModifier.prototype.calculateShapeEdges = function(s4, e5, shapeLength, addedLength, totalModifierLength) {
          var segments = [];
          if (e5 <= 1) {
            segments.push({
              s: s4,
              e: e5
            });
          } else if (s4 >= 1) {
            segments.push({
              s: s4 - 1,
              e: e5 - 1
            });
          } else {
            segments.push({
              s: s4,
              e: 1
            });
            segments.push({
              s: 0,
              e: e5 - 1
            });
          }
          var shapeSegments = [];
          var i6;
          var len = segments.length;
          var segmentOb;
          for (i6 = 0; i6 < len; i6 += 1) {
            segmentOb = segments[i6];
            if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {
              var shapeS;
              var shapeE;
              if (segmentOb.s * totalModifierLength <= addedLength) {
                shapeS = 0;
              } else {
                shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
              }
              if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {
                shapeE = 1;
              } else {
                shapeE = (segmentOb.e * totalModifierLength - addedLength) / shapeLength;
              }
              shapeSegments.push([shapeS, shapeE]);
            }
          }
          if (!shapeSegments.length) {
            shapeSegments.push([0, 0]);
          }
          return shapeSegments;
        };
        TrimModifier.prototype.releasePathsData = function(pathsData) {
          var i6;
          var len = pathsData.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            segmentsLengthPool.release(pathsData[i6]);
          }
          pathsData.length = 0;
          return pathsData;
        };
        TrimModifier.prototype.processShapes = function(_isFirstFrame) {
          var s4;
          var e5;
          if (this._mdf || _isFirstFrame) {
            var o5 = this.o.v % 360 / 360;
            if (o5 < 0) {
              o5 += 1;
            }
            if (this.s.v > 1) {
              s4 = 1 + o5;
            } else if (this.s.v < 0) {
              s4 = 0 + o5;
            } else {
              s4 = this.s.v + o5;
            }
            if (this.e.v > 1) {
              e5 = 1 + o5;
            } else if (this.e.v < 0) {
              e5 = 0 + o5;
            } else {
              e5 = this.e.v + o5;
            }
            if (s4 > e5) {
              var _s = s4;
              s4 = e5;
              e5 = _s;
            }
            s4 = Math.round(s4 * 1e4) * 1e-4;
            e5 = Math.round(e5 * 1e4) * 1e-4;
            this.sValue = s4;
            this.eValue = e5;
          } else {
            s4 = this.sValue;
            e5 = this.eValue;
          }
          var shapePaths;
          var i6;
          var len = this.shapes.length;
          var j3;
          var jLen;
          var pathsData;
          var pathData;
          var totalShapeLength;
          var totalModifierLength = 0;
          if (e5 === s4) {
            for (i6 = 0; i6 < len; i6 += 1) {
              this.shapes[i6].localShapeCollection.releaseShapes();
              this.shapes[i6].shape._mdf = true;
              this.shapes[i6].shape.paths = this.shapes[i6].localShapeCollection;
              if (this._mdf) {
                this.shapes[i6].pathsData.length = 0;
              }
            }
          } else if (!(e5 === 1 && s4 === 0 || e5 === 0 && s4 === 1)) {
            var segments = [];
            var shapeData;
            var localShapeCollection;
            for (i6 = 0; i6 < len; i6 += 1) {
              shapeData = this.shapes[i6];
              if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {
                shapeData.shape.paths = shapeData.localShapeCollection;
              } else {
                shapePaths = shapeData.shape.paths;
                jLen = shapePaths._length;
                totalShapeLength = 0;
                if (!shapeData.shape._mdf && shapeData.pathsData.length) {
                  totalShapeLength = shapeData.totalShapeLength;
                } else {
                  pathsData = this.releasePathsData(shapeData.pathsData);
                  for (j3 = 0; j3 < jLen; j3 += 1) {
                    pathData = bez.getSegmentsLength(shapePaths.shapes[j3]);
                    pathsData.push(pathData);
                    totalShapeLength += pathData.totalLength;
                  }
                  shapeData.totalShapeLength = totalShapeLength;
                  shapeData.pathsData = pathsData;
                }
                totalModifierLength += totalShapeLength;
                shapeData.shape._mdf = true;
              }
            }
            var shapeS = s4;
            var shapeE = e5;
            var addedLength = 0;
            var edges;
            for (i6 = len - 1; i6 >= 0; i6 -= 1) {
              shapeData = this.shapes[i6];
              if (shapeData.shape._mdf) {
                localShapeCollection = shapeData.localShapeCollection;
                localShapeCollection.releaseShapes();
                if (this.m === 2 && len > 1) {
                  edges = this.calculateShapeEdges(s4, e5, shapeData.totalShapeLength, addedLength, totalModifierLength);
                  addedLength += shapeData.totalShapeLength;
                } else {
                  edges = [[shapeS, shapeE]];
                }
                jLen = edges.length;
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  shapeS = edges[j3][0];
                  shapeE = edges[j3][1];
                  segments.length = 0;
                  if (shapeE <= 1) {
                    segments.push({
                      s: shapeData.totalShapeLength * shapeS,
                      e: shapeData.totalShapeLength * shapeE
                    });
                  } else if (shapeS >= 1) {
                    segments.push({
                      s: shapeData.totalShapeLength * (shapeS - 1),
                      e: shapeData.totalShapeLength * (shapeE - 1)
                    });
                  } else {
                    segments.push({
                      s: shapeData.totalShapeLength * shapeS,
                      e: shapeData.totalShapeLength
                    });
                    segments.push({
                      s: 0,
                      e: shapeData.totalShapeLength * (shapeE - 1)
                    });
                  }
                  var newShapesData = this.addShapes(shapeData, segments[0]);
                  if (segments[0].s !== segments[0].e) {
                    if (segments.length > 1) {
                      var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];
                      if (lastShapeInCollection.c) {
                        var lastShape = newShapesData.pop();
                        this.addPaths(newShapesData, localShapeCollection);
                        newShapesData = this.addShapes(shapeData, segments[1], lastShape);
                      } else {
                        this.addPaths(newShapesData, localShapeCollection);
                        newShapesData = this.addShapes(shapeData, segments[1]);
                      }
                    }
                    this.addPaths(newShapesData, localShapeCollection);
                  }
                }
                shapeData.shape.paths = localShapeCollection;
              }
            }
          } else if (this._mdf) {
            for (i6 = 0; i6 < len; i6 += 1) {
              this.shapes[i6].pathsData.length = 0;
              this.shapes[i6].shape._mdf = true;
            }
          }
        };
        TrimModifier.prototype.addPaths = function(newPaths, localShapeCollection) {
          var i6;
          var len = newPaths.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            localShapeCollection.addShape(newPaths[i6]);
          }
        };
        TrimModifier.prototype.addSegment = function(pt1, pt2, pt3, pt4, shapePath, pos, newShape) {
          shapePath.setXYAt(pt2[0], pt2[1], "o", pos);
          shapePath.setXYAt(pt3[0], pt3[1], "i", pos + 1);
          if (newShape) {
            shapePath.setXYAt(pt1[0], pt1[1], "v", pos);
          }
          shapePath.setXYAt(pt4[0], pt4[1], "v", pos + 1);
        };
        TrimModifier.prototype.addSegmentFromArray = function(points, shapePath, pos, newShape) {
          shapePath.setXYAt(points[1], points[5], "o", pos);
          shapePath.setXYAt(points[2], points[6], "i", pos + 1);
          if (newShape) {
            shapePath.setXYAt(points[0], points[4], "v", pos);
          }
          shapePath.setXYAt(points[3], points[7], "v", pos + 1);
        };
        TrimModifier.prototype.addShapes = function(shapeData, shapeSegment, shapePath) {
          var pathsData = shapeData.pathsData;
          var shapePaths = shapeData.shape.paths.shapes;
          var i6;
          var len = shapeData.shape.paths._length;
          var j3;
          var jLen;
          var addedLength = 0;
          var currentLengthData;
          var segmentCount;
          var lengths;
          var segment;
          var shapes = [];
          var initPos;
          var newShape = true;
          if (!shapePath) {
            shapePath = shapePool.newElement();
            segmentCount = 0;
            initPos = 0;
          } else {
            segmentCount = shapePath._length;
            initPos = shapePath._length;
          }
          shapes.push(shapePath);
          for (i6 = 0; i6 < len; i6 += 1) {
            lengths = pathsData[i6].lengths;
            shapePath.c = shapePaths[i6].c;
            jLen = shapePaths[i6].c ? lengths.length : lengths.length + 1;
            for (j3 = 1; j3 < jLen; j3 += 1) {
              currentLengthData = lengths[j3 - 1];
              if (addedLength + currentLengthData.addedLength < shapeSegment.s) {
                addedLength += currentLengthData.addedLength;
                shapePath.c = false;
              } else if (addedLength > shapeSegment.e) {
                shapePath.c = false;
                break;
              } else {
                if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {
                  this.addSegment(shapePaths[i6].v[j3 - 1], shapePaths[i6].o[j3 - 1], shapePaths[i6].i[j3], shapePaths[i6].v[j3], shapePath, segmentCount, newShape);
                  newShape = false;
                } else {
                  segment = bez.getNewSegment(shapePaths[i6].v[j3 - 1], shapePaths[i6].v[j3], shapePaths[i6].o[j3 - 1], shapePaths[i6].i[j3], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j3 - 1]);
                  this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
                  newShape = false;
                  shapePath.c = false;
                }
                addedLength += currentLengthData.addedLength;
                segmentCount += 1;
              }
            }
            if (shapePaths[i6].c && lengths.length) {
              currentLengthData = lengths[j3 - 1];
              if (addedLength <= shapeSegment.e) {
                var segmentLength = lengths[j3 - 1].addedLength;
                if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {
                  this.addSegment(shapePaths[i6].v[j3 - 1], shapePaths[i6].o[j3 - 1], shapePaths[i6].i[0], shapePaths[i6].v[0], shapePath, segmentCount, newShape);
                  newShape = false;
                } else {
                  segment = bez.getNewSegment(shapePaths[i6].v[j3 - 1], shapePaths[i6].v[0], shapePaths[i6].o[j3 - 1], shapePaths[i6].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j3 - 1]);
                  this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
                  newShape = false;
                  shapePath.c = false;
                }
              } else {
                shapePath.c = false;
              }
              addedLength += currentLengthData.addedLength;
              segmentCount += 1;
            }
            if (shapePath._length) {
              shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], "i", initPos);
              shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], "o", shapePath._length - 1);
            }
            if (addedLength > shapeSegment.e) {
              break;
            }
            if (i6 < len - 1) {
              shapePath = shapePool.newElement();
              newShape = true;
              shapes.push(shapePath);
              segmentCount = 0;
            }
          }
          return shapes;
        };
        function PuckerAndBloatModifier() {
        }
        extendPrototype([ShapeModifier], PuckerAndBloatModifier);
        PuckerAndBloatModifier.prototype.initModifierProperties = function(elem2, data2) {
          this.getValue = this.processKeys;
          this.amount = PropertyFactory.getProp(elem2, data2.a, 0, null, this);
          this._isAnimated = !!this.amount.effectsSequence.length;
        };
        PuckerAndBloatModifier.prototype.processPath = function(path, amount) {
          var percent = amount / 100;
          var centerPoint = [0, 0];
          var pathLength = path._length;
          var i6 = 0;
          for (i6 = 0; i6 < pathLength; i6 += 1) {
            centerPoint[0] += path.v[i6][0];
            centerPoint[1] += path.v[i6][1];
          }
          centerPoint[0] /= pathLength;
          centerPoint[1] /= pathLength;
          var clonedPath = shapePool.newElement();
          clonedPath.c = path.c;
          var vX;
          var vY;
          var oX;
          var oY;
          var iX;
          var iY;
          for (i6 = 0; i6 < pathLength; i6 += 1) {
            vX = path.v[i6][0] + (centerPoint[0] - path.v[i6][0]) * percent;
            vY = path.v[i6][1] + (centerPoint[1] - path.v[i6][1]) * percent;
            oX = path.o[i6][0] + (centerPoint[0] - path.o[i6][0]) * -percent;
            oY = path.o[i6][1] + (centerPoint[1] - path.o[i6][1]) * -percent;
            iX = path.i[i6][0] + (centerPoint[0] - path.i[i6][0]) * -percent;
            iY = path.i[i6][1] + (centerPoint[1] - path.i[i6][1]) * -percent;
            clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i6);
          }
          return clonedPath;
        };
        PuckerAndBloatModifier.prototype.processShapes = function(_isFirstFrame) {
          var shapePaths;
          var i6;
          var len = this.shapes.length;
          var j3;
          var jLen;
          var amount = this.amount.v;
          if (amount !== 0) {
            var shapeData;
            var localShapeCollection;
            for (i6 = 0; i6 < len; i6 += 1) {
              shapeData = this.shapes[i6];
              localShapeCollection = shapeData.localShapeCollection;
              if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
                localShapeCollection.releaseShapes();
                shapeData.shape._mdf = true;
                shapePaths = shapeData.shape.paths.shapes;
                jLen = shapeData.shape.paths._length;
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  localShapeCollection.addShape(this.processPath(shapePaths[j3], amount));
                }
              }
              shapeData.shape.paths = shapeData.localShapeCollection;
            }
          }
          if (!this.dynamicProperties.length) {
            this._mdf = false;
          }
        };
        var TransformPropertyFactory = function() {
          var defaultVector = [0, 0];
          function applyToMatrix(mat) {
            var _mdf = this._mdf;
            this.iterateDynamicProperties();
            this._mdf = this._mdf || _mdf;
            if (this.a) {
              mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
            }
            if (this.s) {
              mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
            }
            if (this.sk) {
              mat.skewFromAxis(-this.sk.v, this.sa.v);
            }
            if (this.r) {
              mat.rotate(-this.r.v);
            } else {
              mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
            }
            if (this.data.p.s) {
              if (this.data.p.z) {
                mat.translate(this.px.v, this.py.v, -this.pz.v);
              } else {
                mat.translate(this.px.v, this.py.v, 0);
              }
            } else {
              mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
            }
          }
          function processKeys(forceRender) {
            if (this.elem.globalData.frameId === this.frameId) {
              return;
            }
            if (this._isDirty) {
              this.precalculateMatrix();
              this._isDirty = false;
            }
            this.iterateDynamicProperties();
            if (this._mdf || forceRender) {
              var frameRate;
              this.v.cloneFromProps(this.pre.props);
              if (this.appliedTransformations < 1) {
                this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
              }
              if (this.appliedTransformations < 2) {
                this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
              }
              if (this.sk && this.appliedTransformations < 3) {
                this.v.skewFromAxis(-this.sk.v, this.sa.v);
              }
              if (this.r && this.appliedTransformations < 4) {
                this.v.rotate(-this.r.v);
              } else if (!this.r && this.appliedTransformations < 4) {
                this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
              }
              if (this.autoOriented) {
                var v1;
                var v2;
                frameRate = this.elem.globalData.frameRate;
                if (this.p && this.p.keyframes && this.p.getValueAtTime) {
                  if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {
                    v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);
                    v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);
                  } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
                    v1 = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / frameRate, 0);
                    v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);
                  } else {
                    v1 = this.p.pv;
                    v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);
                  }
                } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                  v1 = [];
                  v2 = [];
                  var px = this.px;
                  var py = this.py;
                  if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {
                    v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0);
                    v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0);
                    v2[0] = px.getValueAtTime(px.keyframes[0].t / frameRate, 0);
                    v2[1] = py.getValueAtTime(py.keyframes[0].t / frameRate, 0);
                  } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {
                    v1[0] = px.getValueAtTime(px.keyframes[px.keyframes.length - 1].t / frameRate, 0);
                    v1[1] = py.getValueAtTime(py.keyframes[py.keyframes.length - 1].t / frameRate, 0);
                    v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0);
                    v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0);
                  } else {
                    v1 = [px.pv, py.pv];
                    v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime);
                    v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime);
                  }
                } else {
                  v2 = defaultVector;
                  v1 = v2;
                }
                this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
              }
              if (this.data.p && this.data.p.s) {
                if (this.data.p.z) {
                  this.v.translate(this.px.v, this.py.v, -this.pz.v);
                } else {
                  this.v.translate(this.px.v, this.py.v, 0);
                }
              } else {
                this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
              }
            }
            this.frameId = this.elem.globalData.frameId;
          }
          function precalculateMatrix() {
            this.appliedTransformations = 0;
            this.pre.reset();
            if (!this.a.effectsSequence.length) {
              this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
              this.appliedTransformations = 1;
            } else {
              return;
            }
            if (!this.s.effectsSequence.length) {
              this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
              this.appliedTransformations = 2;
            } else {
              return;
            }
            if (this.sk) {
              if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {
                this.pre.skewFromAxis(-this.sk.v, this.sa.v);
                this.appliedTransformations = 3;
              } else {
                return;
              }
            }
            if (this.r) {
              if (!this.r.effectsSequence.length) {
                this.pre.rotate(-this.r.v);
                this.appliedTransformations = 4;
              }
            } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {
              this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
              this.appliedTransformations = 4;
            }
          }
          function autoOrient() {
          }
          function addDynamicProperty(prop) {
            this._addDynamicProperty(prop);
            this.elem.addDynamicProperty(prop);
            this._isDirty = true;
          }
          function TransformProperty(elem2, data2, container) {
            this.elem = elem2;
            this.frameId = -1;
            this.propType = "transform";
            this.data = data2;
            this.v = new Matrix();
            this.pre = new Matrix();
            this.appliedTransformations = 0;
            this.initDynamicPropertyContainer(container || elem2);
            if (data2.p && data2.p.s) {
              this.px = PropertyFactory.getProp(elem2, data2.p.x, 0, 0, this);
              this.py = PropertyFactory.getProp(elem2, data2.p.y, 0, 0, this);
              if (data2.p.z) {
                this.pz = PropertyFactory.getProp(elem2, data2.p.z, 0, 0, this);
              }
            } else {
              this.p = PropertyFactory.getProp(elem2, data2.p || {
                k: [0, 0, 0]
              }, 1, 0, this);
            }
            if (data2.rx) {
              this.rx = PropertyFactory.getProp(elem2, data2.rx, 0, degToRads, this);
              this.ry = PropertyFactory.getProp(elem2, data2.ry, 0, degToRads, this);
              this.rz = PropertyFactory.getProp(elem2, data2.rz, 0, degToRads, this);
              if (data2.or.k[0].ti) {
                var i6;
                var len = data2.or.k.length;
                for (i6 = 0; i6 < len; i6 += 1) {
                  data2.or.k[i6].to = null;
                  data2.or.k[i6].ti = null;
                }
              }
              this.or = PropertyFactory.getProp(elem2, data2.or, 1, degToRads, this);
              this.or.sh = true;
            } else {
              this.r = PropertyFactory.getProp(elem2, data2.r || {
                k: 0
              }, 0, degToRads, this);
            }
            if (data2.sk) {
              this.sk = PropertyFactory.getProp(elem2, data2.sk, 0, degToRads, this);
              this.sa = PropertyFactory.getProp(elem2, data2.sa, 0, degToRads, this);
            }
            this.a = PropertyFactory.getProp(elem2, data2.a || {
              k: [0, 0, 0]
            }, 1, 0, this);
            this.s = PropertyFactory.getProp(elem2, data2.s || {
              k: [100, 100, 100]
            }, 1, 0.01, this);
            if (data2.o) {
              this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, elem2);
            } else {
              this.o = {
                _mdf: false,
                v: 1
              };
            }
            this._isDirty = true;
            if (!this.dynamicProperties.length) {
              this.getValue(true);
            }
          }
          TransformProperty.prototype = {
            applyToMatrix,
            getValue: processKeys,
            precalculateMatrix,
            autoOrient
          };
          extendPrototype([DynamicPropertyContainer], TransformProperty);
          TransformProperty.prototype.addDynamicProperty = addDynamicProperty;
          TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;
          function getTransformProperty(elem2, data2, container) {
            return new TransformProperty(elem2, data2, container);
          }
          return {
            getTransformProperty
          };
        }();
        function RepeaterModifier() {
        }
        extendPrototype([ShapeModifier], RepeaterModifier);
        RepeaterModifier.prototype.initModifierProperties = function(elem2, data2) {
          this.getValue = this.processKeys;
          this.c = PropertyFactory.getProp(elem2, data2.c, 0, null, this);
          this.o = PropertyFactory.getProp(elem2, data2.o, 0, null, this);
          this.tr = TransformPropertyFactory.getTransformProperty(elem2, data2.tr, this);
          this.so = PropertyFactory.getProp(elem2, data2.tr.so, 0, 0.01, this);
          this.eo = PropertyFactory.getProp(elem2, data2.tr.eo, 0, 0.01, this);
          this.data = data2;
          if (!this.dynamicProperties.length) {
            this.getValue(true);
          }
          this._isAnimated = !!this.dynamicProperties.length;
          this.pMatrix = new Matrix();
          this.rMatrix = new Matrix();
          this.sMatrix = new Matrix();
          this.tMatrix = new Matrix();
          this.matrix = new Matrix();
        };
        RepeaterModifier.prototype.applyTransforms = function(pMatrix, rMatrix, sMatrix, transform2, perc, inv) {
          var dir = inv ? -1 : 1;
          var scaleX = transform2.s.v[0] + (1 - transform2.s.v[0]) * (1 - perc);
          var scaleY = transform2.s.v[1] + (1 - transform2.s.v[1]) * (1 - perc);
          pMatrix.translate(transform2.p.v[0] * dir * perc, transform2.p.v[1] * dir * perc, transform2.p.v[2]);
          rMatrix.translate(-transform2.a.v[0], -transform2.a.v[1], transform2.a.v[2]);
          rMatrix.rotate(-transform2.r.v * dir * perc);
          rMatrix.translate(transform2.a.v[0], transform2.a.v[1], transform2.a.v[2]);
          sMatrix.translate(-transform2.a.v[0], -transform2.a.v[1], transform2.a.v[2]);
          sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);
          sMatrix.translate(transform2.a.v[0], transform2.a.v[1], transform2.a.v[2]);
        };
        RepeaterModifier.prototype.init = function(elem2, arr, pos, elemsData) {
          this.elem = elem2;
          this.arr = arr;
          this.pos = pos;
          this.elemsData = elemsData;
          this._currentCopies = 0;
          this._elements = [];
          this._groups = [];
          this.frameId = -1;
          this.initDynamicPropertyContainer(elem2);
          this.initModifierProperties(elem2, arr[pos]);
          while (pos > 0) {
            pos -= 1;
            this._elements.unshift(arr[pos]);
          }
          if (this.dynamicProperties.length) {
            this.k = true;
          } else {
            this.getValue(true);
          }
        };
        RepeaterModifier.prototype.resetElements = function(elements) {
          var i6;
          var len = elements.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            elements[i6]._processed = false;
            if (elements[i6].ty === "gr") {
              this.resetElements(elements[i6].it);
            }
          }
        };
        RepeaterModifier.prototype.cloneElements = function(elements) {
          var newElements = JSON.parse(JSON.stringify(elements));
          this.resetElements(newElements);
          return newElements;
        };
        RepeaterModifier.prototype.changeGroupRender = function(elements, renderFlag) {
          var i6;
          var len = elements.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            elements[i6]._render = renderFlag;
            if (elements[i6].ty === "gr") {
              this.changeGroupRender(elements[i6].it, renderFlag);
            }
          }
        };
        RepeaterModifier.prototype.processShapes = function(_isFirstFrame) {
          var items;
          var itemsTransform;
          var i6;
          var dir;
          var cont;
          var hasReloaded = false;
          if (this._mdf || _isFirstFrame) {
            var copies = Math.ceil(this.c.v);
            if (this._groups.length < copies) {
              while (this._groups.length < copies) {
                var group = {
                  it: this.cloneElements(this._elements),
                  ty: "gr"
                };
                group.it.push({
                  a: {
                    a: 0,
                    ix: 1,
                    k: [0, 0]
                  },
                  nm: "Transform",
                  o: {
                    a: 0,
                    ix: 7,
                    k: 100
                  },
                  p: {
                    a: 0,
                    ix: 2,
                    k: [0, 0]
                  },
                  r: {
                    a: 1,
                    ix: 6,
                    k: [{
                      s: 0,
                      e: 0,
                      t: 0
                    }, {
                      s: 0,
                      e: 0,
                      t: 1
                    }]
                  },
                  s: {
                    a: 0,
                    ix: 3,
                    k: [100, 100]
                  },
                  sa: {
                    a: 0,
                    ix: 5,
                    k: 0
                  },
                  sk: {
                    a: 0,
                    ix: 4,
                    k: 0
                  },
                  ty: "tr"
                });
                this.arr.splice(0, 0, group);
                this._groups.splice(0, 0, group);
                this._currentCopies += 1;
              }
              this.elem.reloadShapes();
              hasReloaded = true;
            }
            cont = 0;
            var renderFlag;
            for (i6 = 0; i6 <= this._groups.length - 1; i6 += 1) {
              renderFlag = cont < copies;
              this._groups[i6]._render = renderFlag;
              this.changeGroupRender(this._groups[i6].it, renderFlag);
              if (!renderFlag) {
                var elems = this.elemsData[i6].it;
                var transformData = elems[elems.length - 1];
                if (transformData.transform.op.v !== 0) {
                  transformData.transform.op._mdf = true;
                  transformData.transform.op.v = 0;
                } else {
                  transformData.transform.op._mdf = false;
                }
              }
              cont += 1;
            }
            this._currentCopies = copies;
            var offset = this.o.v;
            var offsetModulo = offset % 1;
            var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);
            var pProps = this.pMatrix.props;
            var rProps = this.rMatrix.props;
            var sProps = this.sMatrix.props;
            this.pMatrix.reset();
            this.rMatrix.reset();
            this.sMatrix.reset();
            this.tMatrix.reset();
            this.matrix.reset();
            var iteration = 0;
            if (offset > 0) {
              while (iteration < roundOffset) {
                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
                iteration += 1;
              }
              if (offsetModulo) {
                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
                iteration += offsetModulo;
              }
            } else if (offset < 0) {
              while (iteration > roundOffset) {
                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
                iteration -= 1;
              }
              if (offsetModulo) {
                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);
                iteration -= offsetModulo;
              }
            }
            i6 = this.data.m === 1 ? 0 : this._currentCopies - 1;
            dir = this.data.m === 1 ? 1 : -1;
            cont = this._currentCopies;
            var j3;
            var jLen;
            while (cont) {
              items = this.elemsData[i6].it;
              itemsTransform = items[items.length - 1].transform.mProps.v.props;
              jLen = itemsTransform.length;
              items[items.length - 1].transform.mProps._mdf = true;
              items[items.length - 1].transform.op._mdf = true;
              items[items.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i6 / (this._currentCopies - 1));
              if (iteration !== 0) {
                if (i6 !== 0 && dir === 1 || i6 !== this._currentCopies - 1 && dir === -1) {
                  this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
                }
                this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);
                this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);
                this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  itemsTransform[j3] = this.matrix.props[j3];
                }
                this.matrix.reset();
              } else {
                this.matrix.reset();
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  itemsTransform[j3] = this.matrix.props[j3];
                }
              }
              iteration += 1;
              cont -= 1;
              i6 += dir;
            }
          } else {
            cont = this._currentCopies;
            i6 = 0;
            dir = 1;
            while (cont) {
              items = this.elemsData[i6].it;
              itemsTransform = items[items.length - 1].transform.mProps.v.props;
              items[items.length - 1].transform.mProps._mdf = false;
              items[items.length - 1].transform.op._mdf = false;
              cont -= 1;
              i6 += dir;
            }
          }
          return hasReloaded;
        };
        RepeaterModifier.prototype.addShape = function() {
        };
        function RoundCornersModifier() {
        }
        extendPrototype([ShapeModifier], RoundCornersModifier);
        RoundCornersModifier.prototype.initModifierProperties = function(elem2, data2) {
          this.getValue = this.processKeys;
          this.rd = PropertyFactory.getProp(elem2, data2.r, 0, null, this);
          this._isAnimated = !!this.rd.effectsSequence.length;
        };
        RoundCornersModifier.prototype.processPath = function(path, round) {
          var clonedPath = shapePool.newElement();
          clonedPath.c = path.c;
          var i6;
          var len = path._length;
          var currentV;
          var currentI;
          var currentO;
          var closerV;
          var distance;
          var newPosPerc;
          var index2 = 0;
          var vX;
          var vY;
          var oX;
          var oY;
          var iX;
          var iY;
          for (i6 = 0; i6 < len; i6 += 1) {
            currentV = path.v[i6];
            currentO = path.o[i6];
            currentI = path.i[i6];
            if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {
              if ((i6 === 0 || i6 === len - 1) && !path.c) {
                clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index2);
                index2 += 1;
              } else {
                if (i6 === 0) {
                  closerV = path.v[len - 1];
                } else {
                  closerV = path.v[i6 - 1];
                }
                distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
                newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
                iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
                vX = iX;
                iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;
                vY = iY;
                oX = vX - (vX - currentV[0]) * roundCorner;
                oY = vY - (vY - currentV[1]) * roundCorner;
                clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index2);
                index2 += 1;
                if (i6 === len - 1) {
                  closerV = path.v[0];
                } else {
                  closerV = path.v[i6 + 1];
                }
                distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
                newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
                oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
                vX = oX;
                oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;
                vY = oY;
                iX = vX - (vX - currentV[0]) * roundCorner;
                iY = vY - (vY - currentV[1]) * roundCorner;
                clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index2);
                index2 += 1;
              }
            } else {
              clonedPath.setTripleAt(path.v[i6][0], path.v[i6][1], path.o[i6][0], path.o[i6][1], path.i[i6][0], path.i[i6][1], index2);
              index2 += 1;
            }
          }
          return clonedPath;
        };
        RoundCornersModifier.prototype.processShapes = function(_isFirstFrame) {
          var shapePaths;
          var i6;
          var len = this.shapes.length;
          var j3;
          var jLen;
          var rd = this.rd.v;
          if (rd !== 0) {
            var shapeData;
            var localShapeCollection;
            for (i6 = 0; i6 < len; i6 += 1) {
              shapeData = this.shapes[i6];
              localShapeCollection = shapeData.localShapeCollection;
              if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
                localShapeCollection.releaseShapes();
                shapeData.shape._mdf = true;
                shapePaths = shapeData.shape.paths.shapes;
                jLen = shapeData.shape.paths._length;
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  localShapeCollection.addShape(this.processPath(shapePaths[j3], rd));
                }
              }
              shapeData.shape.paths = shapeData.localShapeCollection;
            }
          }
          if (!this.dynamicProperties.length) {
            this._mdf = false;
          }
        };
        function floatEqual(a5, b3) {
          return Math.abs(a5 - b3) * 1e5 <= Math.min(Math.abs(a5), Math.abs(b3));
        }
        function floatZero(f3) {
          return Math.abs(f3) <= 1e-5;
        }
        function lerp(p0, p1, amount) {
          return p0 * (1 - amount) + p1 * amount;
        }
        function lerpPoint(p0, p1, amount) {
          return [lerp(p0[0], p1[0], amount), lerp(p0[1], p1[1], amount)];
        }
        function quadRoots(a5, b3, c4) {
          if (a5 === 0) return [];
          var s4 = b3 * b3 - 4 * a5 * c4;
          if (s4 < 0) return [];
          var singleRoot = -b3 / (2 * a5);
          if (s4 === 0) return [singleRoot];
          var delta = Math.sqrt(s4) / (2 * a5);
          return [singleRoot - delta, singleRoot + delta];
        }
        function polynomialCoefficients(p0, p1, p22, p3) {
          return [-p0 + 3 * p1 - 3 * p22 + p3, 3 * p0 - 6 * p1 + 3 * p22, -3 * p0 + 3 * p1, p0];
        }
        function singlePoint(p3) {
          return new PolynomialBezier(p3, p3, p3, p3, false);
        }
        function PolynomialBezier(p0, p1, p22, p3, linearize) {
          if (linearize && pointEqual(p0, p1)) {
            p1 = lerpPoint(p0, p3, 1 / 3);
          }
          if (linearize && pointEqual(p22, p3)) {
            p22 = lerpPoint(p0, p3, 2 / 3);
          }
          var coeffx = polynomialCoefficients(p0[0], p1[0], p22[0], p3[0]);
          var coeffy = polynomialCoefficients(p0[1], p1[1], p22[1], p3[1]);
          this.a = [coeffx[0], coeffy[0]];
          this.b = [coeffx[1], coeffy[1]];
          this.c = [coeffx[2], coeffy[2]];
          this.d = [coeffx[3], coeffy[3]];
          this.points = [p0, p1, p22, p3];
        }
        PolynomialBezier.prototype.point = function(t4) {
          return [((this.a[0] * t4 + this.b[0]) * t4 + this.c[0]) * t4 + this.d[0], ((this.a[1] * t4 + this.b[1]) * t4 + this.c[1]) * t4 + this.d[1]];
        };
        PolynomialBezier.prototype.derivative = function(t4) {
          return [(3 * t4 * this.a[0] + 2 * this.b[0]) * t4 + this.c[0], (3 * t4 * this.a[1] + 2 * this.b[1]) * t4 + this.c[1]];
        };
        PolynomialBezier.prototype.tangentAngle = function(t4) {
          var p3 = this.derivative(t4);
          return Math.atan2(p3[1], p3[0]);
        };
        PolynomialBezier.prototype.normalAngle = function(t4) {
          var p3 = this.derivative(t4);
          return Math.atan2(p3[0], p3[1]);
        };
        PolynomialBezier.prototype.inflectionPoints = function() {
          var denom = this.a[1] * this.b[0] - this.a[0] * this.b[1];
          if (floatZero(denom)) return [];
          var tcusp = -0.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / denom;
          var square = tcusp * tcusp - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / denom;
          if (square < 0) return [];
          var root = Math.sqrt(square);
          if (floatZero(root)) {
            if (root > 0 && root < 1) return [tcusp];
            return [];
          }
          return [tcusp - root, tcusp + root].filter(function(r6) {
            return r6 > 0 && r6 < 1;
          });
        };
        PolynomialBezier.prototype.split = function(t4) {
          if (t4 <= 0) return [singlePoint(this.points[0]), this];
          if (t4 >= 1) return [this, singlePoint(this.points[this.points.length - 1])];
          var p10 = lerpPoint(this.points[0], this.points[1], t4);
          var p11 = lerpPoint(this.points[1], this.points[2], t4);
          var p12 = lerpPoint(this.points[2], this.points[3], t4);
          var p20 = lerpPoint(p10, p11, t4);
          var p21 = lerpPoint(p11, p12, t4);
          var p3 = lerpPoint(p20, p21, t4);
          return [new PolynomialBezier(this.points[0], p10, p20, p3, true), new PolynomialBezier(p3, p21, p12, this.points[3], true)];
        };
        function extrema(bez2, comp2) {
          var min = bez2.points[0][comp2];
          var max = bez2.points[bez2.points.length - 1][comp2];
          if (min > max) {
            var e5 = max;
            max = min;
            min = e5;
          }
          var f3 = quadRoots(3 * bez2.a[comp2], 2 * bez2.b[comp2], bez2.c[comp2]);
          for (var i6 = 0; i6 < f3.length; i6 += 1) {
            if (f3[i6] > 0 && f3[i6] < 1) {
              var val2 = bez2.point(f3[i6])[comp2];
              if (val2 < min) min = val2;
              else if (val2 > max) max = val2;
            }
          }
          return {
            min,
            max
          };
        }
        PolynomialBezier.prototype.bounds = function() {
          return {
            x: extrema(this, 0),
            y: extrema(this, 1)
          };
        };
        PolynomialBezier.prototype.boundingBox = function() {
          var bounds = this.bounds();
          return {
            left: bounds.x.min,
            right: bounds.x.max,
            top: bounds.y.min,
            bottom: bounds.y.max,
            width: bounds.x.max - bounds.x.min,
            height: bounds.y.max - bounds.y.min,
            cx: (bounds.x.max + bounds.x.min) / 2,
            cy: (bounds.y.max + bounds.y.min) / 2
          };
        };
        function intersectData(bez2, t1, t22) {
          var box = bez2.boundingBox();
          return {
            cx: box.cx,
            cy: box.cy,
            width: box.width,
            height: box.height,
            bez: bez2,
            t: (t1 + t22) / 2,
            t1,
            t2: t22
          };
        }
        function splitData(data2) {
          var split = data2.bez.split(0.5);
          return [intersectData(split[0], data2.t1, data2.t), intersectData(split[1], data2.t, data2.t2)];
        }
        function boxIntersect(b1, b22) {
          return Math.abs(b1.cx - b22.cx) * 2 < b1.width + b22.width && Math.abs(b1.cy - b22.cy) * 2 < b1.height + b22.height;
        }
        function intersectsImpl(d1, d22, depth, tolerance, intersections, maxRecursion) {
          if (!boxIntersect(d1, d22)) return;
          if (depth >= maxRecursion || d1.width <= tolerance && d1.height <= tolerance && d22.width <= tolerance && d22.height <= tolerance) {
            intersections.push([d1.t, d22.t]);
            return;
          }
          var d1s = splitData(d1);
          var d2s = splitData(d22);
          intersectsImpl(d1s[0], d2s[0], depth + 1, tolerance, intersections, maxRecursion);
          intersectsImpl(d1s[0], d2s[1], depth + 1, tolerance, intersections, maxRecursion);
          intersectsImpl(d1s[1], d2s[0], depth + 1, tolerance, intersections, maxRecursion);
          intersectsImpl(d1s[1], d2s[1], depth + 1, tolerance, intersections, maxRecursion);
        }
        PolynomialBezier.prototype.intersections = function(other, tolerance, maxRecursion) {
          if (tolerance === void 0) tolerance = 2;
          if (maxRecursion === void 0) maxRecursion = 7;
          var intersections = [];
          intersectsImpl(intersectData(this, 0, 1), intersectData(other, 0, 1), 0, tolerance, intersections, maxRecursion);
          return intersections;
        };
        PolynomialBezier.shapeSegment = function(shapePath, index2) {
          var nextIndex = (index2 + 1) % shapePath.length();
          return new PolynomialBezier(shapePath.v[index2], shapePath.o[index2], shapePath.i[nextIndex], shapePath.v[nextIndex], true);
        };
        PolynomialBezier.shapeSegmentInverted = function(shapePath, index2) {
          var nextIndex = (index2 + 1) % shapePath.length();
          return new PolynomialBezier(shapePath.v[nextIndex], shapePath.i[nextIndex], shapePath.o[index2], shapePath.v[index2], true);
        };
        function crossProduct(a5, b3) {
          return [a5[1] * b3[2] - a5[2] * b3[1], a5[2] * b3[0] - a5[0] * b3[2], a5[0] * b3[1] - a5[1] * b3[0]];
        }
        function lineIntersection(start1, end1, start2, end2) {
          var v1 = [start1[0], start1[1], 1];
          var v2 = [end1[0], end1[1], 1];
          var v3 = [start2[0], start2[1], 1];
          var v4 = [end2[0], end2[1], 1];
          var r6 = crossProduct(crossProduct(v1, v2), crossProduct(v3, v4));
          if (floatZero(r6[2])) return null;
          return [r6[0] / r6[2], r6[1] / r6[2]];
        }
        function polarOffset(p3, angle, length2) {
          return [p3[0] + Math.cos(angle) * length2, p3[1] - Math.sin(angle) * length2];
        }
        function pointDistance(p1, p22) {
          return Math.hypot(p1[0] - p22[0], p1[1] - p22[1]);
        }
        function pointEqual(p1, p22) {
          return floatEqual(p1[0], p22[0]) && floatEqual(p1[1], p22[1]);
        }
        function ZigZagModifier() {
        }
        extendPrototype([ShapeModifier], ZigZagModifier);
        ZigZagModifier.prototype.initModifierProperties = function(elem2, data2) {
          this.getValue = this.processKeys;
          this.amplitude = PropertyFactory.getProp(elem2, data2.s, 0, null, this);
          this.frequency = PropertyFactory.getProp(elem2, data2.r, 0, null, this);
          this.pointsType = PropertyFactory.getProp(elem2, data2.pt, 0, null, this);
          this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0;
        };
        function setPoint(outputBezier, point, angle, direction, amplitude, outAmplitude, inAmplitude) {
          var angO = angle - Math.PI / 2;
          var angI = angle + Math.PI / 2;
          var px = point[0] + Math.cos(angle) * direction * amplitude;
          var py = point[1] - Math.sin(angle) * direction * amplitude;
          outputBezier.setTripleAt(px, py, px + Math.cos(angO) * outAmplitude, py - Math.sin(angO) * outAmplitude, px + Math.cos(angI) * inAmplitude, py - Math.sin(angI) * inAmplitude, outputBezier.length());
        }
        function getPerpendicularVector(pt1, pt2) {
          var vector = [pt2[0] - pt1[0], pt2[1] - pt1[1]];
          var rot = -Math.PI * 0.5;
          var rotatedVector = [Math.cos(rot) * vector[0] - Math.sin(rot) * vector[1], Math.sin(rot) * vector[0] + Math.cos(rot) * vector[1]];
          return rotatedVector;
        }
        function getProjectingAngle(path, cur) {
          var prevIndex = cur === 0 ? path.length() - 1 : cur - 1;
          var nextIndex = (cur + 1) % path.length();
          var prevPoint = path.v[prevIndex];
          var nextPoint = path.v[nextIndex];
          var pVector = getPerpendicularVector(prevPoint, nextPoint);
          return Math.atan2(0, 1) - Math.atan2(pVector[1], pVector[0]);
        }
        function zigZagCorner(outputBezier, path, cur, amplitude, frequency, pointType, direction) {
          var angle = getProjectingAngle(path, cur);
          var point = path.v[cur % path._length];
          var prevPoint = path.v[cur === 0 ? path._length - 1 : cur - 1];
          var nextPoint = path.v[(cur + 1) % path._length];
          var prevDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - prevPoint[0], 2) + Math.pow(point[1] - prevPoint[1], 2)) : 0;
          var nextDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - nextPoint[0], 2) + Math.pow(point[1] - nextPoint[1], 2)) : 0;
          setPoint(outputBezier, path.v[cur % path._length], angle, direction, amplitude, nextDist / ((frequency + 1) * 2), prevDist / ((frequency + 1) * 2), pointType);
        }
        function zigZagSegment(outputBezier, segment, amplitude, frequency, pointType, direction) {
          for (var i6 = 0; i6 < frequency; i6 += 1) {
            var t4 = (i6 + 1) / (frequency + 1);
            var dist = pointType === 2 ? Math.sqrt(Math.pow(segment.points[3][0] - segment.points[0][0], 2) + Math.pow(segment.points[3][1] - segment.points[0][1], 2)) : 0;
            var angle = segment.normalAngle(t4);
            var point = segment.point(t4);
            setPoint(outputBezier, point, angle, direction, amplitude, dist / ((frequency + 1) * 2), dist / ((frequency + 1) * 2), pointType);
            direction = -direction;
          }
          return direction;
        }
        ZigZagModifier.prototype.processPath = function(path, amplitude, frequency, pointType) {
          var count = path._length;
          var clonedPath = shapePool.newElement();
          clonedPath.c = path.c;
          if (!path.c) {
            count -= 1;
          }
          if (count === 0) return clonedPath;
          var direction = -1;
          var segment = PolynomialBezier.shapeSegment(path, 0);
          zigZagCorner(clonedPath, path, 0, amplitude, frequency, pointType, direction);
          for (var i6 = 0; i6 < count; i6 += 1) {
            direction = zigZagSegment(clonedPath, segment, amplitude, frequency, pointType, -direction);
            if (i6 === count - 1 && !path.c) {
              segment = null;
            } else {
              segment = PolynomialBezier.shapeSegment(path, (i6 + 1) % count);
            }
            zigZagCorner(clonedPath, path, i6 + 1, amplitude, frequency, pointType, direction);
          }
          return clonedPath;
        };
        ZigZagModifier.prototype.processShapes = function(_isFirstFrame) {
          var shapePaths;
          var i6;
          var len = this.shapes.length;
          var j3;
          var jLen;
          var amplitude = this.amplitude.v;
          var frequency = Math.max(0, Math.round(this.frequency.v));
          var pointType = this.pointsType.v;
          if (amplitude !== 0) {
            var shapeData;
            var localShapeCollection;
            for (i6 = 0; i6 < len; i6 += 1) {
              shapeData = this.shapes[i6];
              localShapeCollection = shapeData.localShapeCollection;
              if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
                localShapeCollection.releaseShapes();
                shapeData.shape._mdf = true;
                shapePaths = shapeData.shape.paths.shapes;
                jLen = shapeData.shape.paths._length;
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  localShapeCollection.addShape(this.processPath(shapePaths[j3], amplitude, frequency, pointType));
                }
              }
              shapeData.shape.paths = shapeData.localShapeCollection;
            }
          }
          if (!this.dynamicProperties.length) {
            this._mdf = false;
          }
        };
        function linearOffset(p1, p22, amount) {
          var angle = Math.atan2(p22[0] - p1[0], p22[1] - p1[1]);
          return [polarOffset(p1, angle, amount), polarOffset(p22, angle, amount)];
        }
        function offsetSegment(segment, amount) {
          var p0;
          var p1a;
          var p1b;
          var p2b;
          var p2a;
          var p3;
          var e5;
          e5 = linearOffset(segment.points[0], segment.points[1], amount);
          p0 = e5[0];
          p1a = e5[1];
          e5 = linearOffset(segment.points[1], segment.points[2], amount);
          p1b = e5[0];
          p2b = e5[1];
          e5 = linearOffset(segment.points[2], segment.points[3], amount);
          p2a = e5[0];
          p3 = e5[1];
          var p1 = lineIntersection(p0, p1a, p1b, p2b);
          if (p1 === null) p1 = p1a;
          var p22 = lineIntersection(p2a, p3, p1b, p2b);
          if (p22 === null) p22 = p2a;
          return new PolynomialBezier(p0, p1, p22, p3);
        }
        function joinLines(outputBezier, seg1, seg2, lineJoin, miterLimit) {
          var p0 = seg1.points[3];
          var p1 = seg2.points[0];
          if (lineJoin === 3) return p0;
          if (pointEqual(p0, p1)) return p0;
          if (lineJoin === 2) {
            var angleOut = -seg1.tangentAngle(1);
            var angleIn = -seg2.tangentAngle(0) + Math.PI;
            var center = lineIntersection(p0, polarOffset(p0, angleOut + Math.PI / 2, 100), p1, polarOffset(p1, angleOut + Math.PI / 2, 100));
            var radius = center ? pointDistance(center, p0) : pointDistance(p0, p1) / 2;
            var tan = polarOffset(p0, angleOut, 2 * radius * roundCorner);
            outputBezier.setXYAt(tan[0], tan[1], "o", outputBezier.length() - 1);
            tan = polarOffset(p1, angleIn, 2 * radius * roundCorner);
            outputBezier.setTripleAt(p1[0], p1[1], p1[0], p1[1], tan[0], tan[1], outputBezier.length());
            return p1;
          }
          var t0 = pointEqual(p0, seg1.points[2]) ? seg1.points[0] : seg1.points[2];
          var t1 = pointEqual(p1, seg2.points[1]) ? seg2.points[3] : seg2.points[1];
          var intersection = lineIntersection(t0, p0, p1, t1);
          if (intersection && pointDistance(intersection, p0) < miterLimit) {
            outputBezier.setTripleAt(intersection[0], intersection[1], intersection[0], intersection[1], intersection[0], intersection[1], outputBezier.length());
            return intersection;
          }
          return p0;
        }
        function getIntersection(a5, b3) {
          var intersect = a5.intersections(b3);
          if (intersect.length && floatEqual(intersect[0][0], 1)) intersect.shift();
          if (intersect.length) return intersect[0];
          return null;
        }
        function pruneSegmentIntersection(a5, b3) {
          var outa = a5.slice();
          var outb = b3.slice();
          var intersect = getIntersection(a5[a5.length - 1], b3[0]);
          if (intersect) {
            outa[a5.length - 1] = a5[a5.length - 1].split(intersect[0])[0];
            outb[0] = b3[0].split(intersect[1])[1];
          }
          if (a5.length > 1 && b3.length > 1) {
            intersect = getIntersection(a5[0], b3[b3.length - 1]);
            if (intersect) {
              return [[a5[0].split(intersect[0])[0]], [b3[b3.length - 1].split(intersect[1])[1]]];
            }
          }
          return [outa, outb];
        }
        function pruneIntersections(segments) {
          var e5;
          for (var i6 = 1; i6 < segments.length; i6 += 1) {
            e5 = pruneSegmentIntersection(segments[i6 - 1], segments[i6]);
            segments[i6 - 1] = e5[0];
            segments[i6] = e5[1];
          }
          if (segments.length > 1) {
            e5 = pruneSegmentIntersection(segments[segments.length - 1], segments[0]);
            segments[segments.length - 1] = e5[0];
            segments[0] = e5[1];
          }
          return segments;
        }
        function offsetSegmentSplit(segment, amount) {
          var flex = segment.inflectionPoints();
          var left;
          var right;
          var split;
          var mid;
          if (flex.length === 0) {
            return [offsetSegment(segment, amount)];
          }
          if (flex.length === 1 || floatEqual(flex[1], 1)) {
            split = segment.split(flex[0]);
            left = split[0];
            right = split[1];
            return [offsetSegment(left, amount), offsetSegment(right, amount)];
          }
          split = segment.split(flex[0]);
          left = split[0];
          var t4 = (flex[1] - flex[0]) / (1 - flex[0]);
          split = split[1].split(t4);
          mid = split[0];
          right = split[1];
          return [offsetSegment(left, amount), offsetSegment(mid, amount), offsetSegment(right, amount)];
        }
        function OffsetPathModifier() {
        }
        extendPrototype([ShapeModifier], OffsetPathModifier);
        OffsetPathModifier.prototype.initModifierProperties = function(elem2, data2) {
          this.getValue = this.processKeys;
          this.amount = PropertyFactory.getProp(elem2, data2.a, 0, null, this);
          this.miterLimit = PropertyFactory.getProp(elem2, data2.ml, 0, null, this);
          this.lineJoin = data2.lj;
          this._isAnimated = this.amount.effectsSequence.length !== 0;
        };
        OffsetPathModifier.prototype.processPath = function(inputBezier, amount, lineJoin, miterLimit) {
          var outputBezier = shapePool.newElement();
          outputBezier.c = inputBezier.c;
          var count = inputBezier.length();
          if (!inputBezier.c) {
            count -= 1;
          }
          var i6;
          var j3;
          var segment;
          var multiSegments = [];
          for (i6 = 0; i6 < count; i6 += 1) {
            segment = PolynomialBezier.shapeSegment(inputBezier, i6);
            multiSegments.push(offsetSegmentSplit(segment, amount));
          }
          if (!inputBezier.c) {
            for (i6 = count - 1; i6 >= 0; i6 -= 1) {
              segment = PolynomialBezier.shapeSegmentInverted(inputBezier, i6);
              multiSegments.push(offsetSegmentSplit(segment, amount));
            }
          }
          multiSegments = pruneIntersections(multiSegments);
          var lastPoint = null;
          var lastSeg = null;
          for (i6 = 0; i6 < multiSegments.length; i6 += 1) {
            var multiSegment = multiSegments[i6];
            if (lastSeg) lastPoint = joinLines(outputBezier, lastSeg, multiSegment[0], lineJoin, miterLimit);
            lastSeg = multiSegment[multiSegment.length - 1];
            for (j3 = 0; j3 < multiSegment.length; j3 += 1) {
              segment = multiSegment[j3];
              if (lastPoint && pointEqual(segment.points[0], lastPoint)) {
                outputBezier.setXYAt(segment.points[1][0], segment.points[1][1], "o", outputBezier.length() - 1);
              } else {
                outputBezier.setTripleAt(segment.points[0][0], segment.points[0][1], segment.points[1][0], segment.points[1][1], segment.points[0][0], segment.points[0][1], outputBezier.length());
              }
              outputBezier.setTripleAt(segment.points[3][0], segment.points[3][1], segment.points[3][0], segment.points[3][1], segment.points[2][0], segment.points[2][1], outputBezier.length());
              lastPoint = segment.points[3];
            }
          }
          if (multiSegments.length) joinLines(outputBezier, lastSeg, multiSegments[0][0], lineJoin, miterLimit);
          return outputBezier;
        };
        OffsetPathModifier.prototype.processShapes = function(_isFirstFrame) {
          var shapePaths;
          var i6;
          var len = this.shapes.length;
          var j3;
          var jLen;
          var amount = this.amount.v;
          var miterLimit = this.miterLimit.v;
          var lineJoin = this.lineJoin;
          if (amount !== 0) {
            var shapeData;
            var localShapeCollection;
            for (i6 = 0; i6 < len; i6 += 1) {
              shapeData = this.shapes[i6];
              localShapeCollection = shapeData.localShapeCollection;
              if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
                localShapeCollection.releaseShapes();
                shapeData.shape._mdf = true;
                shapePaths = shapeData.shape.paths.shapes;
                jLen = shapeData.shape.paths._length;
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  localShapeCollection.addShape(this.processPath(shapePaths[j3], amount, lineJoin, miterLimit));
                }
              }
              shapeData.shape.paths = shapeData.localShapeCollection;
            }
          }
          if (!this.dynamicProperties.length) {
            this._mdf = false;
          }
        };
        function getFontProperties(fontData) {
          var styles = fontData.fStyle ? fontData.fStyle.split(" ") : [];
          var fWeight = "normal";
          var fStyle = "normal";
          var len = styles.length;
          var styleName;
          for (var i6 = 0; i6 < len; i6 += 1) {
            styleName = styles[i6].toLowerCase();
            switch (styleName) {
              case "italic":
                fStyle = "italic";
                break;
              case "bold":
                fWeight = "700";
                break;
              case "black":
                fWeight = "900";
                break;
              case "medium":
                fWeight = "500";
                break;
              case "regular":
              case "normal":
                fWeight = "400";
                break;
              case "light":
              case "thin":
                fWeight = "200";
                break;
              default:
                break;
            }
          }
          return {
            style: fStyle,
            weight: fontData.fWeight || fWeight
          };
        }
        var FontManager = function() {
          var maxWaitingTime = 5e3;
          var emptyChar = {
            w: 0,
            size: 0,
            shapes: [],
            data: {
              shapes: []
            }
          };
          var combinedCharacters = [];
          combinedCharacters = combinedCharacters.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
          var BLACK_FLAG_CODE_POINT = 127988;
          var CANCEL_TAG_CODE_POINT = 917631;
          var A_TAG_CODE_POINT = 917601;
          var Z_TAG_CODE_POINT = 917626;
          var VARIATION_SELECTOR_16_CODE_POINT = 65039;
          var ZERO_WIDTH_JOINER_CODE_POINT = 8205;
          var REGIONAL_CHARACTER_A_CODE_POINT = 127462;
          var REGIONAL_CHARACTER_Z_CODE_POINT = 127487;
          var surrogateModifiers = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"];
          function trimFontOptions(font) {
            var familyArray = font.split(",");
            var i6;
            var len = familyArray.length;
            var enabledFamilies = [];
            for (i6 = 0; i6 < len; i6 += 1) {
              if (familyArray[i6] !== "sans-serif" && familyArray[i6] !== "monospace") {
                enabledFamilies.push(familyArray[i6]);
              }
            }
            return enabledFamilies.join(",");
          }
          function setUpNode(font, family) {
            var parentNode = createTag("span");
            parentNode.setAttribute("aria-hidden", true);
            parentNode.style.fontFamily = family;
            var node = createTag("span");
            node.innerText = "giItT1WQy@!-/#";
            parentNode.style.position = "absolute";
            parentNode.style.left = "-10000px";
            parentNode.style.top = "-10000px";
            parentNode.style.fontSize = "300px";
            parentNode.style.fontVariant = "normal";
            parentNode.style.fontStyle = "normal";
            parentNode.style.fontWeight = "normal";
            parentNode.style.letterSpacing = "0";
            parentNode.appendChild(node);
            document.body.appendChild(parentNode);
            var width2 = node.offsetWidth;
            node.style.fontFamily = trimFontOptions(font) + ", " + family;
            return {
              node,
              w: width2,
              parent: parentNode
            };
          }
          function checkLoadedFonts() {
            var i6;
            var len = this.fonts.length;
            var node;
            var w3;
            var loadedCount = len;
            for (i6 = 0; i6 < len; i6 += 1) {
              if (this.fonts[i6].loaded) {
                loadedCount -= 1;
              } else if (this.fonts[i6].fOrigin === "n" || this.fonts[i6].origin === 0) {
                this.fonts[i6].loaded = true;
              } else {
                node = this.fonts[i6].monoCase.node;
                w3 = this.fonts[i6].monoCase.w;
                if (node.offsetWidth !== w3) {
                  loadedCount -= 1;
                  this.fonts[i6].loaded = true;
                } else {
                  node = this.fonts[i6].sansCase.node;
                  w3 = this.fonts[i6].sansCase.w;
                  if (node.offsetWidth !== w3) {
                    loadedCount -= 1;
                    this.fonts[i6].loaded = true;
                  }
                }
                if (this.fonts[i6].loaded) {
                  this.fonts[i6].sansCase.parent.parentNode.removeChild(this.fonts[i6].sansCase.parent);
                  this.fonts[i6].monoCase.parent.parentNode.removeChild(this.fonts[i6].monoCase.parent);
                }
              }
            }
            if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {
              setTimeout(this.checkLoadedFontsBinded, 20);
            } else {
              setTimeout(this.setIsLoadedBinded, 10);
            }
          }
          function createHelper(fontData, def) {
            var engine = document.body && def ? "svg" : "canvas";
            var helper;
            var fontProps = getFontProperties(fontData);
            if (engine === "svg") {
              var tHelper = createNS("text");
              tHelper.style.fontSize = "100px";
              tHelper.setAttribute("font-family", fontData.fFamily);
              tHelper.setAttribute("font-style", fontProps.style);
              tHelper.setAttribute("font-weight", fontProps.weight);
              tHelper.textContent = "1";
              if (fontData.fClass) {
                tHelper.style.fontFamily = "inherit";
                tHelper.setAttribute("class", fontData.fClass);
              } else {
                tHelper.style.fontFamily = fontData.fFamily;
              }
              def.appendChild(tHelper);
              helper = tHelper;
            } else {
              var tCanvasHelper = new OffscreenCanvas(500, 500).getContext("2d");
              tCanvasHelper.font = fontProps.style + " " + fontProps.weight + " 100px " + fontData.fFamily;
              helper = tCanvasHelper;
            }
            function measure(text2) {
              if (engine === "svg") {
                helper.textContent = text2;
                return helper.getComputedTextLength();
              }
              return helper.measureText(text2).width;
            }
            return {
              measureText: measure
            };
          }
          function addFonts(fontData, defs) {
            if (!fontData) {
              this.isLoaded = true;
              return;
            }
            if (this.chars) {
              this.isLoaded = true;
              this.fonts = fontData.list;
              return;
            }
            if (!document.body) {
              this.isLoaded = true;
              fontData.list.forEach(function(data2) {
                data2.helper = createHelper(data2);
                data2.cache = {};
              });
              this.fonts = fontData.list;
              return;
            }
            var fontArr = fontData.list;
            var i6;
            var len = fontArr.length;
            var _pendingFonts = len;
            for (i6 = 0; i6 < len; i6 += 1) {
              var shouldLoadFont = true;
              var loadedSelector;
              var j3;
              fontArr[i6].loaded = false;
              fontArr[i6].monoCase = setUpNode(fontArr[i6].fFamily, "monospace");
              fontArr[i6].sansCase = setUpNode(fontArr[i6].fFamily, "sans-serif");
              if (!fontArr[i6].fPath) {
                fontArr[i6].loaded = true;
                _pendingFonts -= 1;
              } else if (fontArr[i6].fOrigin === "p" || fontArr[i6].origin === 3) {
                loadedSelector = document.querySelectorAll('style[f-forigin="p"][f-family="' + fontArr[i6].fFamily + '"], style[f-origin="3"][f-family="' + fontArr[i6].fFamily + '"]');
                if (loadedSelector.length > 0) {
                  shouldLoadFont = false;
                }
                if (shouldLoadFont) {
                  var s4 = createTag("style");
                  s4.setAttribute("f-forigin", fontArr[i6].fOrigin);
                  s4.setAttribute("f-origin", fontArr[i6].origin);
                  s4.setAttribute("f-family", fontArr[i6].fFamily);
                  s4.type = "text/css";
                  s4.innerText = "@font-face {font-family: " + fontArr[i6].fFamily + "; font-style: normal; src: url('" + fontArr[i6].fPath + "');}";
                  defs.appendChild(s4);
                }
              } else if (fontArr[i6].fOrigin === "g" || fontArr[i6].origin === 1) {
                loadedSelector = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]');
                for (j3 = 0; j3 < loadedSelector.length; j3 += 1) {
                  if (loadedSelector[j3].href.indexOf(fontArr[i6].fPath) !== -1) {
                    shouldLoadFont = false;
                  }
                }
                if (shouldLoadFont) {
                  var l6 = createTag("link");
                  l6.setAttribute("f-forigin", fontArr[i6].fOrigin);
                  l6.setAttribute("f-origin", fontArr[i6].origin);
                  l6.type = "text/css";
                  l6.rel = "stylesheet";
                  l6.href = fontArr[i6].fPath;
                  document.body.appendChild(l6);
                }
              } else if (fontArr[i6].fOrigin === "t" || fontArr[i6].origin === 2) {
                loadedSelector = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]');
                for (j3 = 0; j3 < loadedSelector.length; j3 += 1) {
                  if (fontArr[i6].fPath === loadedSelector[j3].src) {
                    shouldLoadFont = false;
                  }
                }
                if (shouldLoadFont) {
                  var sc = createTag("link");
                  sc.setAttribute("f-forigin", fontArr[i6].fOrigin);
                  sc.setAttribute("f-origin", fontArr[i6].origin);
                  sc.setAttribute("rel", "stylesheet");
                  sc.setAttribute("href", fontArr[i6].fPath);
                  defs.appendChild(sc);
                }
              }
              fontArr[i6].helper = createHelper(fontArr[i6], defs);
              fontArr[i6].cache = {};
              this.fonts.push(fontArr[i6]);
            }
            if (_pendingFonts === 0) {
              this.isLoaded = true;
            } else {
              setTimeout(this.checkLoadedFonts.bind(this), 100);
            }
          }
          function addChars(chars) {
            if (!chars) {
              return;
            }
            if (!this.chars) {
              this.chars = [];
            }
            var i6;
            var len = chars.length;
            var j3;
            var jLen = this.chars.length;
            var found;
            for (i6 = 0; i6 < len; i6 += 1) {
              j3 = 0;
              found = false;
              while (j3 < jLen) {
                if (this.chars[j3].style === chars[i6].style && this.chars[j3].fFamily === chars[i6].fFamily && this.chars[j3].ch === chars[i6].ch) {
                  found = true;
                }
                j3 += 1;
              }
              if (!found) {
                this.chars.push(chars[i6]);
                jLen += 1;
              }
            }
          }
          function getCharData(_char, style, font) {
            var i6 = 0;
            var len = this.chars.length;
            while (i6 < len) {
              if (this.chars[i6].ch === _char && this.chars[i6].style === style && this.chars[i6].fFamily === font) {
                return this.chars[i6];
              }
              i6 += 1;
            }
            if ((typeof _char === "string" && _char.charCodeAt(0) !== 13 || !_char) && console && console.warn && !this._warned) {
              this._warned = true;
              console.warn("Missing character from exported characters list: ", _char, style, font);
            }
            return emptyChar;
          }
          function measureText(_char2, fontName, size) {
            var fontData = this.getFontByName(fontName);
            var index2 = _char2;
            if (!fontData.cache[index2]) {
              var tHelper = fontData.helper;
              if (_char2 === " ") {
                var doubleSize = tHelper.measureText("|" + _char2 + "|");
                var singleSize = tHelper.measureText("||");
                fontData.cache[index2] = (doubleSize - singleSize) / 100;
              } else {
                fontData.cache[index2] = tHelper.measureText(_char2) / 100;
              }
            }
            return fontData.cache[index2] * size;
          }
          function getFontByName(name2) {
            var i6 = 0;
            var len = this.fonts.length;
            while (i6 < len) {
              if (this.fonts[i6].fName === name2) {
                return this.fonts[i6];
              }
              i6 += 1;
            }
            return this.fonts[0];
          }
          function getCodePoint(string) {
            var codePoint = 0;
            var first = string.charCodeAt(0);
            if (first >= 55296 && first <= 56319) {
              var second = string.charCodeAt(1);
              if (second >= 56320 && second <= 57343) {
                codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
              }
            }
            return codePoint;
          }
          function isModifier(firstCharCode, secondCharCode) {
            var sum2 = firstCharCode.toString(16) + secondCharCode.toString(16);
            return surrogateModifiers.indexOf(sum2) !== -1;
          }
          function isZeroWidthJoiner(charCode) {
            return charCode === ZERO_WIDTH_JOINER_CODE_POINT;
          }
          function isVariationSelector(charCode) {
            return charCode === VARIATION_SELECTOR_16_CODE_POINT;
          }
          function isRegionalCode(string) {
            var codePoint = getCodePoint(string);
            if (codePoint >= REGIONAL_CHARACTER_A_CODE_POINT && codePoint <= REGIONAL_CHARACTER_Z_CODE_POINT) {
              return true;
            }
            return false;
          }
          function isFlagEmoji(string) {
            return isRegionalCode(string.substr(0, 2)) && isRegionalCode(string.substr(2, 2));
          }
          function isCombinedCharacter(_char3) {
            return combinedCharacters.indexOf(_char3) !== -1;
          }
          function isRegionalFlag(text2, index2) {
            var codePoint = getCodePoint(text2.substr(index2, 2));
            if (codePoint !== BLACK_FLAG_CODE_POINT) {
              return false;
            }
            var count = 0;
            index2 += 2;
            while (count < 5) {
              codePoint = getCodePoint(text2.substr(index2, 2));
              if (codePoint < A_TAG_CODE_POINT || codePoint > Z_TAG_CODE_POINT) {
                return false;
              }
              count += 1;
              index2 += 2;
            }
            return getCodePoint(text2.substr(index2, 2)) === CANCEL_TAG_CODE_POINT;
          }
          function setIsLoaded() {
            this.isLoaded = true;
          }
          var Font = function Font2() {
            this.fonts = [];
            this.chars = null;
            this.typekitLoaded = 0;
            this.isLoaded = false;
            this._warned = false;
            this.initTime = Date.now();
            this.setIsLoadedBinded = this.setIsLoaded.bind(this);
            this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
          };
          Font.isModifier = isModifier;
          Font.isZeroWidthJoiner = isZeroWidthJoiner;
          Font.isFlagEmoji = isFlagEmoji;
          Font.isRegionalCode = isRegionalCode;
          Font.isCombinedCharacter = isCombinedCharacter;
          Font.isRegionalFlag = isRegionalFlag;
          Font.isVariationSelector = isVariationSelector;
          Font.BLACK_FLAG_CODE_POINT = BLACK_FLAG_CODE_POINT;
          var fontPrototype = {
            addChars,
            addFonts,
            getCharData,
            getFontByName,
            measureText,
            checkLoadedFonts,
            setIsLoaded
          };
          Font.prototype = fontPrototype;
          return Font;
        }();
        function SlotManager(animationData2) {
          this.animationData = animationData2;
        }
        SlotManager.prototype.getProp = function(data2) {
          if (this.animationData.slots && this.animationData.slots[data2.sid]) {
            return Object.assign(data2, this.animationData.slots[data2.sid].p);
          }
          return data2;
        };
        function slotFactory(animationData2) {
          return new SlotManager(animationData2);
        }
        function RenderableElement() {
        }
        RenderableElement.prototype = {
          initRenderable: function initRenderable() {
            this.isInRange = false;
            this.hidden = false;
            this.isTransparent = false;
            this.renderableComponents = [];
          },
          addRenderableComponent: function addRenderableComponent(component) {
            if (this.renderableComponents.indexOf(component) === -1) {
              this.renderableComponents.push(component);
            }
          },
          removeRenderableComponent: function removeRenderableComponent(component) {
            if (this.renderableComponents.indexOf(component) !== -1) {
              this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);
            }
          },
          prepareRenderableFrame: function prepareRenderableFrame(num) {
            this.checkLayerLimits(num);
          },
          checkTransparency: function checkTransparency() {
            if (this.finalTransform.mProp.o.v <= 0) {
              if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {
                this.isTransparent = true;
                this.hide();
              }
            } else if (this.isTransparent) {
              this.isTransparent = false;
              this.show();
            }
          },
          /**
             * @function
             * Initializes frame related properties.
             *
             * @param {number} num
             * current frame number in Layer's time
             *
             */
          checkLayerLimits: function checkLayerLimits(num) {
            if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {
              if (this.isInRange !== true) {
                this.globalData._mdf = true;
                this._mdf = true;
                this.isInRange = true;
                this.show();
              }
            } else if (this.isInRange !== false) {
              this.globalData._mdf = true;
              this.isInRange = false;
              this.hide();
            }
          },
          renderRenderable: function renderRenderable() {
            var i6;
            var len = this.renderableComponents.length;
            for (i6 = 0; i6 < len; i6 += 1) {
              this.renderableComponents[i6].renderFrame(this._isFirstFrame);
            }
          },
          sourceRectAtTime: function sourceRectAtTime2() {
            return {
              top: 0,
              left: 0,
              width: 100,
              height: 100
            };
          },
          getLayerSize: function getLayerSize() {
            if (this.data.ty === 5) {
              return {
                w: this.data.textData.width,
                h: this.data.textData.height
              };
            }
            return {
              w: this.data.width,
              h: this.data.height
            };
          }
        };
        var getBlendMode = /* @__PURE__ */ function() {
          var blendModeEnums = {
            0: "source-over",
            1: "multiply",
            2: "screen",
            3: "overlay",
            4: "darken",
            5: "lighten",
            6: "color-dodge",
            7: "color-burn",
            8: "hard-light",
            9: "soft-light",
            10: "difference",
            11: "exclusion",
            12: "hue",
            13: "saturation",
            14: "color",
            15: "luminosity"
          };
          return function(mode) {
            return blendModeEnums[mode] || "";
          };
        }();
        function SliderEffect(data2, elem2, container) {
          this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
        }
        function AngleEffect(data2, elem2, container) {
          this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
        }
        function ColorEffect(data2, elem2, container) {
          this.p = PropertyFactory.getProp(elem2, data2.v, 1, 0, container);
        }
        function PointEffect(data2, elem2, container) {
          this.p = PropertyFactory.getProp(elem2, data2.v, 1, 0, container);
        }
        function LayerIndexEffect(data2, elem2, container) {
          this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
        }
        function MaskIndexEffect(data2, elem2, container) {
          this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
        }
        function CheckboxEffect(data2, elem2, container) {
          this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
        }
        function NoValueEffect() {
          this.p = {};
        }
        function EffectsManager(data2, element) {
          var effects = data2.ef || [];
          this.effectElements = [];
          var i6;
          var len = effects.length;
          var effectItem;
          for (i6 = 0; i6 < len; i6 += 1) {
            effectItem = new GroupEffect(effects[i6], element);
            this.effectElements.push(effectItem);
          }
        }
        function GroupEffect(data2, element) {
          this.init(data2, element);
        }
        extendPrototype([DynamicPropertyContainer], GroupEffect);
        GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;
        GroupEffect.prototype.init = function(data2, element) {
          this.data = data2;
          this.effectElements = [];
          this.initDynamicPropertyContainer(element);
          var i6;
          var len = this.data.ef.length;
          var eff;
          var effects = this.data.ef;
          for (i6 = 0; i6 < len; i6 += 1) {
            eff = null;
            switch (effects[i6].ty) {
              case 0:
                eff = new SliderEffect(effects[i6], element, this);
                break;
              case 1:
                eff = new AngleEffect(effects[i6], element, this);
                break;
              case 2:
                eff = new ColorEffect(effects[i6], element, this);
                break;
              case 3:
                eff = new PointEffect(effects[i6], element, this);
                break;
              case 4:
              case 7:
                eff = new CheckboxEffect(effects[i6], element, this);
                break;
              case 10:
                eff = new LayerIndexEffect(effects[i6], element, this);
                break;
              case 11:
                eff = new MaskIndexEffect(effects[i6], element, this);
                break;
              case 5:
                eff = new EffectsManager(effects[i6], element, this);
                break;
              // case 6:
              default:
                eff = new NoValueEffect(effects[i6], element, this);
                break;
            }
            if (eff) {
              this.effectElements.push(eff);
            }
          }
        };
        function BaseElement() {
        }
        BaseElement.prototype = {
          checkMasks: function checkMasks() {
            if (!this.data.hasMask) {
              return false;
            }
            var i6 = 0;
            var len = this.data.masksProperties.length;
            while (i6 < len) {
              if (this.data.masksProperties[i6].mode !== "n" && this.data.masksProperties[i6].cl !== false) {
                return true;
              }
              i6 += 1;
            }
            return false;
          },
          initExpressions: function initExpressions() {
            var expressionsInterfaces2 = getExpressionInterfaces();
            if (!expressionsInterfaces2) {
              return;
            }
            var LayerExpressionInterface2 = expressionsInterfaces2("layer");
            var EffectsExpressionInterface2 = expressionsInterfaces2("effects");
            var ShapeExpressionInterface2 = expressionsInterfaces2("shape");
            var TextExpressionInterface2 = expressionsInterfaces2("text");
            var CompExpressionInterface2 = expressionsInterfaces2("comp");
            this.layerInterface = LayerExpressionInterface2(this);
            if (this.data.hasMask && this.maskManager) {
              this.layerInterface.registerMaskInterface(this.maskManager);
            }
            var effectsInterface = EffectsExpressionInterface2.createEffectsInterface(this, this.layerInterface);
            this.layerInterface.registerEffectsInterface(effectsInterface);
            if (this.data.ty === 0 || this.data.xt) {
              this.compInterface = CompExpressionInterface2(this);
            } else if (this.data.ty === 4) {
              this.layerInterface.shapeInterface = ShapeExpressionInterface2(this.shapesData, this.itemsData, this.layerInterface);
              this.layerInterface.content = this.layerInterface.shapeInterface;
            } else if (this.data.ty === 5) {
              this.layerInterface.textInterface = TextExpressionInterface2(this);
              this.layerInterface.text = this.layerInterface.textInterface;
            }
          },
          setBlendMode: function setBlendMode() {
            var blendModeValue = getBlendMode(this.data.bm);
            var elem2 = this.baseElement || this.layerElement;
            elem2.style["mix-blend-mode"] = blendModeValue;
          },
          initBaseData: function initBaseData(data2, globalData2, comp2) {
            this.globalData = globalData2;
            this.comp = comp2;
            this.data = data2;
            this.layerId = createElementID();
            if (!this.data.sr) {
              this.data.sr = 1;
            }
            this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);
          },
          getType: function getType() {
            return this.type;
          },
          sourceRectAtTime: function sourceRectAtTime2() {
          }
        };
        function FrameElement() {
        }
        FrameElement.prototype = {
          /**
             * @function
             * Initializes frame related properties.
             *
             */
          initFrame: function initFrame2() {
            this._isFirstFrame = false;
            this.dynamicProperties = [];
            this._mdf = false;
          },
          /**
             * @function
             * Calculates all dynamic values
             *
             * @param {number} num
             * current frame number in Layer's time
             * @param {boolean} isVisible
             * if layers is currently in range
             *
             */
          prepareProperties: function prepareProperties(num, isVisible) {
            var i6;
            var len = this.dynamicProperties.length;
            for (i6 = 0; i6 < len; i6 += 1) {
              if (isVisible || this._isParent && this.dynamicProperties[i6].propType === "transform") {
                this.dynamicProperties[i6].getValue();
                if (this.dynamicProperties[i6]._mdf) {
                  this.globalData._mdf = true;
                  this._mdf = true;
                }
              }
            }
          },
          addDynamicProperty: function addDynamicProperty(prop) {
            if (this.dynamicProperties.indexOf(prop) === -1) {
              this.dynamicProperties.push(prop);
            }
          }
        };
        function FootageElement(data2, globalData2, comp2) {
          this.initFrame();
          this.initRenderable();
          this.assetData = globalData2.getAssetData(data2.refId);
          this.footageData = globalData2.imageLoader.getAsset(this.assetData);
          this.initBaseData(data2, globalData2, comp2);
        }
        FootageElement.prototype.prepareFrame = function() {
        };
        extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement);
        FootageElement.prototype.getBaseElement = function() {
          return null;
        };
        FootageElement.prototype.renderFrame = function() {
        };
        FootageElement.prototype.destroy = function() {
        };
        FootageElement.prototype.initExpressions = function() {
          var expressionsInterfaces2 = getExpressionInterfaces();
          if (!expressionsInterfaces2) {
            return;
          }
          var FootageInterface2 = expressionsInterfaces2("footage");
          this.layerInterface = FootageInterface2(this);
        };
        FootageElement.prototype.getFootageData = function() {
          return this.footageData;
        };
        function AudioElement(data2, globalData2, comp2) {
          this.initFrame();
          this.initRenderable();
          this.assetData = globalData2.getAssetData(data2.refId);
          this.initBaseData(data2, globalData2, comp2);
          this._isPlaying = false;
          this._canPlay = false;
          var assetPath = this.globalData.getAssetsPath(this.assetData);
          this.audio = this.globalData.audioController.createAudio(assetPath);
          this._currentTime = 0;
          this.globalData.audioController.addAudio(this);
          this._volumeMultiplier = 1;
          this._volume = 1;
          this._previousVolume = null;
          this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
            _placeholder: true
          };
          this.lv = PropertyFactory.getProp(this, data2.au && data2.au.lv ? data2.au.lv : {
            k: [100]
          }, 1, 0.01, this);
        }
        AudioElement.prototype.prepareFrame = function(num) {
          this.prepareRenderableFrame(num, true);
          this.prepareProperties(num, true);
          if (!this.tm._placeholder) {
            var timeRemapped = this.tm.v;
            this._currentTime = timeRemapped;
          } else {
            this._currentTime = num / this.data.sr;
          }
          this._volume = this.lv.v[0];
          var totalVolume = this._volume * this._volumeMultiplier;
          if (this._previousVolume !== totalVolume) {
            this._previousVolume = totalVolume;
            this.audio.volume(totalVolume);
          }
        };
        extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement);
        AudioElement.prototype.renderFrame = function() {
          if (this.isInRange && this._canPlay) {
            if (!this._isPlaying) {
              this.audio.play();
              this.audio.seek(this._currentTime / this.globalData.frameRate);
              this._isPlaying = true;
            } else if (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1) {
              this.audio.seek(this._currentTime / this.globalData.frameRate);
            }
          }
        };
        AudioElement.prototype.show = function() {
        };
        AudioElement.prototype.hide = function() {
          this.audio.pause();
          this._isPlaying = false;
        };
        AudioElement.prototype.pause = function() {
          this.audio.pause();
          this._isPlaying = false;
          this._canPlay = false;
        };
        AudioElement.prototype.resume = function() {
          this._canPlay = true;
        };
        AudioElement.prototype.setRate = function(rateValue) {
          this.audio.rate(rateValue);
        };
        AudioElement.prototype.volume = function(volumeValue) {
          this._volumeMultiplier = volumeValue;
          this._previousVolume = volumeValue * this._volume;
          this.audio.volume(this._previousVolume);
        };
        AudioElement.prototype.getBaseElement = function() {
          return null;
        };
        AudioElement.prototype.destroy = function() {
        };
        AudioElement.prototype.sourceRectAtTime = function() {
        };
        AudioElement.prototype.initExpressions = function() {
        };
        function BaseRenderer() {
        }
        BaseRenderer.prototype.checkLayers = function(num) {
          var i6;
          var len = this.layers.length;
          var data2;
          this.completeLayers = true;
          for (i6 = len - 1; i6 >= 0; i6 -= 1) {
            if (!this.elements[i6]) {
              data2 = this.layers[i6];
              if (data2.ip - data2.st <= num - this.layers[i6].st && data2.op - data2.st > num - this.layers[i6].st) {
                this.buildItem(i6);
              }
            }
            this.completeLayers = this.elements[i6] ? this.completeLayers : false;
          }
          this.checkPendingElements();
        };
        BaseRenderer.prototype.createItem = function(layer) {
          switch (layer.ty) {
            case 2:
              return this.createImage(layer);
            case 0:
              return this.createComp(layer);
            case 1:
              return this.createSolid(layer);
            case 3:
              return this.createNull(layer);
            case 4:
              return this.createShape(layer);
            case 5:
              return this.createText(layer);
            case 6:
              return this.createAudio(layer);
            case 13:
              return this.createCamera(layer);
            case 15:
              return this.createFootage(layer);
            default:
              return this.createNull(layer);
          }
        };
        BaseRenderer.prototype.createCamera = function() {
          throw new Error("You're using a 3d camera. Try the html renderer.");
        };
        BaseRenderer.prototype.createAudio = function(data2) {
          return new AudioElement(data2, this.globalData, this);
        };
        BaseRenderer.prototype.createFootage = function(data2) {
          return new FootageElement(data2, this.globalData, this);
        };
        BaseRenderer.prototype.buildAllItems = function() {
          var i6;
          var len = this.layers.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            this.buildItem(i6);
          }
          this.checkPendingElements();
        };
        BaseRenderer.prototype.includeLayers = function(newLayers) {
          this.completeLayers = false;
          var i6;
          var len = newLayers.length;
          var j3;
          var jLen = this.layers.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            j3 = 0;
            while (j3 < jLen) {
              if (this.layers[j3].id === newLayers[i6].id) {
                this.layers[j3] = newLayers[i6];
                break;
              }
              j3 += 1;
            }
          }
        };
        BaseRenderer.prototype.setProjectInterface = function(pInterface) {
          this.globalData.projectInterface = pInterface;
        };
        BaseRenderer.prototype.initItems = function() {
          if (!this.globalData.progressiveLoad) {
            this.buildAllItems();
          }
        };
        BaseRenderer.prototype.buildElementParenting = function(element, parentName, hierarchy) {
          var elements = this.elements;
          var layers = this.layers;
          var i6 = 0;
          var len = layers.length;
          while (i6 < len) {
            if (layers[i6].ind == parentName) {
              if (!elements[i6] || elements[i6] === true) {
                this.buildItem(i6);
                this.addPendingElement(element);
              } else {
                hierarchy.push(elements[i6]);
                elements[i6].setAsParent();
                if (layers[i6].parent !== void 0) {
                  this.buildElementParenting(element, layers[i6].parent, hierarchy);
                } else {
                  element.setHierarchy(hierarchy);
                }
              }
            }
            i6 += 1;
          }
        };
        BaseRenderer.prototype.addPendingElement = function(element) {
          this.pendingElements.push(element);
        };
        BaseRenderer.prototype.searchExtraCompositions = function(assets) {
          var i6;
          var len = assets.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            if (assets[i6].xt) {
              var comp2 = this.createComp(assets[i6]);
              comp2.initExpressions();
              this.globalData.projectInterface.registerComposition(comp2);
            }
          }
        };
        BaseRenderer.prototype.getElementById = function(ind) {
          var i6;
          var len = this.elements.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            if (this.elements[i6].data.ind === ind) {
              return this.elements[i6];
            }
          }
          return null;
        };
        BaseRenderer.prototype.getElementByPath = function(path) {
          var pathValue = path.shift();
          var element;
          if (typeof pathValue === "number") {
            element = this.elements[pathValue];
          } else {
            var i6;
            var len = this.elements.length;
            for (i6 = 0; i6 < len; i6 += 1) {
              if (this.elements[i6].data.nm === pathValue) {
                element = this.elements[i6];
                break;
              }
            }
          }
          if (path.length === 0) {
            return element;
          }
          return element.getElementByPath(path);
        };
        BaseRenderer.prototype.setupGlobalData = function(animData, fontsContainer) {
          this.globalData.fontManager = new FontManager();
          this.globalData.slotManager = slotFactory(animData);
          this.globalData.fontManager.addChars(animData.chars);
          this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);
          this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
          this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
          this.globalData.imageLoader = this.animationItem.imagePreloader;
          this.globalData.audioController = this.animationItem.audioController;
          this.globalData.frameId = 0;
          this.globalData.frameRate = animData.fr;
          this.globalData.nm = animData.nm;
          this.globalData.compSize = {
            w: animData.w,
            h: animData.h
          };
        };
        var effectTypes = {
          TRANSFORM_EFFECT: "transformEFfect"
        };
        function TransformElement() {
        }
        TransformElement.prototype = {
          initTransform: function initTransform() {
            var mat = new Matrix();
            this.finalTransform = {
              mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
                o: 0
              },
              _matMdf: false,
              _localMatMdf: false,
              _opMdf: false,
              mat,
              localMat: mat,
              localOpacity: 1
            };
            if (this.data.ao) {
              this.finalTransform.mProp.autoOriented = true;
            }
            if (this.data.ty !== 11) {
            }
          },
          renderTransform: function renderTransform() {
            this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;
            this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;
            if (this.hierarchy) {
              var mat;
              var finalMat = this.finalTransform.mat;
              var i6 = 0;
              var len = this.hierarchy.length;
              if (!this.finalTransform._matMdf) {
                while (i6 < len) {
                  if (this.hierarchy[i6].finalTransform.mProp._mdf) {
                    this.finalTransform._matMdf = true;
                    break;
                  }
                  i6 += 1;
                }
              }
              if (this.finalTransform._matMdf) {
                mat = this.finalTransform.mProp.v.props;
                finalMat.cloneFromProps(mat);
                for (i6 = 0; i6 < len; i6 += 1) {
                  finalMat.multiply(this.hierarchy[i6].finalTransform.mProp.v);
                }
              }
            }
            if (this.finalTransform._matMdf) {
              this.finalTransform._localMatMdf = this.finalTransform._matMdf;
            }
            if (this.finalTransform._opMdf) {
              this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;
            }
          },
          renderLocalTransform: function renderLocalTransform() {
            if (this.localTransforms) {
              var i6 = 0;
              var len = this.localTransforms.length;
              this.finalTransform._localMatMdf = this.finalTransform._matMdf;
              if (!this.finalTransform._localMatMdf || !this.finalTransform._opMdf) {
                while (i6 < len) {
                  if (this.localTransforms[i6]._mdf) {
                    this.finalTransform._localMatMdf = true;
                  }
                  if (this.localTransforms[i6]._opMdf && !this.finalTransform._opMdf) {
                    this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;
                    this.finalTransform._opMdf = true;
                  }
                  i6 += 1;
                }
              }
              if (this.finalTransform._localMatMdf) {
                var localMat = this.finalTransform.localMat;
                this.localTransforms[0].matrix.clone(localMat);
                for (i6 = 1; i6 < len; i6 += 1) {
                  var lmat = this.localTransforms[i6].matrix;
                  localMat.multiply(lmat);
                }
                localMat.multiply(this.finalTransform.mat);
              }
              if (this.finalTransform._opMdf) {
                var localOp = this.finalTransform.localOpacity;
                for (i6 = 0; i6 < len; i6 += 1) {
                  localOp *= this.localTransforms[i6].opacity * 0.01;
                }
                this.finalTransform.localOpacity = localOp;
              }
            }
          },
          searchEffectTransforms: function searchEffectTransforms() {
            if (this.renderableEffectsManager) {
              var transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
              if (transformEffects.length) {
                this.localTransforms = [];
                this.finalTransform.localMat = new Matrix();
                var i6 = 0;
                var len = transformEffects.length;
                for (i6 = 0; i6 < len; i6 += 1) {
                  this.localTransforms.push(transformEffects[i6]);
                }
              }
            }
          },
          globalToLocal: function globalToLocal(pt) {
            var transforms = [];
            transforms.push(this.finalTransform);
            var flag = true;
            var comp2 = this.comp;
            while (flag) {
              if (comp2.finalTransform) {
                if (comp2.data.hasMask) {
                  transforms.splice(0, 0, comp2.finalTransform);
                }
                comp2 = comp2.comp;
              } else {
                flag = false;
              }
            }
            var i6;
            var len = transforms.length;
            var ptNew;
            for (i6 = 0; i6 < len; i6 += 1) {
              ptNew = transforms[i6].mat.applyToPointArray(0, 0, 0);
              pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];
            }
            return pt;
          },
          mHelper: new Matrix()
        };
        function MaskElement(data2, element, globalData2) {
          this.data = data2;
          this.element = element;
          this.globalData = globalData2;
          this.storedData = [];
          this.masksProperties = this.data.masksProperties || [];
          this.maskElement = null;
          var defs = this.globalData.defs;
          var i6;
          var len = this.masksProperties ? this.masksProperties.length : 0;
          this.viewData = createSizedArray(len);
          this.solidPath = "";
          var path;
          var properties = this.masksProperties;
          var count = 0;
          var currentMasks = [];
          var j3;
          var jLen;
          var layerId = createElementID();
          var rect;
          var expansor;
          var feMorph;
          var x3;
          var maskType = "clipPath";
          var maskRef = "clip-path";
          for (i6 = 0; i6 < len; i6 += 1) {
            if (properties[i6].mode !== "a" && properties[i6].mode !== "n" || properties[i6].inv || properties[i6].o.k !== 100 || properties[i6].o.x) {
              maskType = "mask";
              maskRef = "mask";
            }
            if ((properties[i6].mode === "s" || properties[i6].mode === "i") && count === 0) {
              rect = createNS("rect");
              rect.setAttribute("fill", "#ffffff");
              rect.setAttribute("width", this.element.comp.data.w || 0);
              rect.setAttribute("height", this.element.comp.data.h || 0);
              currentMasks.push(rect);
            } else {
              rect = null;
            }
            path = createNS("path");
            if (properties[i6].mode === "n") {
              this.viewData[i6] = {
                op: PropertyFactory.getProp(this.element, properties[i6].o, 0, 0.01, this.element),
                prop: ShapePropertyFactory.getShapeProp(this.element, properties[i6], 3),
                elem: path,
                lastPath: ""
              };
              defs.appendChild(path);
            } else {
              count += 1;
              path.setAttribute("fill", properties[i6].mode === "s" ? "#000000" : "#ffffff");
              path.setAttribute("clip-rule", "nonzero");
              var filterID;
              if (properties[i6].x.k !== 0) {
                maskType = "mask";
                maskRef = "mask";
                x3 = PropertyFactory.getProp(this.element, properties[i6].x, 0, null, this.element);
                filterID = createElementID();
                expansor = createNS("filter");
                expansor.setAttribute("id", filterID);
                feMorph = createNS("feMorphology");
                feMorph.setAttribute("operator", "erode");
                feMorph.setAttribute("in", "SourceGraphic");
                feMorph.setAttribute("radius", "0");
                expansor.appendChild(feMorph);
                defs.appendChild(expansor);
                path.setAttribute("stroke", properties[i6].mode === "s" ? "#000000" : "#ffffff");
              } else {
                feMorph = null;
                x3 = null;
              }
              this.storedData[i6] = {
                elem: path,
                x: x3,
                expan: feMorph,
                lastPath: "",
                lastOperator: "",
                filterId: filterID,
                lastRadius: 0
              };
              if (properties[i6].mode === "i") {
                jLen = currentMasks.length;
                var g3 = createNS("g");
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  g3.appendChild(currentMasks[j3]);
                }
                var mask2 = createNS("mask");
                mask2.setAttribute("mask-type", "alpha");
                mask2.setAttribute("id", layerId + "_" + count);
                mask2.appendChild(path);
                defs.appendChild(mask2);
                g3.setAttribute("mask", "url(" + getLocationHref() + "#" + layerId + "_" + count + ")");
                currentMasks.length = 0;
                currentMasks.push(g3);
              } else {
                currentMasks.push(path);
              }
              if (properties[i6].inv && !this.solidPath) {
                this.solidPath = this.createLayerSolidPath();
              }
              this.viewData[i6] = {
                elem: path,
                lastPath: "",
                op: PropertyFactory.getProp(this.element, properties[i6].o, 0, 0.01, this.element),
                prop: ShapePropertyFactory.getShapeProp(this.element, properties[i6], 3),
                invRect: rect
              };
              if (!this.viewData[i6].prop.k) {
                this.drawPath(properties[i6], this.viewData[i6].prop.v, this.viewData[i6]);
              }
            }
          }
          this.maskElement = createNS(maskType);
          len = currentMasks.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            this.maskElement.appendChild(currentMasks[i6]);
          }
          if (count > 0) {
            this.maskElement.setAttribute("id", layerId);
            this.element.maskedElement.setAttribute(maskRef, "url(" + getLocationHref() + "#" + layerId + ")");
            defs.appendChild(this.maskElement);
          }
          if (this.viewData.length) {
            this.element.addRenderableComponent(this);
          }
        }
        MaskElement.prototype.getMaskProperty = function(pos) {
          return this.viewData[pos].prop;
        };
        MaskElement.prototype.renderFrame = function(isFirstFrame) {
          var finalMat = this.element.finalTransform.mat;
          var i6;
          var len = this.masksProperties.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            if (this.viewData[i6].prop._mdf || isFirstFrame) {
              this.drawPath(this.masksProperties[i6], this.viewData[i6].prop.v, this.viewData[i6]);
            }
            if (this.viewData[i6].op._mdf || isFirstFrame) {
              this.viewData[i6].elem.setAttribute("fill-opacity", this.viewData[i6].op.v);
            }
            if (this.masksProperties[i6].mode !== "n") {
              if (this.viewData[i6].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {
                this.viewData[i6].invRect.setAttribute("transform", finalMat.getInverseMatrix().to2dCSS());
              }
              if (this.storedData[i6].x && (this.storedData[i6].x._mdf || isFirstFrame)) {
                var feMorph = this.storedData[i6].expan;
                if (this.storedData[i6].x.v < 0) {
                  if (this.storedData[i6].lastOperator !== "erode") {
                    this.storedData[i6].lastOperator = "erode";
                    this.storedData[i6].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[i6].filterId + ")");
                  }
                  feMorph.setAttribute("radius", -this.storedData[i6].x.v);
                } else {
                  if (this.storedData[i6].lastOperator !== "dilate") {
                    this.storedData[i6].lastOperator = "dilate";
                    this.storedData[i6].elem.setAttribute("filter", null);
                  }
                  this.storedData[i6].elem.setAttribute("stroke-width", this.storedData[i6].x.v * 2);
                }
              }
            }
          }
        };
        MaskElement.prototype.getMaskelement = function() {
          return this.maskElement;
        };
        MaskElement.prototype.createLayerSolidPath = function() {
          var path = "M0,0 ";
          path += " h" + this.globalData.compSize.w;
          path += " v" + this.globalData.compSize.h;
          path += " h-" + this.globalData.compSize.w;
          path += " v-" + this.globalData.compSize.h + " ";
          return path;
        };
        MaskElement.prototype.drawPath = function(pathData, pathNodes, viewData) {
          var pathString = " M" + pathNodes.v[0][0] + "," + pathNodes.v[0][1];
          var i6;
          var len;
          len = pathNodes._length;
          for (i6 = 1; i6 < len; i6 += 1) {
            pathString += " C" + pathNodes.o[i6 - 1][0] + "," + pathNodes.o[i6 - 1][1] + " " + pathNodes.i[i6][0] + "," + pathNodes.i[i6][1] + " " + pathNodes.v[i6][0] + "," + pathNodes.v[i6][1];
          }
          if (pathNodes.c && len > 1) {
            pathString += " C" + pathNodes.o[i6 - 1][0] + "," + pathNodes.o[i6 - 1][1] + " " + pathNodes.i[0][0] + "," + pathNodes.i[0][1] + " " + pathNodes.v[0][0] + "," + pathNodes.v[0][1];
          }
          if (viewData.lastPath !== pathString) {
            var pathShapeValue = "";
            if (viewData.elem) {
              if (pathNodes.c) {
                pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;
              }
              viewData.elem.setAttribute("d", pathShapeValue);
            }
            viewData.lastPath = pathString;
          }
        };
        MaskElement.prototype.destroy = function() {
          this.element = null;
          this.globalData = null;
          this.maskElement = null;
          this.data = null;
          this.masksProperties = null;
        };
        var filtersFactory = function() {
          var ob2 = {};
          ob2.createFilter = createFilter;
          ob2.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;
          function createFilter(filId, skipCoordinates) {
            var fil = createNS("filter");
            fil.setAttribute("id", filId);
            if (skipCoordinates !== true) {
              fil.setAttribute("filterUnits", "objectBoundingBox");
              fil.setAttribute("x", "0%");
              fil.setAttribute("y", "0%");
              fil.setAttribute("width", "100%");
              fil.setAttribute("height", "100%");
            }
            return fil;
          }
          function createAlphaToLuminanceFilter() {
            var feColorMatrix = createNS("feColorMatrix");
            feColorMatrix.setAttribute("type", "matrix");
            feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
            feColorMatrix.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1");
            return feColorMatrix;
          }
          return ob2;
        }();
        var featureSupport = function() {
          var ob2 = {
            maskType: true,
            svgLumaHidden: true,
            offscreenCanvas: typeof OffscreenCanvas !== "undefined"
          };
          if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) {
            ob2.maskType = false;
          }
          if (/firefox/i.test(navigator.userAgent)) {
            ob2.svgLumaHidden = false;
          }
          return ob2;
        }();
        var registeredEffects$1 = {};
        var idPrefix = "filter_result_";
        function SVGEffects(elem2) {
          var i6;
          var source = "SourceGraphic";
          var len = elem2.data.ef ? elem2.data.ef.length : 0;
          var filId = createElementID();
          var fil = filtersFactory.createFilter(filId, true);
          var count = 0;
          this.filters = [];
          var filterManager;
          for (i6 = 0; i6 < len; i6 += 1) {
            filterManager = null;
            var type = elem2.data.ef[i6].ty;
            if (registeredEffects$1[type]) {
              var Effect = registeredEffects$1[type].effect;
              filterManager = new Effect(fil, elem2.effectsManager.effectElements[i6], elem2, idPrefix + count, source);
              source = idPrefix + count;
              if (registeredEffects$1[type].countsAsEffect) {
                count += 1;
              }
            }
            if (filterManager) {
              this.filters.push(filterManager);
            }
          }
          if (count) {
            elem2.globalData.defs.appendChild(fil);
            elem2.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
          }
          if (this.filters.length) {
            elem2.addRenderableComponent(this);
          }
        }
        SVGEffects.prototype.renderFrame = function(_isFirstFrame) {
          var i6;
          var len = this.filters.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            this.filters[i6].renderFrame(_isFirstFrame);
          }
        };
        SVGEffects.prototype.getEffects = function(type) {
          var i6;
          var len = this.filters.length;
          var effects = [];
          for (i6 = 0; i6 < len; i6 += 1) {
            if (this.filters[i6].type === type) {
              effects.push(this.filters[i6]);
            }
          }
          return effects;
        };
        function registerEffect$1(id, effect2, countsAsEffect) {
          registeredEffects$1[id] = {
            effect: effect2,
            countsAsEffect
          };
        }
        function SVGBaseElement() {
        }
        SVGBaseElement.prototype = {
          initRendererElement: function initRendererElement() {
            this.layerElement = createNS("g");
          },
          createContainerElements: function createContainerElements() {
            this.matteElement = createNS("g");
            this.transformedElement = this.layerElement;
            this.maskedElement = this.layerElement;
            this._sizeChanged = false;
            var layerElementParent = null;
            if (this.data.td) {
              this.matteMasks = {};
              var gg = createNS("g");
              gg.setAttribute("id", this.layerId);
              gg.appendChild(this.layerElement);
              layerElementParent = gg;
              this.globalData.defs.appendChild(gg);
            } else if (this.data.tt) {
              this.matteElement.appendChild(this.layerElement);
              layerElementParent = this.matteElement;
              this.baseElement = this.matteElement;
            } else {
              this.baseElement = this.layerElement;
            }
            if (this.data.ln) {
              this.layerElement.setAttribute("id", this.data.ln);
            }
            if (this.data.cl) {
              this.layerElement.setAttribute("class", this.data.cl);
            }
            if (this.data.ty === 0 && !this.data.hd) {
              var cp = createNS("clipPath");
              var pt = createNS("path");
              pt.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
              var clipId = createElementID();
              cp.setAttribute("id", clipId);
              cp.appendChild(pt);
              this.globalData.defs.appendChild(cp);
              if (this.checkMasks()) {
                var cpGroup = createNS("g");
                cpGroup.setAttribute("clip-path", "url(" + getLocationHref() + "#" + clipId + ")");
                cpGroup.appendChild(this.layerElement);
                this.transformedElement = cpGroup;
                if (layerElementParent) {
                  layerElementParent.appendChild(this.transformedElement);
                } else {
                  this.baseElement = this.transformedElement;
                }
              } else {
                this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + clipId + ")");
              }
            }
            if (this.data.bm !== 0) {
              this.setBlendMode();
            }
          },
          renderElement: function renderElement() {
            if (this.finalTransform._localMatMdf) {
              this.transformedElement.setAttribute("transform", this.finalTransform.localMat.to2dCSS());
            }
            if (this.finalTransform._opMdf) {
              this.transformedElement.setAttribute("opacity", this.finalTransform.localOpacity);
            }
          },
          destroyBaseElement: function destroyBaseElement() {
            this.layerElement = null;
            this.matteElement = null;
            this.maskManager.destroy();
          },
          getBaseElement: function getBaseElement() {
            if (this.data.hd) {
              return null;
            }
            return this.baseElement;
          },
          createRenderableComponents: function createRenderableComponents() {
            this.maskManager = new MaskElement(this.data, this, this.globalData);
            this.renderableEffectsManager = new SVGEffects(this);
            this.searchEffectTransforms();
          },
          getMatte: function getMatte(matteType) {
            if (!this.matteMasks) {
              this.matteMasks = {};
            }
            if (!this.matteMasks[matteType]) {
              var id = this.layerId + "_" + matteType;
              var filId;
              var fil;
              var useElement;
              var gg;
              if (matteType === 1 || matteType === 3) {
                var masker = createNS("mask");
                masker.setAttribute("id", id);
                masker.setAttribute("mask-type", matteType === 3 ? "luminance" : "alpha");
                useElement = createNS("use");
                useElement.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId);
                masker.appendChild(useElement);
                this.globalData.defs.appendChild(masker);
                if (!featureSupport.maskType && matteType === 1) {
                  masker.setAttribute("mask-type", "luminance");
                  filId = createElementID();
                  fil = filtersFactory.createFilter(filId);
                  this.globalData.defs.appendChild(fil);
                  fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                  gg = createNS("g");
                  gg.appendChild(useElement);
                  masker.appendChild(gg);
                  gg.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
                }
              } else if (matteType === 2) {
                var maskGroup = createNS("mask");
                maskGroup.setAttribute("id", id);
                maskGroup.setAttribute("mask-type", "alpha");
                var maskGrouper = createNS("g");
                maskGroup.appendChild(maskGrouper);
                filId = createElementID();
                fil = filtersFactory.createFilter(filId);
                var feCTr = createNS("feComponentTransfer");
                feCTr.setAttribute("in", "SourceGraphic");
                fil.appendChild(feCTr);
                var feFunc = createNS("feFuncA");
                feFunc.setAttribute("type", "table");
                feFunc.setAttribute("tableValues", "1.0 0.0");
                feCTr.appendChild(feFunc);
                this.globalData.defs.appendChild(fil);
                var alphaRect = createNS("rect");
                alphaRect.setAttribute("width", this.comp.data.w);
                alphaRect.setAttribute("height", this.comp.data.h);
                alphaRect.setAttribute("x", "0");
                alphaRect.setAttribute("y", "0");
                alphaRect.setAttribute("fill", "#ffffff");
                alphaRect.setAttribute("opacity", "0");
                maskGrouper.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
                maskGrouper.appendChild(alphaRect);
                useElement = createNS("use");
                useElement.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId);
                maskGrouper.appendChild(useElement);
                if (!featureSupport.maskType) {
                  maskGroup.setAttribute("mask-type", "luminance");
                  fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                  gg = createNS("g");
                  maskGrouper.appendChild(alphaRect);
                  gg.appendChild(this.layerElement);
                  maskGrouper.appendChild(gg);
                }
                this.globalData.defs.appendChild(maskGroup);
              }
              this.matteMasks[matteType] = id;
            }
            return this.matteMasks[matteType];
          },
          setMatte: function setMatte(id) {
            if (!this.matteElement) {
              return;
            }
            this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + id + ")");
          }
        };
        function HierarchyElement() {
        }
        HierarchyElement.prototype = {
          /**
             * @function
             * Initializes hierarchy properties
             *
             */
          initHierarchy: function initHierarchy() {
            this.hierarchy = [];
            this._isParent = false;
            this.checkParenting();
          },
          /**
             * @function
             * Sets layer's hierarchy.
             * @param {array} hierarch
             * layer's parent list
             *
             */
          setHierarchy: function setHierarchy(hierarchy) {
            this.hierarchy = hierarchy;
          },
          /**
             * @function
             * Sets layer as parent.
             *
             */
          setAsParent: function setAsParent() {
            this._isParent = true;
          },
          /**
             * @function
             * Searches layer's parenting chain
             *
             */
          checkParenting: function checkParenting() {
            if (this.data.parent !== void 0) {
              this.comp.buildElementParenting(this, this.data.parent, []);
            }
          }
        };
        function RenderableDOMElement() {
        }
        (function() {
          var _prototype = {
            initElement: function initElement(data2, globalData2, comp2) {
              this.initFrame();
              this.initBaseData(data2, globalData2, comp2);
              this.initTransform(data2, globalData2, comp2);
              this.initHierarchy();
              this.initRenderable();
              this.initRendererElement();
              this.createContainerElements();
              this.createRenderableComponents();
              this.createContent();
              this.hide();
            },
            hide: function hide() {
              if (!this.hidden && (!this.isInRange || this.isTransparent)) {
                var elem2 = this.baseElement || this.layerElement;
                elem2.style.display = "none";
                this.hidden = true;
              }
            },
            show: function show() {
              if (this.isInRange && !this.isTransparent) {
                if (!this.data.hd) {
                  var elem2 = this.baseElement || this.layerElement;
                  elem2.style.display = "block";
                }
                this.hidden = false;
                this._isFirstFrame = true;
              }
            },
            renderFrame: function renderFrame() {
              if (this.data.hd || this.hidden) {
                return;
              }
              this.renderTransform();
              this.renderRenderable();
              this.renderLocalTransform();
              this.renderElement();
              this.renderInnerContent();
              if (this._isFirstFrame) {
                this._isFirstFrame = false;
              }
            },
            renderInnerContent: function renderInnerContent() {
            },
            prepareFrame: function prepareFrame(num) {
              this._mdf = false;
              this.prepareRenderableFrame(num);
              this.prepareProperties(num, this.isInRange);
              this.checkTransparency();
            },
            destroy: function destroy() {
              this.innerElem = null;
              this.destroyBaseElement();
            }
          };
          extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement);
        })();
        function IImageElement(data2, globalData2, comp2) {
          this.assetData = globalData2.getAssetData(data2.refId);
          if (this.assetData && this.assetData.sid) {
            this.assetData = globalData2.slotManager.getProp(this.assetData);
          }
          this.initElement(data2, globalData2, comp2);
          this.sourceRect = {
            top: 0,
            left: 0,
            width: this.assetData.w,
            height: this.assetData.h
          };
        }
        extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement);
        IImageElement.prototype.createContent = function() {
          var assetPath = this.globalData.getAssetsPath(this.assetData);
          this.innerElem = createNS("image");
          this.innerElem.setAttribute("width", this.assetData.w + "px");
          this.innerElem.setAttribute("height", this.assetData.h + "px");
          this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);
          this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", assetPath);
          this.layerElement.appendChild(this.innerElem);
        };
        IImageElement.prototype.sourceRectAtTime = function() {
          return this.sourceRect;
        };
        function ProcessedElement(element, position2) {
          this.elem = element;
          this.pos = position2;
        }
        function IShapeElement() {
        }
        IShapeElement.prototype = {
          addShapeToModifiers: function addShapeToModifiers(data2) {
            var i6;
            var len = this.shapeModifiers.length;
            for (i6 = 0; i6 < len; i6 += 1) {
              this.shapeModifiers[i6].addShape(data2);
            }
          },
          isShapeInAnimatedModifiers: function isShapeInAnimatedModifiers(data2) {
            var i6 = 0;
            var len = this.shapeModifiers.length;
            while (i6 < len) {
              if (this.shapeModifiers[i6].isAnimatedWithShape(data2)) {
                return true;
              }
            }
            return false;
          },
          renderModifiers: function renderModifiers() {
            if (!this.shapeModifiers.length) {
              return;
            }
            var i6;
            var len = this.shapes.length;
            for (i6 = 0; i6 < len; i6 += 1) {
              this.shapes[i6].sh.reset();
            }
            len = this.shapeModifiers.length;
            var shouldBreakProcess;
            for (i6 = len - 1; i6 >= 0; i6 -= 1) {
              shouldBreakProcess = this.shapeModifiers[i6].processShapes(this._isFirstFrame);
              if (shouldBreakProcess) {
                break;
              }
            }
          },
          searchProcessedElement: function searchProcessedElement(elem2) {
            var elements = this.processedElements;
            var i6 = 0;
            var len = elements.length;
            while (i6 < len) {
              if (elements[i6].elem === elem2) {
                return elements[i6].pos;
              }
              i6 += 1;
            }
            return 0;
          },
          addProcessedElement: function addProcessedElement(elem2, pos) {
            var elements = this.processedElements;
            var i6 = elements.length;
            while (i6) {
              i6 -= 1;
              if (elements[i6].elem === elem2) {
                elements[i6].pos = pos;
                return;
              }
            }
            elements.push(new ProcessedElement(elem2, pos));
          },
          prepareFrame: function prepareFrame(num) {
            this.prepareRenderableFrame(num);
            this.prepareProperties(num, this.isInRange);
          }
        };
        var lineCapEnum = {
          1: "butt",
          2: "round",
          3: "square"
        };
        var lineJoinEnum = {
          1: "miter",
          2: "round",
          3: "bevel"
        };
        function SVGShapeData(transformers, level, shape) {
          this.caches = [];
          this.styles = [];
          this.transformers = transformers;
          this.lStr = "";
          this.sh = shape;
          this.lvl = level;
          this._isAnimated = !!shape.k;
          var i6 = 0;
          var len = transformers.length;
          while (i6 < len) {
            if (transformers[i6].mProps.dynamicProperties.length) {
              this._isAnimated = true;
              break;
            }
            i6 += 1;
          }
        }
        SVGShapeData.prototype.setAsAnimated = function() {
          this._isAnimated = true;
        };
        function SVGStyleData(data2, level) {
          this.data = data2;
          this.type = data2.ty;
          this.d = "";
          this.lvl = level;
          this._mdf = false;
          this.closed = data2.hd === true;
          this.pElem = createNS("path");
          this.msElem = null;
        }
        SVGStyleData.prototype.reset = function() {
          this.d = "";
          this._mdf = false;
        };
        function DashProperty(elem2, data2, renderer2, container) {
          this.elem = elem2;
          this.frameId = -1;
          this.dataProps = createSizedArray(data2.length);
          this.renderer = renderer2;
          this.k = false;
          this.dashStr = "";
          this.dashArray = createTypedArray("float32", data2.length ? data2.length - 1 : 0);
          this.dashoffset = createTypedArray("float32", 1);
          this.initDynamicPropertyContainer(container);
          var i6;
          var len = data2.length || 0;
          var prop;
          for (i6 = 0; i6 < len; i6 += 1) {
            prop = PropertyFactory.getProp(elem2, data2[i6].v, 0, 0, this);
            this.k = prop.k || this.k;
            this.dataProps[i6] = {
              n: data2[i6].n,
              p: prop
            };
          }
          if (!this.k) {
            this.getValue(true);
          }
          this._isAnimated = this.k;
        }
        DashProperty.prototype.getValue = function(forceRender) {
          if (this.elem.globalData.frameId === this.frameId && !forceRender) {
            return;
          }
          this.frameId = this.elem.globalData.frameId;
          this.iterateDynamicProperties();
          this._mdf = this._mdf || forceRender;
          if (this._mdf) {
            var i6 = 0;
            var len = this.dataProps.length;
            if (this.renderer === "svg") {
              this.dashStr = "";
            }
            for (i6 = 0; i6 < len; i6 += 1) {
              if (this.dataProps[i6].n !== "o") {
                if (this.renderer === "svg") {
                  this.dashStr += " " + this.dataProps[i6].p.v;
                } else {
                  this.dashArray[i6] = this.dataProps[i6].p.v;
                }
              } else {
                this.dashoffset[0] = this.dataProps[i6].p.v;
              }
            }
          }
        };
        extendPrototype([DynamicPropertyContainer], DashProperty);
        function SVGStrokeStyleData(elem2, data2, styleOb) {
          this.initDynamicPropertyContainer(elem2);
          this.getValue = this.iterateDynamicProperties;
          this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, this);
          this.w = PropertyFactory.getProp(elem2, data2.w, 0, null, this);
          this.d = new DashProperty(elem2, data2.d || {}, "svg", this);
          this.c = PropertyFactory.getProp(elem2, data2.c, 1, 255, this);
          this.style = styleOb;
          this._isAnimated = !!this._isAnimated;
        }
        extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);
        function SVGFillStyleData(elem2, data2, styleOb) {
          this.initDynamicPropertyContainer(elem2);
          this.getValue = this.iterateDynamicProperties;
          this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, this);
          this.c = PropertyFactory.getProp(elem2, data2.c, 1, 255, this);
          this.style = styleOb;
        }
        extendPrototype([DynamicPropertyContainer], SVGFillStyleData);
        function SVGNoStyleData(elem2, data2, styleOb) {
          this.initDynamicPropertyContainer(elem2);
          this.getValue = this.iterateDynamicProperties;
          this.style = styleOb;
        }
        extendPrototype([DynamicPropertyContainer], SVGNoStyleData);
        function GradientProperty(elem2, data2, container) {
          this.data = data2;
          this.c = createTypedArray("uint8c", data2.p * 4);
          var cLength = data2.k.k[0].s ? data2.k.k[0].s.length - data2.p * 4 : data2.k.k.length - data2.p * 4;
          this.o = createTypedArray("float32", cLength);
          this._cmdf = false;
          this._omdf = false;
          this._collapsable = this.checkCollapsable();
          this._hasOpacity = cLength;
          this.initDynamicPropertyContainer(container);
          this.prop = PropertyFactory.getProp(elem2, data2.k, 1, null, this);
          this.k = this.prop.k;
          this.getValue(true);
        }
        GradientProperty.prototype.comparePoints = function(values, points) {
          var i6 = 0;
          var len = this.o.length / 2;
          var diff;
          while (i6 < len) {
            diff = Math.abs(values[i6 * 4] - values[points * 4 + i6 * 2]);
            if (diff > 0.01) {
              return false;
            }
            i6 += 1;
          }
          return true;
        };
        GradientProperty.prototype.checkCollapsable = function() {
          if (this.o.length / 2 !== this.c.length / 4) {
            return false;
          }
          if (this.data.k.k[0].s) {
            var i6 = 0;
            var len = this.data.k.k.length;
            while (i6 < len) {
              if (!this.comparePoints(this.data.k.k[i6].s, this.data.p)) {
                return false;
              }
              i6 += 1;
            }
          } else if (!this.comparePoints(this.data.k.k, this.data.p)) {
            return false;
          }
          return true;
        };
        GradientProperty.prototype.getValue = function(forceRender) {
          this.prop.getValue();
          this._mdf = false;
          this._cmdf = false;
          this._omdf = false;
          if (this.prop._mdf || forceRender) {
            var i6;
            var len = this.data.p * 4;
            var mult;
            var val2;
            for (i6 = 0; i6 < len; i6 += 1) {
              mult = i6 % 4 === 0 ? 100 : 255;
              val2 = Math.round(this.prop.v[i6] * mult);
              if (this.c[i6] !== val2) {
                this.c[i6] = val2;
                this._cmdf = !forceRender;
              }
            }
            if (this.o.length) {
              len = this.prop.v.length;
              for (i6 = this.data.p * 4; i6 < len; i6 += 1) {
                mult = i6 % 2 === 0 ? 100 : 1;
                val2 = i6 % 2 === 0 ? Math.round(this.prop.v[i6] * 100) : this.prop.v[i6];
                if (this.o[i6 - this.data.p * 4] !== val2) {
                  this.o[i6 - this.data.p * 4] = val2;
                  this._omdf = !forceRender;
                }
              }
            }
            this._mdf = !forceRender;
          }
        };
        extendPrototype([DynamicPropertyContainer], GradientProperty);
        function SVGGradientFillStyleData(elem2, data2, styleOb) {
          this.initDynamicPropertyContainer(elem2);
          this.getValue = this.iterateDynamicProperties;
          this.initGradientData(elem2, data2, styleOb);
        }
        SVGGradientFillStyleData.prototype.initGradientData = function(elem2, data2, styleOb) {
          this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, this);
          this.s = PropertyFactory.getProp(elem2, data2.s, 1, null, this);
          this.e = PropertyFactory.getProp(elem2, data2.e, 1, null, this);
          this.h = PropertyFactory.getProp(elem2, data2.h || {
            k: 0
          }, 0, 0.01, this);
          this.a = PropertyFactory.getProp(elem2, data2.a || {
            k: 0
          }, 0, degToRads, this);
          this.g = new GradientProperty(elem2, data2.g, this);
          this.style = styleOb;
          this.stops = [];
          this.setGradientData(styleOb.pElem, data2);
          this.setGradientOpacity(data2, styleOb);
          this._isAnimated = !!this._isAnimated;
        };
        SVGGradientFillStyleData.prototype.setGradientData = function(pathElement, data2) {
          var gradientId = createElementID();
          var gfill = createNS(data2.t === 1 ? "linearGradient" : "radialGradient");
          gfill.setAttribute("id", gradientId);
          gfill.setAttribute("spreadMethod", "pad");
          gfill.setAttribute("gradientUnits", "userSpaceOnUse");
          var stops = [];
          var stop;
          var j3;
          var jLen;
          jLen = data2.g.p * 4;
          for (j3 = 0; j3 < jLen; j3 += 4) {
            stop = createNS("stop");
            gfill.appendChild(stop);
            stops.push(stop);
          }
          pathElement.setAttribute(data2.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + gradientId + ")");
          this.gf = gfill;
          this.cst = stops;
        };
        SVGGradientFillStyleData.prototype.setGradientOpacity = function(data2, styleOb) {
          if (this.g._hasOpacity && !this.g._collapsable) {
            var stop;
            var j3;
            var jLen;
            var mask2 = createNS("mask");
            var maskElement = createNS("path");
            mask2.appendChild(maskElement);
            var opacityId = createElementID();
            var maskId = createElementID();
            mask2.setAttribute("id", maskId);
            var opFill = createNS(data2.t === 1 ? "linearGradient" : "radialGradient");
            opFill.setAttribute("id", opacityId);
            opFill.setAttribute("spreadMethod", "pad");
            opFill.setAttribute("gradientUnits", "userSpaceOnUse");
            jLen = data2.g.k.k[0].s ? data2.g.k.k[0].s.length : data2.g.k.k.length;
            var stops = this.stops;
            for (j3 = data2.g.p * 4; j3 < jLen; j3 += 2) {
              stop = createNS("stop");
              stop.setAttribute("stop-color", "rgb(255,255,255)");
              opFill.appendChild(stop);
              stops.push(stop);
            }
            maskElement.setAttribute(data2.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + opacityId + ")");
            if (data2.ty === "gs") {
              maskElement.setAttribute("stroke-linecap", lineCapEnum[data2.lc || 2]);
              maskElement.setAttribute("stroke-linejoin", lineJoinEnum[data2.lj || 2]);
              if (data2.lj === 1) {
                maskElement.setAttribute("stroke-miterlimit", data2.ml);
              }
            }
            this.of = opFill;
            this.ms = mask2;
            this.ost = stops;
            this.maskId = maskId;
            styleOb.msElem = maskElement;
          }
        };
        extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);
        function SVGGradientStrokeStyleData(elem2, data2, styleOb) {
          this.initDynamicPropertyContainer(elem2);
          this.getValue = this.iterateDynamicProperties;
          this.w = PropertyFactory.getProp(elem2, data2.w, 0, null, this);
          this.d = new DashProperty(elem2, data2.d || {}, "svg", this);
          this.initGradientData(elem2, data2, styleOb);
          this._isAnimated = !!this._isAnimated;
        }
        extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
        function ShapeGroupData() {
          this.it = [];
          this.prevViewData = [];
          this.gr = createNS("g");
        }
        function SVGTransformData(mProps, op, container) {
          this.transform = {
            mProps,
            op,
            container
          };
          this.elements = [];
          this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
        }
        var buildShapeString = function buildShapeString2(pathNodes, length2, closed, mat) {
          if (length2 === 0) {
            return "";
          }
          var _o = pathNodes.o;
          var _i = pathNodes.i;
          var _v = pathNodes.v;
          var i6;
          var shapeString = " M" + mat.applyToPointStringified(_v[0][0], _v[0][1]);
          for (i6 = 1; i6 < length2; i6 += 1) {
            shapeString += " C" + mat.applyToPointStringified(_o[i6 - 1][0], _o[i6 - 1][1]) + " " + mat.applyToPointStringified(_i[i6][0], _i[i6][1]) + " " + mat.applyToPointStringified(_v[i6][0], _v[i6][1]);
          }
          if (closed && length2) {
            shapeString += " C" + mat.applyToPointStringified(_o[i6 - 1][0], _o[i6 - 1][1]) + " " + mat.applyToPointStringified(_i[0][0], _i[0][1]) + " " + mat.applyToPointStringified(_v[0][0], _v[0][1]);
            shapeString += "z";
          }
          return shapeString;
        };
        var SVGElementsRenderer = function() {
          var _identityMatrix = new Matrix();
          var _matrixHelper = new Matrix();
          var ob2 = {
            createRenderFunction
          };
          function createRenderFunction(data2) {
            switch (data2.ty) {
              case "fl":
                return renderFill;
              case "gf":
                return renderGradient;
              case "gs":
                return renderGradientStroke;
              case "st":
                return renderStroke;
              case "sh":
              case "el":
              case "rc":
              case "sr":
                return renderPath;
              case "tr":
                return renderContentTransform;
              case "no":
                return renderNoop;
              default:
                return null;
            }
          }
          function renderContentTransform(styleData, itemData, isFirstFrame) {
            if (isFirstFrame || itemData.transform.op._mdf) {
              itemData.transform.container.setAttribute("opacity", itemData.transform.op.v);
            }
            if (isFirstFrame || itemData.transform.mProps._mdf) {
              itemData.transform.container.setAttribute("transform", itemData.transform.mProps.v.to2dCSS());
            }
          }
          function renderNoop() {
          }
          function renderPath(styleData, itemData, isFirstFrame) {
            var j3;
            var jLen;
            var pathStringTransformed;
            var redraw;
            var pathNodes;
            var l6;
            var lLen = itemData.styles.length;
            var lvl = itemData.lvl;
            var paths;
            var mat;
            var iterations;
            var k3;
            for (l6 = 0; l6 < lLen; l6 += 1) {
              redraw = itemData.sh._mdf || isFirstFrame;
              if (itemData.styles[l6].lvl < lvl) {
                mat = _matrixHelper.reset();
                iterations = lvl - itemData.styles[l6].lvl;
                k3 = itemData.transformers.length - 1;
                while (!redraw && iterations > 0) {
                  redraw = itemData.transformers[k3].mProps._mdf || redraw;
                  iterations -= 1;
                  k3 -= 1;
                }
                if (redraw) {
                  iterations = lvl - itemData.styles[l6].lvl;
                  k3 = itemData.transformers.length - 1;
                  while (iterations > 0) {
                    mat.multiply(itemData.transformers[k3].mProps.v);
                    iterations -= 1;
                    k3 -= 1;
                  }
                }
              } else {
                mat = _identityMatrix;
              }
              paths = itemData.sh.paths;
              jLen = paths._length;
              if (redraw) {
                pathStringTransformed = "";
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  pathNodes = paths.shapes[j3];
                  if (pathNodes && pathNodes._length) {
                    pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);
                  }
                }
                itemData.caches[l6] = pathStringTransformed;
              } else {
                pathStringTransformed = itemData.caches[l6];
              }
              itemData.styles[l6].d += styleData.hd === true ? "" : pathStringTransformed;
              itemData.styles[l6]._mdf = redraw || itemData.styles[l6]._mdf;
            }
          }
          function renderFill(styleData, itemData, isFirstFrame) {
            var styleElem = itemData.style;
            if (itemData.c._mdf || isFirstFrame) {
              styleElem.pElem.setAttribute("fill", "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")");
            }
            if (itemData.o._mdf || isFirstFrame) {
              styleElem.pElem.setAttribute("fill-opacity", itemData.o.v);
            }
          }
          function renderGradientStroke(styleData, itemData, isFirstFrame) {
            renderGradient(styleData, itemData, isFirstFrame);
            renderStroke(styleData, itemData, isFirstFrame);
          }
          function renderGradient(styleData, itemData, isFirstFrame) {
            var gfill = itemData.gf;
            var hasOpacity = itemData.g._hasOpacity;
            var pt1 = itemData.s.v;
            var pt2 = itemData.e.v;
            if (itemData.o._mdf || isFirstFrame) {
              var attr = styleData.ty === "gf" ? "fill-opacity" : "stroke-opacity";
              itemData.style.pElem.setAttribute(attr, itemData.o.v);
            }
            if (itemData.s._mdf || isFirstFrame) {
              var attr1 = styleData.t === 1 ? "x1" : "cx";
              var attr2 = attr1 === "x1" ? "y1" : "cy";
              gfill.setAttribute(attr1, pt1[0]);
              gfill.setAttribute(attr2, pt1[1]);
              if (hasOpacity && !itemData.g._collapsable) {
                itemData.of.setAttribute(attr1, pt1[0]);
                itemData.of.setAttribute(attr2, pt1[1]);
              }
            }
            var stops;
            var i6;
            var len;
            var stop;
            if (itemData.g._cmdf || isFirstFrame) {
              stops = itemData.cst;
              var cValues = itemData.g.c;
              len = stops.length;
              for (i6 = 0; i6 < len; i6 += 1) {
                stop = stops[i6];
                stop.setAttribute("offset", cValues[i6 * 4] + "%");
                stop.setAttribute("stop-color", "rgb(" + cValues[i6 * 4 + 1] + "," + cValues[i6 * 4 + 2] + "," + cValues[i6 * 4 + 3] + ")");
              }
            }
            if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
              var oValues = itemData.g.o;
              if (itemData.g._collapsable) {
                stops = itemData.cst;
              } else {
                stops = itemData.ost;
              }
              len = stops.length;
              for (i6 = 0; i6 < len; i6 += 1) {
                stop = stops[i6];
                if (!itemData.g._collapsable) {
                  stop.setAttribute("offset", oValues[i6 * 2] + "%");
                }
                stop.setAttribute("stop-opacity", oValues[i6 * 2 + 1]);
              }
            }
            if (styleData.t === 1) {
              if (itemData.e._mdf || isFirstFrame) {
                gfill.setAttribute("x2", pt2[0]);
                gfill.setAttribute("y2", pt2[1]);
                if (hasOpacity && !itemData.g._collapsable) {
                  itemData.of.setAttribute("x2", pt2[0]);
                  itemData.of.setAttribute("y2", pt2[1]);
                }
              }
            } else {
              var rad;
              if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {
                rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
                gfill.setAttribute("r", rad);
                if (hasOpacity && !itemData.g._collapsable) {
                  itemData.of.setAttribute("r", rad);
                }
              }
              if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {
                if (!rad) {
                  rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
                }
                var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
                var percent = itemData.h.v;
                if (percent >= 1) {
                  percent = 0.99;
                } else if (percent <= -1) {
                  percent = -0.99;
                }
                var dist = rad * percent;
                var x3 = Math.cos(ang + itemData.a.v) * dist + pt1[0];
                var y3 = Math.sin(ang + itemData.a.v) * dist + pt1[1];
                gfill.setAttribute("fx", x3);
                gfill.setAttribute("fy", y3);
                if (hasOpacity && !itemData.g._collapsable) {
                  itemData.of.setAttribute("fx", x3);
                  itemData.of.setAttribute("fy", y3);
                }
              }
            }
          }
          function renderStroke(styleData, itemData, isFirstFrame) {
            var styleElem = itemData.style;
            var d3 = itemData.d;
            if (d3 && (d3._mdf || isFirstFrame) && d3.dashStr) {
              styleElem.pElem.setAttribute("stroke-dasharray", d3.dashStr);
              styleElem.pElem.setAttribute("stroke-dashoffset", d3.dashoffset[0]);
            }
            if (itemData.c && (itemData.c._mdf || isFirstFrame)) {
              styleElem.pElem.setAttribute("stroke", "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")");
            }
            if (itemData.o._mdf || isFirstFrame) {
              styleElem.pElem.setAttribute("stroke-opacity", itemData.o.v);
            }
            if (itemData.w._mdf || isFirstFrame) {
              styleElem.pElem.setAttribute("stroke-width", itemData.w.v);
              if (styleElem.msElem) {
                styleElem.msElem.setAttribute("stroke-width", itemData.w.v);
              }
            }
          }
          return ob2;
        }();
        function SVGShapeElement(data2, globalData2, comp2) {
          this.shapes = [];
          this.shapesData = data2.shapes;
          this.stylesList = [];
          this.shapeModifiers = [];
          this.itemsData = [];
          this.processedElements = [];
          this.animatedContents = [];
          this.initElement(data2, globalData2, comp2);
          this.prevViewData = [];
        }
        extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement);
        SVGShapeElement.prototype.initSecondaryElement = function() {
        };
        SVGShapeElement.prototype.identityMatrix = new Matrix();
        SVGShapeElement.prototype.buildExpressionInterface = function() {
        };
        SVGShapeElement.prototype.createContent = function() {
          this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
          this.filterUniqueShapes();
        };
        SVGShapeElement.prototype.filterUniqueShapes = function() {
          var i6;
          var len = this.shapes.length;
          var shape;
          var j3;
          var jLen = this.stylesList.length;
          var style;
          var tempShapes = [];
          var areAnimated = false;
          for (j3 = 0; j3 < jLen; j3 += 1) {
            style = this.stylesList[j3];
            areAnimated = false;
            tempShapes.length = 0;
            for (i6 = 0; i6 < len; i6 += 1) {
              shape = this.shapes[i6];
              if (shape.styles.indexOf(style) !== -1) {
                tempShapes.push(shape);
                areAnimated = shape._isAnimated || areAnimated;
              }
            }
            if (tempShapes.length > 1 && areAnimated) {
              this.setShapesAsAnimated(tempShapes);
            }
          }
        };
        SVGShapeElement.prototype.setShapesAsAnimated = function(shapes) {
          var i6;
          var len = shapes.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            shapes[i6].setAsAnimated();
          }
        };
        SVGShapeElement.prototype.createStyleElement = function(data2, level) {
          var elementData;
          var styleOb = new SVGStyleData(data2, level);
          var pathElement = styleOb.pElem;
          if (data2.ty === "st") {
            elementData = new SVGStrokeStyleData(this, data2, styleOb);
          } else if (data2.ty === "fl") {
            elementData = new SVGFillStyleData(this, data2, styleOb);
          } else if (data2.ty === "gf" || data2.ty === "gs") {
            var GradientConstructor = data2.ty === "gf" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
            elementData = new GradientConstructor(this, data2, styleOb);
            this.globalData.defs.appendChild(elementData.gf);
            if (elementData.maskId) {
              this.globalData.defs.appendChild(elementData.ms);
              this.globalData.defs.appendChild(elementData.of);
              pathElement.setAttribute("mask", "url(" + getLocationHref() + "#" + elementData.maskId + ")");
            }
          } else if (data2.ty === "no") {
            elementData = new SVGNoStyleData(this, data2, styleOb);
          }
          if (data2.ty === "st" || data2.ty === "gs") {
            pathElement.setAttribute("stroke-linecap", lineCapEnum[data2.lc || 2]);
            pathElement.setAttribute("stroke-linejoin", lineJoinEnum[data2.lj || 2]);
            pathElement.setAttribute("fill-opacity", "0");
            if (data2.lj === 1) {
              pathElement.setAttribute("stroke-miterlimit", data2.ml);
            }
          }
          if (data2.r === 2) {
            pathElement.setAttribute("fill-rule", "evenodd");
          }
          if (data2.ln) {
            pathElement.setAttribute("id", data2.ln);
          }
          if (data2.cl) {
            pathElement.setAttribute("class", data2.cl);
          }
          if (data2.bm) {
            pathElement.style["mix-blend-mode"] = getBlendMode(data2.bm);
          }
          this.stylesList.push(styleOb);
          this.addToAnimatedContents(data2, elementData);
          return elementData;
        };
        SVGShapeElement.prototype.createGroupElement = function(data2) {
          var elementData = new ShapeGroupData();
          if (data2.ln) {
            elementData.gr.setAttribute("id", data2.ln);
          }
          if (data2.cl) {
            elementData.gr.setAttribute("class", data2.cl);
          }
          if (data2.bm) {
            elementData.gr.style["mix-blend-mode"] = getBlendMode(data2.bm);
          }
          return elementData;
        };
        SVGShapeElement.prototype.createTransformElement = function(data2, container) {
          var transformProperty = TransformPropertyFactory.getTransformProperty(this, data2, this);
          var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);
          this.addToAnimatedContents(data2, elementData);
          return elementData;
        };
        SVGShapeElement.prototype.createShapeElement = function(data2, ownTransformers, level) {
          var ty = 4;
          if (data2.ty === "rc") {
            ty = 5;
          } else if (data2.ty === "el") {
            ty = 6;
          } else if (data2.ty === "sr") {
            ty = 7;
          }
          var shapeProperty = ShapePropertyFactory.getShapeProp(this, data2, ty, this);
          var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);
          this.shapes.push(elementData);
          this.addShapeToModifiers(elementData);
          this.addToAnimatedContents(data2, elementData);
          return elementData;
        };
        SVGShapeElement.prototype.addToAnimatedContents = function(data2, element) {
          var i6 = 0;
          var len = this.animatedContents.length;
          while (i6 < len) {
            if (this.animatedContents[i6].element === element) {
              return;
            }
            i6 += 1;
          }
          this.animatedContents.push({
            fn: SVGElementsRenderer.createRenderFunction(data2),
            element,
            data: data2
          });
        };
        SVGShapeElement.prototype.setElementStyles = function(elementData) {
          var arr = elementData.styles;
          var j3;
          var jLen = this.stylesList.length;
          for (j3 = 0; j3 < jLen; j3 += 1) {
            if (!this.stylesList[j3].closed) {
              arr.push(this.stylesList[j3]);
            }
          }
        };
        SVGShapeElement.prototype.reloadShapes = function() {
          this._isFirstFrame = true;
          var i6;
          var len = this.itemsData.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            this.prevViewData[i6] = this.itemsData[i6];
          }
          this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
          this.filterUniqueShapes();
          len = this.dynamicProperties.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            this.dynamicProperties[i6].getValue();
          }
          this.renderModifiers();
        };
        SVGShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, container, level, transformers, render3) {
          var ownTransformers = [].concat(transformers);
          var i6;
          var len = arr.length - 1;
          var j3;
          var jLen;
          var ownStyles = [];
          var ownModifiers = [];
          var currentTransform;
          var modifier;
          var processedPos;
          for (i6 = len; i6 >= 0; i6 -= 1) {
            processedPos = this.searchProcessedElement(arr[i6]);
            if (!processedPos) {
              arr[i6]._render = render3;
            } else {
              itemsData[i6] = prevViewData[processedPos - 1];
            }
            if (arr[i6].ty === "fl" || arr[i6].ty === "st" || arr[i6].ty === "gf" || arr[i6].ty === "gs" || arr[i6].ty === "no") {
              if (!processedPos) {
                itemsData[i6] = this.createStyleElement(arr[i6], level);
              } else {
                itemsData[i6].style.closed = false;
              }
              if (arr[i6]._render) {
                if (itemsData[i6].style.pElem.parentNode !== container) {
                  container.appendChild(itemsData[i6].style.pElem);
                }
              }
              ownStyles.push(itemsData[i6].style);
            } else if (arr[i6].ty === "gr") {
              if (!processedPos) {
                itemsData[i6] = this.createGroupElement(arr[i6]);
              } else {
                jLen = itemsData[i6].it.length;
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  itemsData[i6].prevViewData[j3] = itemsData[i6].it[j3];
                }
              }
              this.searchShapes(arr[i6].it, itemsData[i6].it, itemsData[i6].prevViewData, itemsData[i6].gr, level + 1, ownTransformers, render3);
              if (arr[i6]._render) {
                if (itemsData[i6].gr.parentNode !== container) {
                  container.appendChild(itemsData[i6].gr);
                }
              }
            } else if (arr[i6].ty === "tr") {
              if (!processedPos) {
                itemsData[i6] = this.createTransformElement(arr[i6], container);
              }
              currentTransform = itemsData[i6].transform;
              ownTransformers.push(currentTransform);
            } else if (arr[i6].ty === "sh" || arr[i6].ty === "rc" || arr[i6].ty === "el" || arr[i6].ty === "sr") {
              if (!processedPos) {
                itemsData[i6] = this.createShapeElement(arr[i6], ownTransformers, level);
              }
              this.setElementStyles(itemsData[i6]);
            } else if (arr[i6].ty === "tm" || arr[i6].ty === "rd" || arr[i6].ty === "ms" || arr[i6].ty === "pb" || arr[i6].ty === "zz" || arr[i6].ty === "op") {
              if (!processedPos) {
                modifier = ShapeModifiers.getModifier(arr[i6].ty);
                modifier.init(this, arr[i6]);
                itemsData[i6] = modifier;
                this.shapeModifiers.push(modifier);
              } else {
                modifier = itemsData[i6];
                modifier.closed = false;
              }
              ownModifiers.push(modifier);
            } else if (arr[i6].ty === "rp") {
              if (!processedPos) {
                modifier = ShapeModifiers.getModifier(arr[i6].ty);
                itemsData[i6] = modifier;
                modifier.init(this, arr, i6, itemsData);
                this.shapeModifiers.push(modifier);
                render3 = false;
              } else {
                modifier = itemsData[i6];
                modifier.closed = true;
              }
              ownModifiers.push(modifier);
            }
            this.addProcessedElement(arr[i6], i6 + 1);
          }
          len = ownStyles.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            ownStyles[i6].closed = true;
          }
          len = ownModifiers.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            ownModifiers[i6].closed = true;
          }
        };
        SVGShapeElement.prototype.renderInnerContent = function() {
          this.renderModifiers();
          var i6;
          var len = this.stylesList.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            this.stylesList[i6].reset();
          }
          this.renderShape();
          for (i6 = 0; i6 < len; i6 += 1) {
            if (this.stylesList[i6]._mdf || this._isFirstFrame) {
              if (this.stylesList[i6].msElem) {
                this.stylesList[i6].msElem.setAttribute("d", this.stylesList[i6].d);
                this.stylesList[i6].d = "M0 0" + this.stylesList[i6].d;
              }
              this.stylesList[i6].pElem.setAttribute("d", this.stylesList[i6].d || "M0 0");
            }
          }
        };
        SVGShapeElement.prototype.renderShape = function() {
          var i6;
          var len = this.animatedContents.length;
          var animatedContent;
          for (i6 = 0; i6 < len; i6 += 1) {
            animatedContent = this.animatedContents[i6];
            if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {
              animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);
            }
          }
        };
        SVGShapeElement.prototype.destroy = function() {
          this.destroyBaseElement();
          this.shapesData = null;
          this.itemsData = null;
        };
        function LetterProps(o5, sw, sc, fc, m3, p3) {
          this.o = o5;
          this.sw = sw;
          this.sc = sc;
          this.fc = fc;
          this.m = m3;
          this.p = p3;
          this._mdf = {
            o: true,
            sw: !!sw,
            sc: !!sc,
            fc: !!fc,
            m: true,
            p: true
          };
        }
        LetterProps.prototype.update = function(o5, sw, sc, fc, m3, p3) {
          this._mdf.o = false;
          this._mdf.sw = false;
          this._mdf.sc = false;
          this._mdf.fc = false;
          this._mdf.m = false;
          this._mdf.p = false;
          var updated = false;
          if (this.o !== o5) {
            this.o = o5;
            this._mdf.o = true;
            updated = true;
          }
          if (this.sw !== sw) {
            this.sw = sw;
            this._mdf.sw = true;
            updated = true;
          }
          if (this.sc !== sc) {
            this.sc = sc;
            this._mdf.sc = true;
            updated = true;
          }
          if (this.fc !== fc) {
            this.fc = fc;
            this._mdf.fc = true;
            updated = true;
          }
          if (this.m !== m3) {
            this.m = m3;
            this._mdf.m = true;
            updated = true;
          }
          if (p3.length && (this.p[0] !== p3[0] || this.p[1] !== p3[1] || this.p[4] !== p3[4] || this.p[5] !== p3[5] || this.p[12] !== p3[12] || this.p[13] !== p3[13])) {
            this.p = p3;
            this._mdf.p = true;
            updated = true;
          }
          return updated;
        };
        function TextProperty(elem2, data2) {
          this._frameId = initialDefaultFrame;
          this.pv = "";
          this.v = "";
          this.kf = false;
          this._isFirstFrame = true;
          this._mdf = false;
          if (data2.d && data2.d.sid) {
            data2.d = elem2.globalData.slotManager.getProp(data2.d);
          }
          this.data = data2;
          this.elem = elem2;
          this.comp = this.elem.comp;
          this.keysIndex = 0;
          this.canResize = false;
          this.minimumFontSize = 1;
          this.effectsSequence = [];
          this.currentData = {
            ascent: 0,
            boxWidth: this.defaultBoxWidth,
            f: "",
            fStyle: "",
            fWeight: "",
            fc: "",
            j: "",
            justifyOffset: "",
            l: [],
            lh: 0,
            lineWidths: [],
            ls: "",
            of: "",
            s: "",
            sc: "",
            sw: 0,
            t: 0,
            tr: 0,
            sz: 0,
            ps: null,
            fillColorAnim: false,
            strokeColorAnim: false,
            strokeWidthAnim: false,
            yOffset: 0,
            finalSize: 0,
            finalText: [],
            finalLineHeight: 0,
            __complete: false
          };
          this.copyData(this.currentData, this.data.d.k[0].s);
          if (!this.searchProperty()) {
            this.completeTextData(this.currentData);
          }
        }
        TextProperty.prototype.defaultBoxWidth = [0, 0];
        TextProperty.prototype.copyData = function(obj, data2) {
          for (var s4 in data2) {
            if (Object.prototype.hasOwnProperty.call(data2, s4)) {
              obj[s4] = data2[s4];
            }
          }
          return obj;
        };
        TextProperty.prototype.setCurrentData = function(data2) {
          if (!data2.__complete) {
            this.completeTextData(data2);
          }
          this.currentData = data2;
          this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;
          this._mdf = true;
        };
        TextProperty.prototype.searchProperty = function() {
          return this.searchKeyframes();
        };
        TextProperty.prototype.searchKeyframes = function() {
          this.kf = this.data.d.k.length > 1;
          if (this.kf) {
            this.addEffect(this.getKeyframeValue.bind(this));
          }
          return this.kf;
        };
        TextProperty.prototype.addEffect = function(effectFunction) {
          this.effectsSequence.push(effectFunction);
          this.elem.addDynamicProperty(this);
        };
        TextProperty.prototype.getValue = function(_finalValue) {
          if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {
            return;
          }
          this.currentData.t = this.data.d.k[this.keysIndex].s.t;
          var currentValue = this.currentData;
          var currentIndex = this.keysIndex;
          if (this.lock) {
            this.setCurrentData(this.currentData);
            return;
          }
          this.lock = true;
          this._mdf = false;
          var i6;
          var len = this.effectsSequence.length;
          var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;
          for (i6 = 0; i6 < len; i6 += 1) {
            if (currentIndex !== this.keysIndex) {
              finalValue = this.effectsSequence[i6](finalValue, finalValue.t);
            } else {
              finalValue = this.effectsSequence[i6](this.currentData, finalValue.t);
            }
          }
          if (currentValue !== finalValue) {
            this.setCurrentData(finalValue);
          }
          this.v = this.currentData;
          this.pv = this.v;
          this.lock = false;
          this.frameId = this.elem.globalData.frameId;
        };
        TextProperty.prototype.getKeyframeValue = function() {
          var textKeys = this.data.d.k;
          var frameNum = this.elem.comp.renderedFrame;
          var i6 = 0;
          var len = textKeys.length;
          while (i6 <= len - 1) {
            if (i6 === len - 1 || textKeys[i6 + 1].t > frameNum) {
              break;
            }
            i6 += 1;
          }
          if (this.keysIndex !== i6) {
            this.keysIndex = i6;
          }
          return this.data.d.k[this.keysIndex].s;
        };
        TextProperty.prototype.buildFinalText = function(text2) {
          var charactersArray = [];
          var i6 = 0;
          var len = text2.length;
          var charCode;
          var secondCharCode;
          var shouldCombine = false;
          var shouldCombineNext = false;
          var currentChars = "";
          while (i6 < len) {
            shouldCombine = shouldCombineNext;
            shouldCombineNext = false;
            charCode = text2.charCodeAt(i6);
            currentChars = text2.charAt(i6);
            if (FontManager.isCombinedCharacter(charCode)) {
              shouldCombine = true;
            } else if (charCode >= 55296 && charCode <= 56319) {
              if (FontManager.isRegionalFlag(text2, i6)) {
                currentChars = text2.substr(i6, 14);
              } else {
                secondCharCode = text2.charCodeAt(i6 + 1);
                if (secondCharCode >= 56320 && secondCharCode <= 57343) {
                  if (FontManager.isModifier(charCode, secondCharCode)) {
                    currentChars = text2.substr(i6, 2);
                    shouldCombine = true;
                  } else if (FontManager.isFlagEmoji(text2.substr(i6, 4))) {
                    currentChars = text2.substr(i6, 4);
                  } else {
                    currentChars = text2.substr(i6, 2);
                  }
                }
              }
            } else if (charCode > 56319) {
              secondCharCode = text2.charCodeAt(i6 + 1);
              if (FontManager.isVariationSelector(charCode)) {
                shouldCombine = true;
              }
            } else if (FontManager.isZeroWidthJoiner(charCode)) {
              shouldCombine = true;
              shouldCombineNext = true;
            }
            if (shouldCombine) {
              charactersArray[charactersArray.length - 1] += currentChars;
              shouldCombine = false;
            } else {
              charactersArray.push(currentChars);
            }
            i6 += currentChars.length;
          }
          return charactersArray;
        };
        TextProperty.prototype.completeTextData = function(documentData) {
          documentData.__complete = true;
          var fontManager = this.elem.globalData.fontManager;
          var data2 = this.data;
          var letters = [];
          var i6;
          var len;
          var newLineFlag;
          var index2 = 0;
          var val2;
          var anchorGrouping = data2.m.g;
          var currentSize = 0;
          var currentPos = 0;
          var currentLine = 0;
          var lineWidths = [];
          var lineWidth = 0;
          var maxLineWidth = 0;
          var j3;
          var jLen;
          var fontData = fontManager.getFontByName(documentData.f);
          var charData;
          var cLength = 0;
          var fontProps = getFontProperties(fontData);
          documentData.fWeight = fontProps.weight;
          documentData.fStyle = fontProps.style;
          documentData.finalSize = documentData.s;
          documentData.finalText = this.buildFinalText(documentData.t);
          len = documentData.finalText.length;
          documentData.finalLineHeight = documentData.lh;
          var trackingOffset = documentData.tr / 1e3 * documentData.finalSize;
          var charCode;
          if (documentData.sz) {
            var flag = true;
            var boxWidth = documentData.sz[0];
            var boxHeight = documentData.sz[1];
            var currentHeight;
            var finalText;
            while (flag) {
              finalText = this.buildFinalText(documentData.t);
              currentHeight = 0;
              lineWidth = 0;
              len = finalText.length;
              trackingOffset = documentData.tr / 1e3 * documentData.finalSize;
              var lastSpaceIndex = -1;
              for (i6 = 0; i6 < len; i6 += 1) {
                charCode = finalText[i6].charCodeAt(0);
                newLineFlag = false;
                if (finalText[i6] === " ") {
                  lastSpaceIndex = i6;
                } else if (charCode === 13 || charCode === 3) {
                  lineWidth = 0;
                  newLineFlag = true;
                  currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
                }
                if (fontManager.chars) {
                  charData = fontManager.getCharData(finalText[i6], fontData.fStyle, fontData.fFamily);
                  cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
                } else {
                  cLength = fontManager.measureText(finalText[i6], documentData.f, documentData.finalSize);
                }
                if (lineWidth + cLength > boxWidth && finalText[i6] !== " ") {
                  if (lastSpaceIndex === -1) {
                    len += 1;
                  } else {
                    i6 = lastSpaceIndex;
                  }
                  currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
                  finalText.splice(i6, lastSpaceIndex === i6 ? 1 : 0, "\r");
                  lastSpaceIndex = -1;
                  lineWidth = 0;
                } else {
                  lineWidth += cLength;
                  lineWidth += trackingOffset;
                }
              }
              currentHeight += fontData.ascent * documentData.finalSize / 100;
              if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {
                documentData.finalSize -= 1;
                documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;
              } else {
                documentData.finalText = finalText;
                len = documentData.finalText.length;
                flag = false;
              }
            }
          }
          lineWidth = -trackingOffset;
          cLength = 0;
          var uncollapsedSpaces = 0;
          var currentChar;
          for (i6 = 0; i6 < len; i6 += 1) {
            newLineFlag = false;
            currentChar = documentData.finalText[i6];
            charCode = currentChar.charCodeAt(0);
            if (charCode === 13 || charCode === 3) {
              uncollapsedSpaces = 0;
              lineWidths.push(lineWidth);
              maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
              lineWidth = -2 * trackingOffset;
              val2 = "";
              newLineFlag = true;
              currentLine += 1;
            } else {
              val2 = currentChar;
            }
            if (fontManager.chars) {
              charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
              cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
            } else {
              cLength = fontManager.measureText(val2, documentData.f, documentData.finalSize);
            }
            if (currentChar === " ") {
              uncollapsedSpaces += cLength + trackingOffset;
            } else {
              lineWidth += cLength + trackingOffset + uncollapsedSpaces;
              uncollapsedSpaces = 0;
            }
            letters.push({
              l: cLength,
              an: cLength,
              add: currentSize,
              n: newLineFlag,
              anIndexes: [],
              val: val2,
              line: currentLine,
              animatorJustifyOffset: 0
            });
            if (anchorGrouping == 2) {
              currentSize += cLength;
              if (val2 === "" || val2 === " " || i6 === len - 1) {
                if (val2 === "" || val2 === " ") {
                  currentSize -= cLength;
                }
                while (currentPos <= i6) {
                  letters[currentPos].an = currentSize;
                  letters[currentPos].ind = index2;
                  letters[currentPos].extra = cLength;
                  currentPos += 1;
                }
                index2 += 1;
                currentSize = 0;
              }
            } else if (anchorGrouping == 3) {
              currentSize += cLength;
              if (val2 === "" || i6 === len - 1) {
                if (val2 === "") {
                  currentSize -= cLength;
                }
                while (currentPos <= i6) {
                  letters[currentPos].an = currentSize;
                  letters[currentPos].ind = index2;
                  letters[currentPos].extra = cLength;
                  currentPos += 1;
                }
                currentSize = 0;
                index2 += 1;
              }
            } else {
              letters[index2].ind = index2;
              letters[index2].extra = 0;
              index2 += 1;
            }
          }
          documentData.l = letters;
          maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
          lineWidths.push(lineWidth);
          if (documentData.sz) {
            documentData.boxWidth = documentData.sz[0];
            documentData.justifyOffset = 0;
          } else {
            documentData.boxWidth = maxLineWidth;
            switch (documentData.j) {
              case 1:
                documentData.justifyOffset = -documentData.boxWidth;
                break;
              case 2:
                documentData.justifyOffset = -documentData.boxWidth / 2;
                break;
              default:
                documentData.justifyOffset = 0;
            }
          }
          documentData.lineWidths = lineWidths;
          var animators = data2.a;
          var animatorData;
          var letterData;
          jLen = animators.length;
          var based;
          var ind;
          var indexes = [];
          for (j3 = 0; j3 < jLen; j3 += 1) {
            animatorData = animators[j3];
            if (animatorData.a.sc) {
              documentData.strokeColorAnim = true;
            }
            if (animatorData.a.sw) {
              documentData.strokeWidthAnim = true;
            }
            if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {
              documentData.fillColorAnim = true;
            }
            ind = 0;
            based = animatorData.s.b;
            for (i6 = 0; i6 < len; i6 += 1) {
              letterData = letters[i6];
              letterData.anIndexes[j3] = ind;
              if (based == 1 && letterData.val !== "" || based == 2 && letterData.val !== "" && letterData.val !== " " || based == 3 && (letterData.n || letterData.val == " " || i6 == len - 1) || based == 4 && (letterData.n || i6 == len - 1)) {
                if (animatorData.s.rn === 1) {
                  indexes.push(ind);
                }
                ind += 1;
              }
            }
            data2.a[j3].s.totalChars = ind;
            var currentInd = -1;
            var newInd;
            if (animatorData.s.rn === 1) {
              for (i6 = 0; i6 < len; i6 += 1) {
                letterData = letters[i6];
                if (currentInd != letterData.anIndexes[j3]) {
                  currentInd = letterData.anIndexes[j3];
                  newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];
                }
                letterData.anIndexes[j3] = newInd;
              }
            }
          }
          documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;
          documentData.ls = documentData.ls || 0;
          documentData.ascent = fontData.ascent * documentData.finalSize / 100;
        };
        TextProperty.prototype.updateDocumentData = function(newData, index2) {
          index2 = index2 === void 0 ? this.keysIndex : index2;
          var dData = this.copyData({}, this.data.d.k[index2].s);
          dData = this.copyData(dData, newData);
          this.data.d.k[index2].s = dData;
          this.recalculate(index2);
          this.setCurrentData(dData);
          this.elem.addDynamicProperty(this);
        };
        TextProperty.prototype.recalculate = function(index2) {
          var dData = this.data.d.k[index2].s;
          dData.__complete = false;
          this.keysIndex = 0;
          this._isFirstFrame = true;
          this.getValue(dData);
        };
        TextProperty.prototype.canResizeFont = function(_canResize) {
          this.canResize = _canResize;
          this.recalculate(this.keysIndex);
          this.elem.addDynamicProperty(this);
        };
        TextProperty.prototype.setMinimumFontSize = function(_fontValue) {
          this.minimumFontSize = Math.floor(_fontValue) || 1;
          this.recalculate(this.keysIndex);
          this.elem.addDynamicProperty(this);
        };
        var TextSelectorProp = function() {
          var max = Math.max;
          var min = Math.min;
          var floor = Math.floor;
          function TextSelectorPropFactory(elem2, data2) {
            this._currentTextLength = -1;
            this.k = false;
            this.data = data2;
            this.elem = elem2;
            this.comp = elem2.comp;
            this.finalS = 0;
            this.finalE = 0;
            this.initDynamicPropertyContainer(elem2);
            this.s = PropertyFactory.getProp(elem2, data2.s || {
              k: 0
            }, 0, 0, this);
            if ("e" in data2) {
              this.e = PropertyFactory.getProp(elem2, data2.e, 0, 0, this);
            } else {
              this.e = {
                v: 100
              };
            }
            this.o = PropertyFactory.getProp(elem2, data2.o || {
              k: 0
            }, 0, 0, this);
            this.xe = PropertyFactory.getProp(elem2, data2.xe || {
              k: 0
            }, 0, 0, this);
            this.ne = PropertyFactory.getProp(elem2, data2.ne || {
              k: 0
            }, 0, 0, this);
            this.sm = PropertyFactory.getProp(elem2, data2.sm || {
              k: 100
            }, 0, 0, this);
            this.a = PropertyFactory.getProp(elem2, data2.a, 0, 0.01, this);
            if (!this.dynamicProperties.length) {
              this.getValue();
            }
          }
          TextSelectorPropFactory.prototype = {
            getMult: function getMult(ind) {
              if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {
                this.getValue();
              }
              var x1 = 0;
              var y1 = 0;
              var x22 = 1;
              var y22 = 1;
              if (this.ne.v > 0) {
                x1 = this.ne.v / 100;
              } else {
                y1 = -this.ne.v / 100;
              }
              if (this.xe.v > 0) {
                x22 = 1 - this.xe.v / 100;
              } else {
                y22 = 1 + this.xe.v / 100;
              }
              var easer = BezierFactory.getBezierEasing(x1, y1, x22, y22).get;
              var mult = 0;
              var s4 = this.finalS;
              var e5 = this.finalE;
              var type = this.data.sh;
              if (type === 2) {
                if (e5 === s4) {
                  mult = ind >= e5 ? 1 : 0;
                } else {
                  mult = max(0, min(0.5 / (e5 - s4) + (ind - s4) / (e5 - s4), 1));
                }
                mult = easer(mult);
              } else if (type === 3) {
                if (e5 === s4) {
                  mult = ind >= e5 ? 0 : 1;
                } else {
                  mult = 1 - max(0, min(0.5 / (e5 - s4) + (ind - s4) / (e5 - s4), 1));
                }
                mult = easer(mult);
              } else if (type === 4) {
                if (e5 === s4) {
                  mult = 0;
                } else {
                  mult = max(0, min(0.5 / (e5 - s4) + (ind - s4) / (e5 - s4), 1));
                  if (mult < 0.5) {
                    mult *= 2;
                  } else {
                    mult = 1 - 2 * (mult - 0.5);
                  }
                }
                mult = easer(mult);
              } else if (type === 5) {
                if (e5 === s4) {
                  mult = 0;
                } else {
                  var tot = e5 - s4;
                  ind = min(max(0, ind + 0.5 - s4), e5 - s4);
                  var x3 = -tot / 2 + ind;
                  var a5 = tot / 2;
                  mult = Math.sqrt(1 - x3 * x3 / (a5 * a5));
                }
                mult = easer(mult);
              } else if (type === 6) {
                if (e5 === s4) {
                  mult = 0;
                } else {
                  ind = min(max(0, ind + 0.5 - s4), e5 - s4);
                  mult = (1 + Math.cos(Math.PI + Math.PI * 2 * ind / (e5 - s4))) / 2;
                }
                mult = easer(mult);
              } else {
                if (ind >= floor(s4)) {
                  if (ind - s4 < 0) {
                    mult = max(0, min(min(e5, 1) - (s4 - ind), 1));
                  } else {
                    mult = max(0, min(e5 - ind, 1));
                  }
                }
                mult = easer(mult);
              }
              if (this.sm.v !== 100) {
                var smoothness = this.sm.v * 0.01;
                if (smoothness === 0) {
                  smoothness = 1e-8;
                }
                var threshold = 0.5 - smoothness * 0.5;
                if (mult < threshold) {
                  mult = 0;
                } else {
                  mult = (mult - threshold) / smoothness;
                  if (mult > 1) {
                    mult = 1;
                  }
                }
              }
              return mult * this.a.v;
            },
            getValue: function getValue(newCharsFlag) {
              this.iterateDynamicProperties();
              this._mdf = newCharsFlag || this._mdf;
              this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;
              if (newCharsFlag && this.data.r === 2) {
                this.e.v = this._currentTextLength;
              }
              var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;
              var o5 = this.o.v / divisor;
              var s4 = this.s.v / divisor + o5;
              var e5 = this.e.v / divisor + o5;
              if (s4 > e5) {
                var _s = s4;
                s4 = e5;
                e5 = _s;
              }
              this.finalS = s4;
              this.finalE = e5;
            }
          };
          extendPrototype([DynamicPropertyContainer], TextSelectorPropFactory);
          function getTextSelectorProp(elem2, data2, arr) {
            return new TextSelectorPropFactory(elem2, data2, arr);
          }
          return {
            getTextSelectorProp
          };
        }();
        function TextAnimatorDataProperty(elem2, animatorProps, container) {
          var defaultData = {
            propType: false
          };
          var getProp = PropertyFactory.getProp;
          var textAnimatorAnimatables = animatorProps.a;
          this.a = {
            r: textAnimatorAnimatables.r ? getProp(elem2, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,
            rx: textAnimatorAnimatables.rx ? getProp(elem2, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,
            ry: textAnimatorAnimatables.ry ? getProp(elem2, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,
            sk: textAnimatorAnimatables.sk ? getProp(elem2, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,
            sa: textAnimatorAnimatables.sa ? getProp(elem2, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,
            s: textAnimatorAnimatables.s ? getProp(elem2, textAnimatorAnimatables.s, 1, 0.01, container) : defaultData,
            a: textAnimatorAnimatables.a ? getProp(elem2, textAnimatorAnimatables.a, 1, 0, container) : defaultData,
            o: textAnimatorAnimatables.o ? getProp(elem2, textAnimatorAnimatables.o, 0, 0.01, container) : defaultData,
            p: textAnimatorAnimatables.p ? getProp(elem2, textAnimatorAnimatables.p, 1, 0, container) : defaultData,
            sw: textAnimatorAnimatables.sw ? getProp(elem2, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,
            sc: textAnimatorAnimatables.sc ? getProp(elem2, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,
            fc: textAnimatorAnimatables.fc ? getProp(elem2, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,
            fh: textAnimatorAnimatables.fh ? getProp(elem2, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,
            fs: textAnimatorAnimatables.fs ? getProp(elem2, textAnimatorAnimatables.fs, 0, 0.01, container) : defaultData,
            fb: textAnimatorAnimatables.fb ? getProp(elem2, textAnimatorAnimatables.fb, 0, 0.01, container) : defaultData,
            t: textAnimatorAnimatables.t ? getProp(elem2, textAnimatorAnimatables.t, 0, 0, container) : defaultData
          };
          this.s = TextSelectorProp.getTextSelectorProp(elem2, animatorProps.s, container);
          this.s.t = animatorProps.s.t;
        }
        function TextAnimatorProperty(textData, renderType, elem2) {
          this._isFirstFrame = true;
          this._hasMaskedPath = false;
          this._frameId = -1;
          this._textData = textData;
          this._renderType = renderType;
          this._elem = elem2;
          this._animatorsData = createSizedArray(this._textData.a.length);
          this._pathData = {};
          this._moreOptions = {
            alignment: {}
          };
          this.renderedLetters = [];
          this.lettersChangedFlag = false;
          this.initDynamicPropertyContainer(elem2);
        }
        TextAnimatorProperty.prototype.searchProperties = function() {
          var i6;
          var len = this._textData.a.length;
          var animatorProps;
          var getProp = PropertyFactory.getProp;
          for (i6 = 0; i6 < len; i6 += 1) {
            animatorProps = this._textData.a[i6];
            this._animatorsData[i6] = new TextAnimatorDataProperty(this._elem, animatorProps, this);
          }
          if (this._textData.p && "m" in this._textData.p) {
            this._pathData = {
              a: getProp(this._elem, this._textData.p.a, 0, 0, this),
              f: getProp(this._elem, this._textData.p.f, 0, 0, this),
              l: getProp(this._elem, this._textData.p.l, 0, 0, this),
              r: getProp(this._elem, this._textData.p.r, 0, 0, this),
              p: getProp(this._elem, this._textData.p.p, 0, 0, this),
              m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
            };
            this._hasMaskedPath = true;
          } else {
            this._hasMaskedPath = false;
          }
          this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);
        };
        TextAnimatorProperty.prototype.getMeasures = function(documentData, lettersChangedFlag) {
          this.lettersChangedFlag = lettersChangedFlag;
          if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {
            return;
          }
          this._isFirstFrame = false;
          var alignment = this._moreOptions.alignment.v;
          var animators = this._animatorsData;
          var textData = this._textData;
          var matrixHelper = this.mHelper;
          var renderType = this._renderType;
          var renderedLettersCount = this.renderedLetters.length;
          var xPos;
          var yPos;
          var i6;
          var len;
          var letters = documentData.l;
          var pathInfo;
          var currentLength;
          var currentPoint;
          var segmentLength;
          var flag;
          var pointInd;
          var segmentInd;
          var prevPoint;
          var points;
          var segments;
          var partialLength;
          var totalLength;
          var perc;
          var tanAngle;
          var mask2;
          if (this._hasMaskedPath) {
            mask2 = this._pathData.m;
            if (!this._pathData.n || this._pathData._mdf) {
              var paths = mask2.v;
              if (this._pathData.r.v) {
                paths = paths.reverse();
              }
              pathInfo = {
                tLength: 0,
                segments: []
              };
              len = paths._length - 1;
              var bezierData;
              totalLength = 0;
              for (i6 = 0; i6 < len; i6 += 1) {
                bezierData = bez.buildBezierData(paths.v[i6], paths.v[i6 + 1], [paths.o[i6][0] - paths.v[i6][0], paths.o[i6][1] - paths.v[i6][1]], [paths.i[i6 + 1][0] - paths.v[i6 + 1][0], paths.i[i6 + 1][1] - paths.v[i6 + 1][1]]);
                pathInfo.tLength += bezierData.segmentLength;
                pathInfo.segments.push(bezierData);
                totalLength += bezierData.segmentLength;
              }
              i6 = len;
              if (mask2.v.c) {
                bezierData = bez.buildBezierData(paths.v[i6], paths.v[0], [paths.o[i6][0] - paths.v[i6][0], paths.o[i6][1] - paths.v[i6][1]], [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]);
                pathInfo.tLength += bezierData.segmentLength;
                pathInfo.segments.push(bezierData);
                totalLength += bezierData.segmentLength;
              }
              this._pathData.pi = pathInfo;
            }
            pathInfo = this._pathData.pi;
            currentLength = this._pathData.f.v;
            segmentInd = 0;
            pointInd = 1;
            segmentLength = 0;
            flag = true;
            segments = pathInfo.segments;
            if (currentLength < 0 && mask2.v.c) {
              if (pathInfo.tLength < Math.abs(currentLength)) {
                currentLength = -Math.abs(currentLength) % pathInfo.tLength;
              }
              segmentInd = segments.length - 1;
              points = segments[segmentInd].points;
              pointInd = points.length - 1;
              while (currentLength < 0) {
                currentLength += points[pointInd].partialLength;
                pointInd -= 1;
                if (pointInd < 0) {
                  segmentInd -= 1;
                  points = segments[segmentInd].points;
                  pointInd = points.length - 1;
                }
              }
            }
            points = segments[segmentInd].points;
            prevPoint = points[pointInd - 1];
            currentPoint = points[pointInd];
            partialLength = currentPoint.partialLength;
          }
          len = letters.length;
          xPos = 0;
          yPos = 0;
          var yOff = documentData.finalSize * 1.2 * 0.714;
          var firstLine = true;
          var animatorProps;
          var animatorSelector;
          var j3;
          var jLen;
          var letterValue;
          jLen = animators.length;
          var mult;
          var ind = -1;
          var offf;
          var xPathPos;
          var yPathPos;
          var initPathPos = currentLength;
          var initSegmentInd = segmentInd;
          var initPointInd = pointInd;
          var currentLine = -1;
          var elemOpacity;
          var sc;
          var sw;
          var fc;
          var k3;
          var letterSw;
          var letterSc;
          var letterFc;
          var letterM = "";
          var letterP = this.defaultPropsArray;
          var letterO;
          if (documentData.j === 2 || documentData.j === 1) {
            var animatorJustifyOffset = 0;
            var animatorFirstCharOffset = 0;
            var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;
            var lastIndex = 0;
            var isNewLine = true;
            for (i6 = 0; i6 < len; i6 += 1) {
              if (letters[i6].n) {
                if (animatorJustifyOffset) {
                  animatorJustifyOffset += animatorFirstCharOffset;
                }
                while (lastIndex < i6) {
                  letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
                  lastIndex += 1;
                }
                animatorJustifyOffset = 0;
                isNewLine = true;
              } else {
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  animatorProps = animators[j3].a;
                  if (animatorProps.t.propType) {
                    if (isNewLine && documentData.j === 2) {
                      animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;
                    }
                    animatorSelector = animators[j3].s;
                    mult = animatorSelector.getMult(letters[i6].anIndexes[j3], textData.a[j3].s.totalChars);
                    if (mult.length) {
                      animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;
                    } else {
                      animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;
                    }
                  }
                }
                isNewLine = false;
              }
            }
            if (animatorJustifyOffset) {
              animatorJustifyOffset += animatorFirstCharOffset;
            }
            while (lastIndex < i6) {
              letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
              lastIndex += 1;
            }
          }
          for (i6 = 0; i6 < len; i6 += 1) {
            matrixHelper.reset();
            elemOpacity = 1;
            if (letters[i6].n) {
              xPos = 0;
              yPos += documentData.yOffset;
              yPos += firstLine ? 1 : 0;
              currentLength = initPathPos;
              firstLine = false;
              if (this._hasMaskedPath) {
                segmentInd = initSegmentInd;
                pointInd = initPointInd;
                points = segments[segmentInd].points;
                prevPoint = points[pointInd - 1];
                currentPoint = points[pointInd];
                partialLength = currentPoint.partialLength;
                segmentLength = 0;
              }
              letterM = "";
              letterFc = "";
              letterSw = "";
              letterO = "";
              letterP = this.defaultPropsArray;
            } else {
              if (this._hasMaskedPath) {
                if (currentLine !== letters[i6].line) {
                  switch (documentData.j) {
                    case 1:
                      currentLength += totalLength - documentData.lineWidths[letters[i6].line];
                      break;
                    case 2:
                      currentLength += (totalLength - documentData.lineWidths[letters[i6].line]) / 2;
                      break;
                    default:
                      break;
                  }
                  currentLine = letters[i6].line;
                }
                if (ind !== letters[i6].ind) {
                  if (letters[ind]) {
                    currentLength += letters[ind].extra;
                  }
                  currentLength += letters[i6].an / 2;
                  ind = letters[i6].ind;
                }
                currentLength += alignment[0] * letters[i6].an * 5e-3;
                var animatorOffset = 0;
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  animatorProps = animators[j3].a;
                  if (animatorProps.p.propType) {
                    animatorSelector = animators[j3].s;
                    mult = animatorSelector.getMult(letters[i6].anIndexes[j3], textData.a[j3].s.totalChars);
                    if (mult.length) {
                      animatorOffset += animatorProps.p.v[0] * mult[0];
                    } else {
                      animatorOffset += animatorProps.p.v[0] * mult;
                    }
                  }
                  if (animatorProps.a.propType) {
                    animatorSelector = animators[j3].s;
                    mult = animatorSelector.getMult(letters[i6].anIndexes[j3], textData.a[j3].s.totalChars);
                    if (mult.length) {
                      animatorOffset += animatorProps.a.v[0] * mult[0];
                    } else {
                      animatorOffset += animatorProps.a.v[0] * mult;
                    }
                  }
                }
                flag = true;
                if (this._pathData.a.v) {
                  currentLength = letters[0].an * 0.5 + (totalLength - this._pathData.f.v - letters[0].an * 0.5 - letters[letters.length - 1].an * 0.5) * ind / (len - 1);
                  currentLength += this._pathData.f.v;
                }
                while (flag) {
                  if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
                    perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
                    xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
                    yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
                    matrixHelper.translate(-alignment[0] * letters[i6].an * 5e-3, -(alignment[1] * yOff) * 0.01);
                    flag = false;
                  } else if (points) {
                    segmentLength += currentPoint.partialLength;
                    pointInd += 1;
                    if (pointInd >= points.length) {
                      pointInd = 0;
                      segmentInd += 1;
                      if (!segments[segmentInd]) {
                        if (mask2.v.c) {
                          pointInd = 0;
                          segmentInd = 0;
                          points = segments[segmentInd].points;
                        } else {
                          segmentLength -= currentPoint.partialLength;
                          points = null;
                        }
                      } else {
                        points = segments[segmentInd].points;
                      }
                    }
                    if (points) {
                      prevPoint = currentPoint;
                      currentPoint = points[pointInd];
                      partialLength = currentPoint.partialLength;
                    }
                  }
                }
                offf = letters[i6].an / 2 - letters[i6].add;
                matrixHelper.translate(-offf, 0, 0);
              } else {
                offf = letters[i6].an / 2 - letters[i6].add;
                matrixHelper.translate(-offf, 0, 0);
                matrixHelper.translate(-alignment[0] * letters[i6].an * 5e-3, -alignment[1] * yOff * 0.01, 0);
              }
              for (j3 = 0; j3 < jLen; j3 += 1) {
                animatorProps = animators[j3].a;
                if (animatorProps.t.propType) {
                  animatorSelector = animators[j3].s;
                  mult = animatorSelector.getMult(letters[i6].anIndexes[j3], textData.a[j3].s.totalChars);
                  if (xPos !== 0 || documentData.j !== 0) {
                    if (this._hasMaskedPath) {
                      if (mult.length) {
                        currentLength += animatorProps.t.v * mult[0];
                      } else {
                        currentLength += animatorProps.t.v * mult;
                      }
                    } else if (mult.length) {
                      xPos += animatorProps.t.v * mult[0];
                    } else {
                      xPos += animatorProps.t.v * mult;
                    }
                  }
                }
              }
              if (documentData.strokeWidthAnim) {
                sw = documentData.sw || 0;
              }
              if (documentData.strokeColorAnim) {
                if (documentData.sc) {
                  sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];
                } else {
                  sc = [0, 0, 0];
                }
              }
              if (documentData.fillColorAnim && documentData.fc) {
                fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];
              }
              for (j3 = 0; j3 < jLen; j3 += 1) {
                animatorProps = animators[j3].a;
                if (animatorProps.a.propType) {
                  animatorSelector = animators[j3].s;
                  mult = animatorSelector.getMult(letters[i6].anIndexes[j3], textData.a[j3].s.totalChars);
                  if (mult.length) {
                    matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);
                  } else {
                    matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);
                  }
                }
              }
              for (j3 = 0; j3 < jLen; j3 += 1) {
                animatorProps = animators[j3].a;
                if (animatorProps.s.propType) {
                  animatorSelector = animators[j3].s;
                  mult = animatorSelector.getMult(letters[i6].anIndexes[j3], textData.a[j3].s.totalChars);
                  if (mult.length) {
                    matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult[0], 1 + (animatorProps.s.v[1] - 1) * mult[1], 1);
                  } else {
                    matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult, 1 + (animatorProps.s.v[1] - 1) * mult, 1);
                  }
                }
              }
              for (j3 = 0; j3 < jLen; j3 += 1) {
                animatorProps = animators[j3].a;
                animatorSelector = animators[j3].s;
                mult = animatorSelector.getMult(letters[i6].anIndexes[j3], textData.a[j3].s.totalChars);
                if (animatorProps.sk.propType) {
                  if (mult.length) {
                    matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);
                  } else {
                    matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
                  }
                }
                if (animatorProps.r.propType) {
                  if (mult.length) {
                    matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
                  } else {
                    matrixHelper.rotateZ(-animatorProps.r.v * mult);
                  }
                }
                if (animatorProps.ry.propType) {
                  if (mult.length) {
                    matrixHelper.rotateY(animatorProps.ry.v * mult[1]);
                  } else {
                    matrixHelper.rotateY(animatorProps.ry.v * mult);
                  }
                }
                if (animatorProps.rx.propType) {
                  if (mult.length) {
                    matrixHelper.rotateX(animatorProps.rx.v * mult[0]);
                  } else {
                    matrixHelper.rotateX(animatorProps.rx.v * mult);
                  }
                }
                if (animatorProps.o.propType) {
                  if (mult.length) {
                    elemOpacity += (animatorProps.o.v * mult[0] - elemOpacity) * mult[0];
                  } else {
                    elemOpacity += (animatorProps.o.v * mult - elemOpacity) * mult;
                  }
                }
                if (documentData.strokeWidthAnim && animatorProps.sw.propType) {
                  if (mult.length) {
                    sw += animatorProps.sw.v * mult[0];
                  } else {
                    sw += animatorProps.sw.v * mult;
                  }
                }
                if (documentData.strokeColorAnim && animatorProps.sc.propType) {
                  for (k3 = 0; k3 < 3; k3 += 1) {
                    if (mult.length) {
                      sc[k3] += (animatorProps.sc.v[k3] - sc[k3]) * mult[0];
                    } else {
                      sc[k3] += (animatorProps.sc.v[k3] - sc[k3]) * mult;
                    }
                  }
                }
                if (documentData.fillColorAnim && documentData.fc) {
                  if (animatorProps.fc.propType) {
                    for (k3 = 0; k3 < 3; k3 += 1) {
                      if (mult.length) {
                        fc[k3] += (animatorProps.fc.v[k3] - fc[k3]) * mult[0];
                      } else {
                        fc[k3] += (animatorProps.fc.v[k3] - fc[k3]) * mult;
                      }
                    }
                  }
                  if (animatorProps.fh.propType) {
                    if (mult.length) {
                      fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);
                    } else {
                      fc = addHueToRGB(fc, animatorProps.fh.v * mult);
                    }
                  }
                  if (animatorProps.fs.propType) {
                    if (mult.length) {
                      fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]);
                    } else {
                      fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);
                    }
                  }
                  if (animatorProps.fb.propType) {
                    if (mult.length) {
                      fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]);
                    } else {
                      fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);
                    }
                  }
                }
              }
              for (j3 = 0; j3 < jLen; j3 += 1) {
                animatorProps = animators[j3].a;
                if (animatorProps.p.propType) {
                  animatorSelector = animators[j3].s;
                  mult = animatorSelector.getMult(letters[i6].anIndexes[j3], textData.a[j3].s.totalChars);
                  if (this._hasMaskedPath) {
                    if (mult.length) {
                      matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);
                    } else {
                      matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                    }
                  } else if (mult.length) {
                    matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);
                  } else {
                    matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                  }
                }
              }
              if (documentData.strokeWidthAnim) {
                letterSw = sw < 0 ? 0 : sw;
              }
              if (documentData.strokeColorAnim) {
                letterSc = "rgb(" + Math.round(sc[0] * 255) + "," + Math.round(sc[1] * 255) + "," + Math.round(sc[2] * 255) + ")";
              }
              if (documentData.fillColorAnim && documentData.fc) {
                letterFc = "rgb(" + Math.round(fc[0] * 255) + "," + Math.round(fc[1] * 255) + "," + Math.round(fc[2] * 255) + ")";
              }
              if (this._hasMaskedPath) {
                matrixHelper.translate(0, -documentData.ls);
                matrixHelper.translate(0, alignment[1] * yOff * 0.01 + yPos, 0);
                if (this._pathData.p.v) {
                  tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
                  var rot = Math.atan(tanAngle) * 180 / Math.PI;
                  if (currentPoint.point[0] < prevPoint.point[0]) {
                    rot += 180;
                  }
                  matrixHelper.rotate(-rot * Math.PI / 180);
                }
                matrixHelper.translate(xPathPos, yPathPos, 0);
                currentLength -= alignment[0] * letters[i6].an * 5e-3;
                if (letters[i6 + 1] && ind !== letters[i6 + 1].ind) {
                  currentLength += letters[i6].an / 2;
                  currentLength += documentData.tr * 1e-3 * documentData.finalSize;
                }
              } else {
                matrixHelper.translate(xPos, yPos, 0);
                if (documentData.ps) {
                  matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
                }
                switch (documentData.j) {
                  case 1:
                    matrixHelper.translate(letters[i6].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i6].line]), 0, 0);
                    break;
                  case 2:
                    matrixHelper.translate(letters[i6].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i6].line]) / 2, 0, 0);
                    break;
                  default:
                    break;
                }
                matrixHelper.translate(0, -documentData.ls);
                matrixHelper.translate(offf, 0, 0);
                matrixHelper.translate(alignment[0] * letters[i6].an * 5e-3, alignment[1] * yOff * 0.01, 0);
                xPos += letters[i6].l + documentData.tr * 1e-3 * documentData.finalSize;
              }
              if (renderType === "html") {
                letterM = matrixHelper.toCSS();
              } else if (renderType === "svg") {
                letterM = matrixHelper.to2dCSS();
              } else {
                letterP = [matrixHelper.props[0], matrixHelper.props[1], matrixHelper.props[2], matrixHelper.props[3], matrixHelper.props[4], matrixHelper.props[5], matrixHelper.props[6], matrixHelper.props[7], matrixHelper.props[8], matrixHelper.props[9], matrixHelper.props[10], matrixHelper.props[11], matrixHelper.props[12], matrixHelper.props[13], matrixHelper.props[14], matrixHelper.props[15]];
              }
              letterO = elemOpacity;
            }
            if (renderedLettersCount <= i6) {
              letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);
              this.renderedLetters.push(letterValue);
              renderedLettersCount += 1;
              this.lettersChangedFlag = true;
            } else {
              letterValue = this.renderedLetters[i6];
              this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;
            }
          }
        };
        TextAnimatorProperty.prototype.getValue = function() {
          if (this._elem.globalData.frameId === this._frameId) {
            return;
          }
          this._frameId = this._elem.globalData.frameId;
          this.iterateDynamicProperties();
        };
        TextAnimatorProperty.prototype.mHelper = new Matrix();
        TextAnimatorProperty.prototype.defaultPropsArray = [];
        extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);
        function ITextElement() {
        }
        ITextElement.prototype.initElement = function(data2, globalData2, comp2) {
          this.lettersChangedFlag = true;
          this.initFrame();
          this.initBaseData(data2, globalData2, comp2);
          this.textProperty = new TextProperty(this, data2.t, this.dynamicProperties);
          this.textAnimator = new TextAnimatorProperty(data2.t, this.renderType, this);
          this.initTransform(data2, globalData2, comp2);
          this.initHierarchy();
          this.initRenderable();
          this.initRendererElement();
          this.createContainerElements();
          this.createRenderableComponents();
          this.createContent();
          this.hide();
          this.textAnimator.searchProperties(this.dynamicProperties);
        };
        ITextElement.prototype.prepareFrame = function(num) {
          this._mdf = false;
          this.prepareRenderableFrame(num);
          this.prepareProperties(num, this.isInRange);
        };
        ITextElement.prototype.createPathShape = function(matrixHelper, shapes) {
          var j3;
          var jLen = shapes.length;
          var pathNodes;
          var shapeStr = "";
          for (j3 = 0; j3 < jLen; j3 += 1) {
            if (shapes[j3].ty === "sh") {
              pathNodes = shapes[j3].ks.k;
              shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);
            }
          }
          return shapeStr;
        };
        ITextElement.prototype.updateDocumentData = function(newData, index2) {
          this.textProperty.updateDocumentData(newData, index2);
        };
        ITextElement.prototype.canResizeFont = function(_canResize) {
          this.textProperty.canResizeFont(_canResize);
        };
        ITextElement.prototype.setMinimumFontSize = function(_fontSize) {
          this.textProperty.setMinimumFontSize(_fontSize);
        };
        ITextElement.prototype.applyTextPropertiesToMatrix = function(documentData, matrixHelper, lineNumber, xPos, yPos) {
          if (documentData.ps) {
            matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
          }
          matrixHelper.translate(0, -documentData.ls, 0);
          switch (documentData.j) {
            case 1:
              matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);
              break;
            case 2:
              matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);
              break;
            default:
              break;
          }
          matrixHelper.translate(xPos, yPos, 0);
        };
        ITextElement.prototype.buildColor = function(colorData) {
          return "rgb(" + Math.round(colorData[0] * 255) + "," + Math.round(colorData[1] * 255) + "," + Math.round(colorData[2] * 255) + ")";
        };
        ITextElement.prototype.emptyProp = new LetterProps();
        ITextElement.prototype.destroy = function() {
        };
        ITextElement.prototype.validateText = function() {
          if (this.textProperty._mdf || this.textProperty._isFirstFrame) {
            this.buildNewText();
            this.textProperty._isFirstFrame = false;
            this.textProperty._mdf = false;
          }
        };
        var emptyShapeData = {
          shapes: []
        };
        function SVGTextLottieElement(data2, globalData2, comp2) {
          this.textSpans = [];
          this.renderType = "svg";
          this.initElement(data2, globalData2, comp2);
        }
        extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement);
        SVGTextLottieElement.prototype.createContent = function() {
          if (this.data.singleShape && !this.globalData.fontManager.chars) {
            this.textContainer = createNS("text");
          }
        };
        SVGTextLottieElement.prototype.buildTextContents = function(textArray) {
          var i6 = 0;
          var len = textArray.length;
          var textContents = [];
          var currentTextContent = "";
          while (i6 < len) {
            if (textArray[i6] === String.fromCharCode(13) || textArray[i6] === String.fromCharCode(3)) {
              textContents.push(currentTextContent);
              currentTextContent = "";
            } else {
              currentTextContent += textArray[i6];
            }
            i6 += 1;
          }
          textContents.push(currentTextContent);
          return textContents;
        };
        SVGTextLottieElement.prototype.buildShapeData = function(data2, scale2) {
          if (data2.shapes && data2.shapes.length) {
            var shape = data2.shapes[0];
            if (shape.it) {
              var shapeItem = shape.it[shape.it.length - 1];
              if (shapeItem.s) {
                shapeItem.s.k[0] = scale2;
                shapeItem.s.k[1] = scale2;
              }
            }
          }
          return data2;
        };
        SVGTextLottieElement.prototype.buildNewText = function() {
          this.addDynamicProperty(this);
          var i6;
          var len;
          var documentData = this.textProperty.currentData;
          this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);
          if (documentData.fc) {
            this.layerElement.setAttribute("fill", this.buildColor(documentData.fc));
          } else {
            this.layerElement.setAttribute("fill", "rgba(0,0,0,0)");
          }
          if (documentData.sc) {
            this.layerElement.setAttribute("stroke", this.buildColor(documentData.sc));
            this.layerElement.setAttribute("stroke-width", documentData.sw);
          }
          this.layerElement.setAttribute("font-size", documentData.finalSize);
          var fontData = this.globalData.fontManager.getFontByName(documentData.f);
          if (fontData.fClass) {
            this.layerElement.setAttribute("class", fontData.fClass);
          } else {
            this.layerElement.setAttribute("font-family", fontData.fFamily);
            var fWeight = documentData.fWeight;
            var fStyle = documentData.fStyle;
            this.layerElement.setAttribute("font-style", fStyle);
            this.layerElement.setAttribute("font-weight", fWeight);
          }
          this.layerElement.setAttribute("aria-label", documentData.t);
          var letters = documentData.l || [];
          var usesGlyphs = !!this.globalData.fontManager.chars;
          len = letters.length;
          var tSpan;
          var matrixHelper = this.mHelper;
          var shapeStr = "";
          var singleShape = this.data.singleShape;
          var xPos = 0;
          var yPos = 0;
          var firstLine = true;
          var trackingOffset = documentData.tr * 1e-3 * documentData.finalSize;
          if (singleShape && !usesGlyphs && !documentData.sz) {
            var tElement = this.textContainer;
            var justify = "start";
            switch (documentData.j) {
              case 1:
                justify = "end";
                break;
              case 2:
                justify = "middle";
                break;
              default:
                justify = "start";
                break;
            }
            tElement.setAttribute("text-anchor", justify);
            tElement.setAttribute("letter-spacing", trackingOffset);
            var textContent = this.buildTextContents(documentData.finalText);
            len = textContent.length;
            yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;
            for (i6 = 0; i6 < len; i6 += 1) {
              tSpan = this.textSpans[i6].span || createNS("tspan");
              tSpan.textContent = textContent[i6];
              tSpan.setAttribute("x", 0);
              tSpan.setAttribute("y", yPos);
              tSpan.style.display = "inherit";
              tElement.appendChild(tSpan);
              if (!this.textSpans[i6]) {
                this.textSpans[i6] = {
                  span: null,
                  glyph: null
                };
              }
              this.textSpans[i6].span = tSpan;
              yPos += documentData.finalLineHeight;
            }
            this.layerElement.appendChild(tElement);
          } else {
            var cachedSpansLength = this.textSpans.length;
            var charData;
            for (i6 = 0; i6 < len; i6 += 1) {
              if (!this.textSpans[i6]) {
                this.textSpans[i6] = {
                  span: null,
                  childSpan: null,
                  glyph: null
                };
              }
              if (!usesGlyphs || !singleShape || i6 === 0) {
                tSpan = cachedSpansLength > i6 ? this.textSpans[i6].span : createNS(usesGlyphs ? "g" : "text");
                if (cachedSpansLength <= i6) {
                  tSpan.setAttribute("stroke-linecap", "butt");
                  tSpan.setAttribute("stroke-linejoin", "round");
                  tSpan.setAttribute("stroke-miterlimit", "4");
                  this.textSpans[i6].span = tSpan;
                  if (usesGlyphs) {
                    var childSpan = createNS("g");
                    tSpan.appendChild(childSpan);
                    this.textSpans[i6].childSpan = childSpan;
                  }
                  this.textSpans[i6].span = tSpan;
                  this.layerElement.appendChild(tSpan);
                }
                tSpan.style.display = "inherit";
              }
              matrixHelper.reset();
              if (singleShape) {
                if (letters[i6].n) {
                  xPos = -trackingOffset;
                  yPos += documentData.yOffset;
                  yPos += firstLine ? 1 : 0;
                  firstLine = false;
                }
                this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i6].line, xPos, yPos);
                xPos += letters[i6].l || 0;
                xPos += trackingOffset;
              }
              if (usesGlyphs) {
                charData = this.globalData.fontManager.getCharData(documentData.finalText[i6], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
                var glyphElement;
                if (charData.t === 1) {
                  glyphElement = new SVGCompElement(charData.data, this.globalData, this);
                } else {
                  var data2 = emptyShapeData;
                  if (charData.data && charData.data.shapes) {
                    data2 = this.buildShapeData(charData.data, documentData.finalSize);
                  }
                  glyphElement = new SVGShapeElement(data2, this.globalData, this);
                }
                if (this.textSpans[i6].glyph) {
                  var glyph = this.textSpans[i6].glyph;
                  this.textSpans[i6].childSpan.removeChild(glyph.layerElement);
                  glyph.destroy();
                }
                this.textSpans[i6].glyph = glyphElement;
                glyphElement._debug = true;
                glyphElement.prepareFrame(0);
                glyphElement.renderFrame();
                this.textSpans[i6].childSpan.appendChild(glyphElement.layerElement);
                if (charData.t === 1) {
                  this.textSpans[i6].childSpan.setAttribute("transform", "scale(" + documentData.finalSize / 100 + "," + documentData.finalSize / 100 + ")");
                }
              } else {
                if (singleShape) {
                  tSpan.setAttribute("transform", "translate(" + matrixHelper.props[12] + "," + matrixHelper.props[13] + ")");
                }
                tSpan.textContent = letters[i6].val;
                tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
              }
            }
            if (singleShape && tSpan) {
              tSpan.setAttribute("d", shapeStr);
            }
          }
          while (i6 < this.textSpans.length) {
            this.textSpans[i6].span.style.display = "none";
            i6 += 1;
          }
          this._sizeChanged = true;
        };
        SVGTextLottieElement.prototype.sourceRectAtTime = function() {
          this.prepareFrame(this.comp.renderedFrame - this.data.st);
          this.renderInnerContent();
          if (this._sizeChanged) {
            this._sizeChanged = false;
            var textBox = this.layerElement.getBBox();
            this.bbox = {
              top: textBox.y,
              left: textBox.x,
              width: textBox.width,
              height: textBox.height
            };
          }
          return this.bbox;
        };
        SVGTextLottieElement.prototype.getValue = function() {
          var i6;
          var len = this.textSpans.length;
          var glyphElement;
          this.renderedFrame = this.comp.renderedFrame;
          for (i6 = 0; i6 < len; i6 += 1) {
            glyphElement = this.textSpans[i6].glyph;
            if (glyphElement) {
              glyphElement.prepareFrame(this.comp.renderedFrame - this.data.st);
              if (glyphElement._mdf) {
                this._mdf = true;
              }
            }
          }
        };
        SVGTextLottieElement.prototype.renderInnerContent = function() {
          this.validateText();
          if (!this.data.singleShape || this._mdf) {
            this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
            if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
              this._sizeChanged = true;
              var i6;
              var len;
              var renderedLetters = this.textAnimator.renderedLetters;
              var letters = this.textProperty.currentData.l;
              len = letters.length;
              var renderedLetter;
              var textSpan;
              var glyphElement;
              for (i6 = 0; i6 < len; i6 += 1) {
                if (!letters[i6].n) {
                  renderedLetter = renderedLetters[i6];
                  textSpan = this.textSpans[i6].span;
                  glyphElement = this.textSpans[i6].glyph;
                  if (glyphElement) {
                    glyphElement.renderFrame();
                  }
                  if (renderedLetter._mdf.m) {
                    textSpan.setAttribute("transform", renderedLetter.m);
                  }
                  if (renderedLetter._mdf.o) {
                    textSpan.setAttribute("opacity", renderedLetter.o);
                  }
                  if (renderedLetter._mdf.sw) {
                    textSpan.setAttribute("stroke-width", renderedLetter.sw);
                  }
                  if (renderedLetter._mdf.sc) {
                    textSpan.setAttribute("stroke", renderedLetter.sc);
                  }
                  if (renderedLetter._mdf.fc) {
                    textSpan.setAttribute("fill", renderedLetter.fc);
                  }
                }
              }
            }
          }
        };
        function ISolidElement(data2, globalData2, comp2) {
          this.initElement(data2, globalData2, comp2);
        }
        extendPrototype([IImageElement], ISolidElement);
        ISolidElement.prototype.createContent = function() {
          var rect = createNS("rect");
          rect.setAttribute("width", this.data.sw);
          rect.setAttribute("height", this.data.sh);
          rect.setAttribute("fill", this.data.sc);
          this.layerElement.appendChild(rect);
        };
        function NullElement(data2, globalData2, comp2) {
          this.initFrame();
          this.initBaseData(data2, globalData2, comp2);
          this.initFrame();
          this.initTransform(data2, globalData2, comp2);
          this.initHierarchy();
        }
        NullElement.prototype.prepareFrame = function(num) {
          this.prepareProperties(num, true);
        };
        NullElement.prototype.renderFrame = function() {
        };
        NullElement.prototype.getBaseElement = function() {
          return null;
        };
        NullElement.prototype.destroy = function() {
        };
        NullElement.prototype.sourceRectAtTime = function() {
        };
        NullElement.prototype.hide = function() {
        };
        extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);
        function SVGRendererBase() {
        }
        extendPrototype([BaseRenderer], SVGRendererBase);
        SVGRendererBase.prototype.createNull = function(data2) {
          return new NullElement(data2, this.globalData, this);
        };
        SVGRendererBase.prototype.createShape = function(data2) {
          return new SVGShapeElement(data2, this.globalData, this);
        };
        SVGRendererBase.prototype.createText = function(data2) {
          return new SVGTextLottieElement(data2, this.globalData, this);
        };
        SVGRendererBase.prototype.createImage = function(data2) {
          return new IImageElement(data2, this.globalData, this);
        };
        SVGRendererBase.prototype.createSolid = function(data2) {
          return new ISolidElement(data2, this.globalData, this);
        };
        SVGRendererBase.prototype.configAnimation = function(animData) {
          this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
          this.svgElement.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
          if (this.renderConfig.viewBoxSize) {
            this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize);
          } else {
            this.svgElement.setAttribute("viewBox", "0 0 " + animData.w + " " + animData.h);
          }
          if (!this.renderConfig.viewBoxOnly) {
            this.svgElement.setAttribute("width", animData.w);
            this.svgElement.setAttribute("height", animData.h);
            this.svgElement.style.width = "100%";
            this.svgElement.style.height = "100%";
            this.svgElement.style.transform = "translate3d(0,0,0)";
            this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility;
          }
          if (this.renderConfig.width) {
            this.svgElement.setAttribute("width", this.renderConfig.width);
          }
          if (this.renderConfig.height) {
            this.svgElement.setAttribute("height", this.renderConfig.height);
          }
          if (this.renderConfig.className) {
            this.svgElement.setAttribute("class", this.renderConfig.className);
          }
          if (this.renderConfig.id) {
            this.svgElement.setAttribute("id", this.renderConfig.id);
          }
          if (this.renderConfig.focusable !== void 0) {
            this.svgElement.setAttribute("focusable", this.renderConfig.focusable);
          }
          this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio);
          this.animationItem.wrapper.appendChild(this.svgElement);
          var defs = this.globalData.defs;
          this.setupGlobalData(animData, defs);
          this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
          this.data = animData;
          var maskElement = createNS("clipPath");
          var rect = createNS("rect");
          rect.setAttribute("width", animData.w);
          rect.setAttribute("height", animData.h);
          rect.setAttribute("x", 0);
          rect.setAttribute("y", 0);
          var maskId = createElementID();
          maskElement.setAttribute("id", maskId);
          maskElement.appendChild(rect);
          this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + maskId + ")");
          defs.appendChild(maskElement);
          this.layers = animData.layers;
          this.elements = createSizedArray(animData.layers.length);
        };
        SVGRendererBase.prototype.destroy = function() {
          if (this.animationItem.wrapper) {
            this.animationItem.wrapper.innerText = "";
          }
          this.layerElement = null;
          this.globalData.defs = null;
          var i6;
          var len = this.layers ? this.layers.length : 0;
          for (i6 = 0; i6 < len; i6 += 1) {
            if (this.elements[i6] && this.elements[i6].destroy) {
              this.elements[i6].destroy();
            }
          }
          this.elements.length = 0;
          this.destroyed = true;
          this.animationItem = null;
        };
        SVGRendererBase.prototype.updateContainerSize = function() {
        };
        SVGRendererBase.prototype.findIndexByInd = function(ind) {
          var i6 = 0;
          var len = this.layers.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            if (this.layers[i6].ind === ind) {
              return i6;
            }
          }
          return -1;
        };
        SVGRendererBase.prototype.buildItem = function(pos) {
          var elements = this.elements;
          if (elements[pos] || this.layers[pos].ty === 99) {
            return;
          }
          elements[pos] = true;
          var element = this.createItem(this.layers[pos]);
          elements[pos] = element;
          if (getExpressionsPlugin()) {
            if (this.layers[pos].ty === 0) {
              this.globalData.projectInterface.registerComposition(element);
            }
            element.initExpressions();
          }
          this.appendElementInPos(element, pos);
          if (this.layers[pos].tt) {
            var elementIndex2 = "tp" in this.layers[pos] ? this.findIndexByInd(this.layers[pos].tp) : pos - 1;
            if (elementIndex2 === -1) {
              return;
            }
            if (!this.elements[elementIndex2] || this.elements[elementIndex2] === true) {
              this.buildItem(elementIndex2);
              this.addPendingElement(element);
            } else {
              var matteElement = elements[elementIndex2];
              var matteMask = matteElement.getMatte(this.layers[pos].tt);
              element.setMatte(matteMask);
            }
          }
        };
        SVGRendererBase.prototype.checkPendingElements = function() {
          while (this.pendingElements.length) {
            var element = this.pendingElements.pop();
            element.checkParenting();
            if (element.data.tt) {
              var i6 = 0;
              var len = this.elements.length;
              while (i6 < len) {
                if (this.elements[i6] === element) {
                  var elementIndex2 = "tp" in element.data ? this.findIndexByInd(element.data.tp) : i6 - 1;
                  var matteElement = this.elements[elementIndex2];
                  var matteMask = matteElement.getMatte(this.layers[i6].tt);
                  element.setMatte(matteMask);
                  break;
                }
                i6 += 1;
              }
            }
          }
        };
        SVGRendererBase.prototype.renderFrame = function(num) {
          if (this.renderedFrame === num || this.destroyed) {
            return;
          }
          if (num === null) {
            num = this.renderedFrame;
          } else {
            this.renderedFrame = num;
          }
          this.globalData.frameNum = num;
          this.globalData.frameId += 1;
          this.globalData.projectInterface.currentFrame = num;
          this.globalData._mdf = false;
          var i6;
          var len = this.layers.length;
          if (!this.completeLayers) {
            this.checkLayers(num);
          }
          for (i6 = len - 1; i6 >= 0; i6 -= 1) {
            if (this.completeLayers || this.elements[i6]) {
              this.elements[i6].prepareFrame(num - this.layers[i6].st);
            }
          }
          if (this.globalData._mdf) {
            for (i6 = 0; i6 < len; i6 += 1) {
              if (this.completeLayers || this.elements[i6]) {
                this.elements[i6].renderFrame();
              }
            }
          }
        };
        SVGRendererBase.prototype.appendElementInPos = function(element, pos) {
          var newElement = element.getBaseElement();
          if (!newElement) {
            return;
          }
          var i6 = 0;
          var nextElement;
          while (i6 < pos) {
            if (this.elements[i6] && this.elements[i6] !== true && this.elements[i6].getBaseElement()) {
              nextElement = this.elements[i6].getBaseElement();
            }
            i6 += 1;
          }
          if (nextElement) {
            this.layerElement.insertBefore(newElement, nextElement);
          } else {
            this.layerElement.appendChild(newElement);
          }
        };
        SVGRendererBase.prototype.hide = function() {
          this.layerElement.style.display = "none";
        };
        SVGRendererBase.prototype.show = function() {
          this.layerElement.style.display = "block";
        };
        function ICompElement() {
        }
        extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement);
        ICompElement.prototype.initElement = function(data2, globalData2, comp2) {
          this.initFrame();
          this.initBaseData(data2, globalData2, comp2);
          this.initTransform(data2, globalData2, comp2);
          this.initRenderable();
          this.initHierarchy();
          this.initRendererElement();
          this.createContainerElements();
          this.createRenderableComponents();
          if (this.data.xt || !globalData2.progressiveLoad) {
            this.buildAllItems();
          }
          this.hide();
        };
        ICompElement.prototype.prepareFrame = function(num) {
          this._mdf = false;
          this.prepareRenderableFrame(num);
          this.prepareProperties(num, this.isInRange);
          if (!this.isInRange && !this.data.xt) {
            return;
          }
          if (!this.tm._placeholder) {
            var timeRemapped = this.tm.v;
            if (timeRemapped === this.data.op) {
              timeRemapped = this.data.op - 1;
            }
            this.renderedFrame = timeRemapped;
          } else {
            this.renderedFrame = num / this.data.sr;
          }
          var i6;
          var len = this.elements.length;
          if (!this.completeLayers) {
            this.checkLayers(this.renderedFrame);
          }
          for (i6 = len - 1; i6 >= 0; i6 -= 1) {
            if (this.completeLayers || this.elements[i6]) {
              this.elements[i6].prepareFrame(this.renderedFrame - this.layers[i6].st);
              if (this.elements[i6]._mdf) {
                this._mdf = true;
              }
            }
          }
        };
        ICompElement.prototype.renderInnerContent = function() {
          var i6;
          var len = this.layers.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            if (this.completeLayers || this.elements[i6]) {
              this.elements[i6].renderFrame();
            }
          }
        };
        ICompElement.prototype.setElements = function(elems) {
          this.elements = elems;
        };
        ICompElement.prototype.getElements = function() {
          return this.elements;
        };
        ICompElement.prototype.destroyElements = function() {
          var i6;
          var len = this.layers.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            if (this.elements[i6]) {
              this.elements[i6].destroy();
            }
          }
        };
        ICompElement.prototype.destroy = function() {
          this.destroyElements();
          this.destroyBaseElement();
        };
        function SVGCompElement(data2, globalData2, comp2) {
          this.layers = data2.layers;
          this.supports3d = true;
          this.completeLayers = false;
          this.pendingElements = [];
          this.elements = this.layers ? createSizedArray(this.layers.length) : [];
          this.initElement(data2, globalData2, comp2);
          this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
            _placeholder: true
          };
        }
        extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement);
        SVGCompElement.prototype.createComp = function(data2) {
          return new SVGCompElement(data2, this.globalData, this);
        };
        function SVGRenderer(animationItem, config3) {
          this.animationItem = animationItem;
          this.layers = null;
          this.renderedFrame = -1;
          this.svgElement = createNS("svg");
          var ariaLabel = "";
          if (config3 && config3.title) {
            var titleElement = createNS("title");
            var titleId = createElementID();
            titleElement.setAttribute("id", titleId);
            titleElement.textContent = config3.title;
            this.svgElement.appendChild(titleElement);
            ariaLabel += titleId;
          }
          if (config3 && config3.description) {
            var descElement = createNS("desc");
            var descId = createElementID();
            descElement.setAttribute("id", descId);
            descElement.textContent = config3.description;
            this.svgElement.appendChild(descElement);
            ariaLabel += " " + descId;
          }
          if (ariaLabel) {
            this.svgElement.setAttribute("aria-labelledby", ariaLabel);
          }
          var defs = createNS("defs");
          this.svgElement.appendChild(defs);
          var maskElement = createNS("g");
          this.svgElement.appendChild(maskElement);
          this.layerElement = maskElement;
          this.renderConfig = {
            preserveAspectRatio: config3 && config3.preserveAspectRatio || "xMidYMid meet",
            imagePreserveAspectRatio: config3 && config3.imagePreserveAspectRatio || "xMidYMid slice",
            contentVisibility: config3 && config3.contentVisibility || "visible",
            progressiveLoad: config3 && config3.progressiveLoad || false,
            hideOnTransparent: !(config3 && config3.hideOnTransparent === false),
            viewBoxOnly: config3 && config3.viewBoxOnly || false,
            viewBoxSize: config3 && config3.viewBoxSize || false,
            className: config3 && config3.className || "",
            id: config3 && config3.id || "",
            focusable: config3 && config3.focusable,
            filterSize: {
              width: config3 && config3.filterSize && config3.filterSize.width || "100%",
              height: config3 && config3.filterSize && config3.filterSize.height || "100%",
              x: config3 && config3.filterSize && config3.filterSize.x || "0%",
              y: config3 && config3.filterSize && config3.filterSize.y || "0%"
            },
            width: config3 && config3.width,
            height: config3 && config3.height,
            runExpressions: !config3 || config3.runExpressions === void 0 || config3.runExpressions
          };
          this.globalData = {
            _mdf: false,
            frameNum: -1,
            defs,
            renderConfig: this.renderConfig
          };
          this.elements = [];
          this.pendingElements = [];
          this.destroyed = false;
          this.rendererType = "svg";
        }
        extendPrototype([SVGRendererBase], SVGRenderer);
        SVGRenderer.prototype.createComp = function(data2) {
          return new SVGCompElement(data2, this.globalData, this);
        };
        function ShapeTransformManager() {
          this.sequences = {};
          this.sequenceList = [];
          this.transform_key_count = 0;
        }
        ShapeTransformManager.prototype = {
          addTransformSequence: function addTransformSequence(transforms) {
            var i6;
            var len = transforms.length;
            var key2 = "_";
            for (i6 = 0; i6 < len; i6 += 1) {
              key2 += transforms[i6].transform.key + "_";
            }
            var sequence = this.sequences[key2];
            if (!sequence) {
              sequence = {
                transforms: [].concat(transforms),
                finalTransform: new Matrix(),
                _mdf: false
              };
              this.sequences[key2] = sequence;
              this.sequenceList.push(sequence);
            }
            return sequence;
          },
          processSequence: function processSequence(sequence, isFirstFrame) {
            var i6 = 0;
            var len = sequence.transforms.length;
            var _mdf = isFirstFrame;
            while (i6 < len && !isFirstFrame) {
              if (sequence.transforms[i6].transform.mProps._mdf) {
                _mdf = true;
                break;
              }
              i6 += 1;
            }
            if (_mdf) {
              sequence.finalTransform.reset();
              for (i6 = len - 1; i6 >= 0; i6 -= 1) {
                sequence.finalTransform.multiply(sequence.transforms[i6].transform.mProps.v);
              }
            }
            sequence._mdf = _mdf;
          },
          processSequences: function processSequences(isFirstFrame) {
            var i6;
            var len = this.sequenceList.length;
            for (i6 = 0; i6 < len; i6 += 1) {
              this.processSequence(this.sequenceList[i6], isFirstFrame);
            }
          },
          getNewKey: function getNewKey() {
            this.transform_key_count += 1;
            return "_" + this.transform_key_count;
          }
        };
        var lumaLoader = function lumaLoader2() {
          var id = "__lottie_element_luma_buffer";
          var lumaBuffer = null;
          var lumaBufferCtx = null;
          var svg = null;
          function createLumaSvgFilter() {
            var _svg = createNS("svg");
            var fil = createNS("filter");
            var matrix = createNS("feColorMatrix");
            fil.setAttribute("id", id);
            matrix.setAttribute("type", "matrix");
            matrix.setAttribute("color-interpolation-filters", "sRGB");
            matrix.setAttribute("values", "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0");
            fil.appendChild(matrix);
            _svg.appendChild(fil);
            _svg.setAttribute("id", id + "_svg");
            if (featureSupport.svgLumaHidden) {
              _svg.style.display = "none";
            }
            return _svg;
          }
          function loadLuma() {
            if (!lumaBuffer) {
              svg = createLumaSvgFilter();
              document.body.appendChild(svg);
              lumaBuffer = createTag("canvas");
              lumaBufferCtx = lumaBuffer.getContext("2d");
              lumaBufferCtx.filter = "url(#" + id + ")";
              lumaBufferCtx.fillStyle = "rgba(0,0,0,0)";
              lumaBufferCtx.fillRect(0, 0, 1, 1);
            }
          }
          function getLuma(canvas) {
            if (!lumaBuffer) {
              loadLuma();
            }
            lumaBuffer.width = canvas.width;
            lumaBuffer.height = canvas.height;
            lumaBufferCtx.filter = "url(#" + id + ")";
            return lumaBuffer;
          }
          return {
            load: loadLuma,
            get: getLuma
          };
        };
        function createCanvas(width2, height2) {
          if (featureSupport.offscreenCanvas) {
            return new OffscreenCanvas(width2, height2);
          }
          var canvas = createTag("canvas");
          canvas.width = width2;
          canvas.height = height2;
          return canvas;
        }
        var assetLoader = function() {
          return {
            loadLumaCanvas: lumaLoader.load,
            getLumaCanvas: lumaLoader.get,
            createCanvas
          };
        }();
        var registeredEffects = {};
        function CVEffects(elem2) {
          var i6;
          var len = elem2.data.ef ? elem2.data.ef.length : 0;
          this.filters = [];
          var filterManager;
          for (i6 = 0; i6 < len; i6 += 1) {
            filterManager = null;
            var type = elem2.data.ef[i6].ty;
            if (registeredEffects[type]) {
              var Effect = registeredEffects[type].effect;
              filterManager = new Effect(elem2.effectsManager.effectElements[i6], elem2);
            }
            if (filterManager) {
              this.filters.push(filterManager);
            }
          }
          if (this.filters.length) {
            elem2.addRenderableComponent(this);
          }
        }
        CVEffects.prototype.renderFrame = function(_isFirstFrame) {
          var i6;
          var len = this.filters.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            this.filters[i6].renderFrame(_isFirstFrame);
          }
        };
        CVEffects.prototype.getEffects = function(type) {
          var i6;
          var len = this.filters.length;
          var effects = [];
          for (i6 = 0; i6 < len; i6 += 1) {
            if (this.filters[i6].type === type) {
              effects.push(this.filters[i6]);
            }
          }
          return effects;
        };
        function registerEffect(id, effect2) {
          registeredEffects[id] = {
            effect: effect2
          };
        }
        function CVMaskElement(data2, element) {
          this.data = data2;
          this.element = element;
          this.masksProperties = this.data.masksProperties || [];
          this.viewData = createSizedArray(this.masksProperties.length);
          var i6;
          var len = this.masksProperties.length;
          var hasMasks = false;
          for (i6 = 0; i6 < len; i6 += 1) {
            if (this.masksProperties[i6].mode !== "n") {
              hasMasks = true;
            }
            this.viewData[i6] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i6], 3);
          }
          this.hasMasks = hasMasks;
          if (hasMasks) {
            this.element.addRenderableComponent(this);
          }
        }
        CVMaskElement.prototype.renderFrame = function() {
          if (!this.hasMasks) {
            return;
          }
          var transform2 = this.element.finalTransform.mat;
          var ctx = this.element.canvasContext;
          var i6;
          var len = this.masksProperties.length;
          var pt;
          var pts;
          var data2;
          ctx.beginPath();
          for (i6 = 0; i6 < len; i6 += 1) {
            if (this.masksProperties[i6].mode !== "n") {
              if (this.masksProperties[i6].inv) {
                ctx.moveTo(0, 0);
                ctx.lineTo(this.element.globalData.compSize.w, 0);
                ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);
                ctx.lineTo(0, this.element.globalData.compSize.h);
                ctx.lineTo(0, 0);
              }
              data2 = this.viewData[i6].v;
              pt = transform2.applyToPointArray(data2.v[0][0], data2.v[0][1], 0);
              ctx.moveTo(pt[0], pt[1]);
              var j3;
              var jLen = data2._length;
              for (j3 = 1; j3 < jLen; j3 += 1) {
                pts = transform2.applyToTriplePoints(data2.o[j3 - 1], data2.i[j3], data2.v[j3]);
                ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
              }
              pts = transform2.applyToTriplePoints(data2.o[j3 - 1], data2.i[0], data2.v[0]);
              ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
            }
          }
          this.element.globalData.renderer.save(true);
          ctx.clip();
        };
        CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;
        CVMaskElement.prototype.destroy = function() {
          this.element = null;
        };
        function CVBaseElement() {
        }
        var operationsMap = {
          1: "source-in",
          2: "source-out",
          3: "source-in",
          4: "source-out"
        };
        CVBaseElement.prototype = {
          createElements: function createElements() {
          },
          initRendererElement: function initRendererElement() {
          },
          createContainerElements: function createContainerElements() {
            if (this.data.tt >= 1) {
              this.buffers = [];
              var canvasContext = this.globalData.canvasContext;
              var bufferCanvas = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
              this.buffers.push(bufferCanvas);
              var bufferCanvas2 = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
              this.buffers.push(bufferCanvas2);
              if (this.data.tt >= 3 && !document._isProxy) {
                assetLoader.loadLumaCanvas();
              }
            }
            this.canvasContext = this.globalData.canvasContext;
            this.transformCanvas = this.globalData.transformCanvas;
            this.renderableEffectsManager = new CVEffects(this);
            this.searchEffectTransforms();
          },
          createContent: function createContent() {
          },
          setBlendMode: function setBlendMode() {
            var globalData2 = this.globalData;
            if (globalData2.blendMode !== this.data.bm) {
              globalData2.blendMode = this.data.bm;
              var blendModeValue = getBlendMode(this.data.bm);
              globalData2.canvasContext.globalCompositeOperation = blendModeValue;
            }
          },
          createRenderableComponents: function createRenderableComponents() {
            this.maskManager = new CVMaskElement(this.data, this);
            this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
          },
          hideElement: function hideElement() {
            if (!this.hidden && (!this.isInRange || this.isTransparent)) {
              this.hidden = true;
            }
          },
          showElement: function showElement() {
            if (this.isInRange && !this.isTransparent) {
              this.hidden = false;
              this._isFirstFrame = true;
              this.maskManager._isFirstFrame = true;
            }
          },
          clearCanvas: function clearCanvas(canvasContext) {
            canvasContext.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy);
          },
          prepareLayer: function prepareLayer() {
            if (this.data.tt >= 1) {
              var buffer = this.buffers[0];
              var bufferCtx = buffer.getContext("2d");
              this.clearCanvas(bufferCtx);
              bufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
              this.currentTransform = this.canvasContext.getTransform();
              this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
              this.clearCanvas(this.canvasContext);
              this.canvasContext.setTransform(this.currentTransform);
            }
          },
          exitLayer: function exitLayer() {
            if (this.data.tt >= 1) {
              var buffer = this.buffers[1];
              var bufferCtx = buffer.getContext("2d");
              this.clearCanvas(bufferCtx);
              bufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
              this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
              this.clearCanvas(this.canvasContext);
              this.canvasContext.setTransform(this.currentTransform);
              var mask2 = this.comp.getElementById("tp" in this.data ? this.data.tp : this.data.ind - 1);
              mask2.renderFrame(true);
              this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
              if (this.data.tt >= 3 && !document._isProxy) {
                var lumaBuffer = assetLoader.getLumaCanvas(this.canvasContext.canvas);
                var lumaBufferCtx = lumaBuffer.getContext("2d");
                lumaBufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
                this.clearCanvas(this.canvasContext);
                this.canvasContext.drawImage(lumaBuffer, 0, 0);
              }
              this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt];
              this.canvasContext.drawImage(buffer, 0, 0);
              this.canvasContext.globalCompositeOperation = "destination-over";
              this.canvasContext.drawImage(this.buffers[0], 0, 0);
              this.canvasContext.setTransform(this.currentTransform);
              this.canvasContext.globalCompositeOperation = "source-over";
            }
          },
          renderFrame: function renderFrame(forceRender) {
            if (this.hidden || this.data.hd) {
              return;
            }
            if (this.data.td === 1 && !forceRender) {
              return;
            }
            this.renderTransform();
            this.renderRenderable();
            this.renderLocalTransform();
            this.setBlendMode();
            var forceRealStack = this.data.ty === 0;
            this.prepareLayer();
            this.globalData.renderer.save(forceRealStack);
            this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props);
            this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity);
            this.renderInnerContent();
            this.globalData.renderer.restore(forceRealStack);
            this.exitLayer();
            if (this.maskManager.hasMasks) {
              this.globalData.renderer.restore(true);
            }
            if (this._isFirstFrame) {
              this._isFirstFrame = false;
            }
          },
          destroy: function destroy() {
            this.canvasContext = null;
            this.data = null;
            this.globalData = null;
            this.maskManager.destroy();
          },
          mHelper: new Matrix()
        };
        CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;
        CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;
        function CVShapeData(element, data2, styles, transformsManager) {
          this.styledShapes = [];
          this.tr = [0, 0, 0, 0, 0, 0];
          var ty = 4;
          if (data2.ty === "rc") {
            ty = 5;
          } else if (data2.ty === "el") {
            ty = 6;
          } else if (data2.ty === "sr") {
            ty = 7;
          }
          this.sh = ShapePropertyFactory.getShapeProp(element, data2, ty, element);
          var i6;
          var len = styles.length;
          var styledShape;
          for (i6 = 0; i6 < len; i6 += 1) {
            if (!styles[i6].closed) {
              styledShape = {
                transforms: transformsManager.addTransformSequence(styles[i6].transforms),
                trNodes: []
              };
              this.styledShapes.push(styledShape);
              styles[i6].elements.push(styledShape);
            }
          }
        }
        CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;
        function CVShapeElement(data2, globalData2, comp2) {
          this.shapes = [];
          this.shapesData = data2.shapes;
          this.stylesList = [];
          this.itemsData = [];
          this.prevViewData = [];
          this.shapeModifiers = [];
          this.processedElements = [];
          this.transformsManager = new ShapeTransformManager();
          this.initElement(data2, globalData2, comp2);
        }
        extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement);
        CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;
        CVShapeElement.prototype.transformHelper = {
          opacity: 1,
          _opMdf: false
        };
        CVShapeElement.prototype.dashResetter = [];
        CVShapeElement.prototype.createContent = function() {
          this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
        };
        CVShapeElement.prototype.createStyleElement = function(data2, transforms) {
          var styleElem = {
            data: data2,
            type: data2.ty,
            preTransforms: this.transformsManager.addTransformSequence(transforms),
            transforms: [],
            elements: [],
            closed: data2.hd === true
          };
          var elementData = {};
          if (data2.ty === "fl" || data2.ty === "st") {
            elementData.c = PropertyFactory.getProp(this, data2.c, 1, 255, this);
            if (!elementData.c.k) {
              styleElem.co = "rgb(" + bmFloor(elementData.c.v[0]) + "," + bmFloor(elementData.c.v[1]) + "," + bmFloor(elementData.c.v[2]) + ")";
            }
          } else if (data2.ty === "gf" || data2.ty === "gs") {
            elementData.s = PropertyFactory.getProp(this, data2.s, 1, null, this);
            elementData.e = PropertyFactory.getProp(this, data2.e, 1, null, this);
            elementData.h = PropertyFactory.getProp(this, data2.h || {
              k: 0
            }, 0, 0.01, this);
            elementData.a = PropertyFactory.getProp(this, data2.a || {
              k: 0
            }, 0, degToRads, this);
            elementData.g = new GradientProperty(this, data2.g, this);
          }
          elementData.o = PropertyFactory.getProp(this, data2.o, 0, 0.01, this);
          if (data2.ty === "st" || data2.ty === "gs") {
            styleElem.lc = lineCapEnum[data2.lc || 2];
            styleElem.lj = lineJoinEnum[data2.lj || 2];
            if (data2.lj == 1) {
              styleElem.ml = data2.ml;
            }
            elementData.w = PropertyFactory.getProp(this, data2.w, 0, null, this);
            if (!elementData.w.k) {
              styleElem.wi = elementData.w.v;
            }
            if (data2.d) {
              var d3 = new DashProperty(this, data2.d, "canvas", this);
              elementData.d = d3;
              if (!elementData.d.k) {
                styleElem.da = elementData.d.dashArray;
                styleElem["do"] = elementData.d.dashoffset[0];
              }
            }
          } else {
            styleElem.r = data2.r === 2 ? "evenodd" : "nonzero";
          }
          this.stylesList.push(styleElem);
          elementData.style = styleElem;
          return elementData;
        };
        CVShapeElement.prototype.createGroupElement = function() {
          var elementData = {
            it: [],
            prevViewData: []
          };
          return elementData;
        };
        CVShapeElement.prototype.createTransformElement = function(data2) {
          var elementData = {
            transform: {
              opacity: 1,
              _opMdf: false,
              key: this.transformsManager.getNewKey(),
              op: PropertyFactory.getProp(this, data2.o, 0, 0.01, this),
              mProps: TransformPropertyFactory.getTransformProperty(this, data2, this)
            }
          };
          return elementData;
        };
        CVShapeElement.prototype.createShapeElement = function(data2) {
          var elementData = new CVShapeData(this, data2, this.stylesList, this.transformsManager);
          this.shapes.push(elementData);
          this.addShapeToModifiers(elementData);
          return elementData;
        };
        CVShapeElement.prototype.reloadShapes = function() {
          this._isFirstFrame = true;
          var i6;
          var len = this.itemsData.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            this.prevViewData[i6] = this.itemsData[i6];
          }
          this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
          len = this.dynamicProperties.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            this.dynamicProperties[i6].getValue();
          }
          this.renderModifiers();
          this.transformsManager.processSequences(this._isFirstFrame);
        };
        CVShapeElement.prototype.addTransformToStyleList = function(transform2) {
          var i6;
          var len = this.stylesList.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            if (!this.stylesList[i6].closed) {
              this.stylesList[i6].transforms.push(transform2);
            }
          }
        };
        CVShapeElement.prototype.removeTransformFromStyleList = function() {
          var i6;
          var len = this.stylesList.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            if (!this.stylesList[i6].closed) {
              this.stylesList[i6].transforms.pop();
            }
          }
        };
        CVShapeElement.prototype.closeStyles = function(styles) {
          var i6;
          var len = styles.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            styles[i6].closed = true;
          }
        };
        CVShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, shouldRender, transforms) {
          var i6;
          var len = arr.length - 1;
          var j3;
          var jLen;
          var ownStyles = [];
          var ownModifiers = [];
          var processedPos;
          var modifier;
          var currentTransform;
          var ownTransforms = [].concat(transforms);
          for (i6 = len; i6 >= 0; i6 -= 1) {
            processedPos = this.searchProcessedElement(arr[i6]);
            if (!processedPos) {
              arr[i6]._shouldRender = shouldRender;
            } else {
              itemsData[i6] = prevViewData[processedPos - 1];
            }
            if (arr[i6].ty === "fl" || arr[i6].ty === "st" || arr[i6].ty === "gf" || arr[i6].ty === "gs") {
              if (!processedPos) {
                itemsData[i6] = this.createStyleElement(arr[i6], ownTransforms);
              } else {
                itemsData[i6].style.closed = false;
              }
              ownStyles.push(itemsData[i6].style);
            } else if (arr[i6].ty === "gr") {
              if (!processedPos) {
                itemsData[i6] = this.createGroupElement(arr[i6]);
              } else {
                jLen = itemsData[i6].it.length;
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  itemsData[i6].prevViewData[j3] = itemsData[i6].it[j3];
                }
              }
              this.searchShapes(arr[i6].it, itemsData[i6].it, itemsData[i6].prevViewData, shouldRender, ownTransforms);
            } else if (arr[i6].ty === "tr") {
              if (!processedPos) {
                currentTransform = this.createTransformElement(arr[i6]);
                itemsData[i6] = currentTransform;
              }
              ownTransforms.push(itemsData[i6]);
              this.addTransformToStyleList(itemsData[i6]);
            } else if (arr[i6].ty === "sh" || arr[i6].ty === "rc" || arr[i6].ty === "el" || arr[i6].ty === "sr") {
              if (!processedPos) {
                itemsData[i6] = this.createShapeElement(arr[i6]);
              }
            } else if (arr[i6].ty === "tm" || arr[i6].ty === "rd" || arr[i6].ty === "pb" || arr[i6].ty === "zz" || arr[i6].ty === "op") {
              if (!processedPos) {
                modifier = ShapeModifiers.getModifier(arr[i6].ty);
                modifier.init(this, arr[i6]);
                itemsData[i6] = modifier;
                this.shapeModifiers.push(modifier);
              } else {
                modifier = itemsData[i6];
                modifier.closed = false;
              }
              ownModifiers.push(modifier);
            } else if (arr[i6].ty === "rp") {
              if (!processedPos) {
                modifier = ShapeModifiers.getModifier(arr[i6].ty);
                itemsData[i6] = modifier;
                modifier.init(this, arr, i6, itemsData);
                this.shapeModifiers.push(modifier);
                shouldRender = false;
              } else {
                modifier = itemsData[i6];
                modifier.closed = true;
              }
              ownModifiers.push(modifier);
            }
            this.addProcessedElement(arr[i6], i6 + 1);
          }
          this.removeTransformFromStyleList();
          this.closeStyles(ownStyles);
          len = ownModifiers.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            ownModifiers[i6].closed = true;
          }
        };
        CVShapeElement.prototype.renderInnerContent = function() {
          this.transformHelper.opacity = 1;
          this.transformHelper._opMdf = false;
          this.renderModifiers();
          this.transformsManager.processSequences(this._isFirstFrame);
          this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true);
        };
        CVShapeElement.prototype.renderShapeTransform = function(parentTransform, groupTransform) {
          if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {
            groupTransform.opacity = parentTransform.opacity;
            groupTransform.opacity *= groupTransform.op.v;
            groupTransform._opMdf = true;
          }
        };
        CVShapeElement.prototype.drawLayer = function() {
          var i6;
          var len = this.stylesList.length;
          var j3;
          var jLen;
          var k3;
          var kLen;
          var elems;
          var nodes;
          var renderer2 = this.globalData.renderer;
          var ctx = this.globalData.canvasContext;
          var type;
          var currentStyle;
          for (i6 = 0; i6 < len; i6 += 1) {
            currentStyle = this.stylesList[i6];
            type = currentStyle.type;
            if (!((type === "st" || type === "gs") && currentStyle.wi === 0 || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
              renderer2.save();
              elems = currentStyle.elements;
              if (type === "st" || type === "gs") {
                renderer2.ctxStrokeStyle(type === "st" ? currentStyle.co : currentStyle.grd);
                renderer2.ctxLineWidth(currentStyle.wi);
                renderer2.ctxLineCap(currentStyle.lc);
                renderer2.ctxLineJoin(currentStyle.lj);
                renderer2.ctxMiterLimit(currentStyle.ml || 0);
              } else {
                renderer2.ctxFillStyle(type === "fl" ? currentStyle.co : currentStyle.grd);
              }
              renderer2.ctxOpacity(currentStyle.coOp);
              if (type !== "st" && type !== "gs") {
                ctx.beginPath();
              }
              renderer2.ctxTransform(currentStyle.preTransforms.finalTransform.props);
              jLen = elems.length;
              for (j3 = 0; j3 < jLen; j3 += 1) {
                if (type === "st" || type === "gs") {
                  ctx.beginPath();
                  if (currentStyle.da) {
                    ctx.setLineDash(currentStyle.da);
                    ctx.lineDashOffset = currentStyle["do"];
                  }
                }
                nodes = elems[j3].trNodes;
                kLen = nodes.length;
                for (k3 = 0; k3 < kLen; k3 += 1) {
                  if (nodes[k3].t === "m") {
                    ctx.moveTo(nodes[k3].p[0], nodes[k3].p[1]);
                  } else if (nodes[k3].t === "c") {
                    ctx.bezierCurveTo(nodes[k3].pts[0], nodes[k3].pts[1], nodes[k3].pts[2], nodes[k3].pts[3], nodes[k3].pts[4], nodes[k3].pts[5]);
                  } else {
                    ctx.closePath();
                  }
                }
                if (type === "st" || type === "gs") {
                  renderer2.ctxStroke();
                  if (currentStyle.da) {
                    ctx.setLineDash(this.dashResetter);
                  }
                }
              }
              if (type !== "st" && type !== "gs") {
                this.globalData.renderer.ctxFill(currentStyle.r);
              }
              renderer2.restore();
            }
          }
        };
        CVShapeElement.prototype.renderShape = function(parentTransform, items, data2, isMain) {
          var i6;
          var len = items.length - 1;
          var groupTransform;
          groupTransform = parentTransform;
          for (i6 = len; i6 >= 0; i6 -= 1) {
            if (items[i6].ty === "tr") {
              groupTransform = data2[i6].transform;
              this.renderShapeTransform(parentTransform, groupTransform);
            } else if (items[i6].ty === "sh" || items[i6].ty === "el" || items[i6].ty === "rc" || items[i6].ty === "sr") {
              this.renderPath(items[i6], data2[i6]);
            } else if (items[i6].ty === "fl") {
              this.renderFill(items[i6], data2[i6], groupTransform);
            } else if (items[i6].ty === "st") {
              this.renderStroke(items[i6], data2[i6], groupTransform);
            } else if (items[i6].ty === "gf" || items[i6].ty === "gs") {
              this.renderGradientFill(items[i6], data2[i6], groupTransform);
            } else if (items[i6].ty === "gr") {
              this.renderShape(groupTransform, items[i6].it, data2[i6].it);
            } else if (items[i6].ty === "tm") {
            }
          }
          if (isMain) {
            this.drawLayer();
          }
        };
        CVShapeElement.prototype.renderStyledShape = function(styledShape, shape) {
          if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {
            var shapeNodes = styledShape.trNodes;
            var paths = shape.paths;
            var i6;
            var len;
            var j3;
            var jLen = paths._length;
            shapeNodes.length = 0;
            var groupTransformMat = styledShape.transforms.finalTransform;
            for (j3 = 0; j3 < jLen; j3 += 1) {
              var pathNodes = paths.shapes[j3];
              if (pathNodes && pathNodes.v) {
                len = pathNodes._length;
                for (i6 = 1; i6 < len; i6 += 1) {
                  if (i6 === 1) {
                    shapeNodes.push({
                      t: "m",
                      p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                    });
                  }
                  shapeNodes.push({
                    t: "c",
                    pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i6 - 1], pathNodes.i[i6], pathNodes.v[i6])
                  });
                }
                if (len === 1) {
                  shapeNodes.push({
                    t: "m",
                    p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                  });
                }
                if (pathNodes.c && len) {
                  shapeNodes.push({
                    t: "c",
                    pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i6 - 1], pathNodes.i[0], pathNodes.v[0])
                  });
                  shapeNodes.push({
                    t: "z"
                  });
                }
              }
            }
            styledShape.trNodes = shapeNodes;
          }
        };
        CVShapeElement.prototype.renderPath = function(pathData, itemData) {
          if (pathData.hd !== true && pathData._shouldRender) {
            var i6;
            var len = itemData.styledShapes.length;
            for (i6 = 0; i6 < len; i6 += 1) {
              this.renderStyledShape(itemData.styledShapes[i6], itemData.sh);
            }
          }
        };
        CVShapeElement.prototype.renderFill = function(styleData, itemData, groupTransform) {
          var styleElem = itemData.style;
          if (itemData.c._mdf || this._isFirstFrame) {
            styleElem.co = "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")";
          }
          if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
            styleElem.coOp = itemData.o.v * groupTransform.opacity;
          }
        };
        CVShapeElement.prototype.renderGradientFill = function(styleData, itemData, groupTransform) {
          var styleElem = itemData.style;
          var grd;
          if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf)) {
            var ctx = this.globalData.canvasContext;
            var pt1 = itemData.s.v;
            var pt2 = itemData.e.v;
            if (styleData.t === 1) {
              grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);
            } else {
              var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
              var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
              var percent = itemData.h.v;
              if (percent >= 1) {
                percent = 0.99;
              } else if (percent <= -1) {
                percent = -0.99;
              }
              var dist = rad * percent;
              var x3 = Math.cos(ang + itemData.a.v) * dist + pt1[0];
              var y3 = Math.sin(ang + itemData.a.v) * dist + pt1[1];
              grd = ctx.createRadialGradient(x3, y3, 0, pt1[0], pt1[1], rad);
            }
            var i6;
            var len = styleData.g.p;
            var cValues = itemData.g.c;
            var opacity = 1;
            for (i6 = 0; i6 < len; i6 += 1) {
              if (itemData.g._hasOpacity && itemData.g._collapsable) {
                opacity = itemData.g.o[i6 * 2 + 1];
              }
              grd.addColorStop(cValues[i6 * 4] / 100, "rgba(" + cValues[i6 * 4 + 1] + "," + cValues[i6 * 4 + 2] + "," + cValues[i6 * 4 + 3] + "," + opacity + ")");
            }
            styleElem.grd = grd;
          }
          styleElem.coOp = itemData.o.v * groupTransform.opacity;
        };
        CVShapeElement.prototype.renderStroke = function(styleData, itemData, groupTransform) {
          var styleElem = itemData.style;
          var d3 = itemData.d;
          if (d3 && (d3._mdf || this._isFirstFrame)) {
            styleElem.da = d3.dashArray;
            styleElem["do"] = d3.dashoffset[0];
          }
          if (itemData.c._mdf || this._isFirstFrame) {
            styleElem.co = "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")";
          }
          if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
            styleElem.coOp = itemData.o.v * groupTransform.opacity;
          }
          if (itemData.w._mdf || this._isFirstFrame) {
            styleElem.wi = itemData.w.v;
          }
        };
        CVShapeElement.prototype.destroy = function() {
          this.shapesData = null;
          this.globalData = null;
          this.canvasContext = null;
          this.stylesList.length = 0;
          this.itemsData.length = 0;
        };
        function CVTextElement(data2, globalData2, comp2) {
          this.textSpans = [];
          this.yOffset = 0;
          this.fillColorAnim = false;
          this.strokeColorAnim = false;
          this.strokeWidthAnim = false;
          this.stroke = false;
          this.fill = false;
          this.justifyOffset = 0;
          this.currentRender = null;
          this.renderType = "canvas";
          this.values = {
            fill: "rgba(0,0,0,0)",
            stroke: "rgba(0,0,0,0)",
            sWidth: 0,
            fValue: ""
          };
          this.initElement(data2, globalData2, comp2);
        }
        extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement);
        CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d");
        CVTextElement.prototype.buildNewText = function() {
          var documentData = this.textProperty.currentData;
          this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
          var hasFill = false;
          if (documentData.fc) {
            hasFill = true;
            this.values.fill = this.buildColor(documentData.fc);
          } else {
            this.values.fill = "rgba(0,0,0,0)";
          }
          this.fill = hasFill;
          var hasStroke = false;
          if (documentData.sc) {
            hasStroke = true;
            this.values.stroke = this.buildColor(documentData.sc);
            this.values.sWidth = documentData.sw;
          }
          var fontData = this.globalData.fontManager.getFontByName(documentData.f);
          var i6;
          var len;
          var letters = documentData.l;
          var matrixHelper = this.mHelper;
          this.stroke = hasStroke;
          this.values.fValue = documentData.finalSize + "px " + this.globalData.fontManager.getFontByName(documentData.f).fFamily;
          len = documentData.finalText.length;
          var charData;
          var shapeData;
          var k3;
          var kLen;
          var shapes;
          var j3;
          var jLen;
          var pathNodes;
          var commands;
          var pathArr;
          var singleShape = this.data.singleShape;
          var trackingOffset = documentData.tr * 1e-3 * documentData.finalSize;
          var xPos = 0;
          var yPos = 0;
          var firstLine = true;
          var cnt = 0;
          for (i6 = 0; i6 < len; i6 += 1) {
            charData = this.globalData.fontManager.getCharData(documentData.finalText[i6], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
            shapeData = charData && charData.data || {};
            matrixHelper.reset();
            if (singleShape && letters[i6].n) {
              xPos = -trackingOffset;
              yPos += documentData.yOffset;
              yPos += firstLine ? 1 : 0;
              firstLine = false;
            }
            shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
            jLen = shapes.length;
            matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
            if (singleShape) {
              this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i6].line, xPos, yPos);
            }
            commands = createSizedArray(jLen - 1);
            var commandsCounter = 0;
            for (j3 = 0; j3 < jLen; j3 += 1) {
              if (shapes[j3].ty === "sh") {
                kLen = shapes[j3].ks.k.i.length;
                pathNodes = shapes[j3].ks.k;
                pathArr = [];
                for (k3 = 1; k3 < kLen; k3 += 1) {
                  if (k3 === 1) {
                    pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
                  }
                  pathArr.push(matrixHelper.applyToX(pathNodes.o[k3 - 1][0], pathNodes.o[k3 - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k3 - 1][0], pathNodes.o[k3 - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k3][0], pathNodes.i[k3][1], 0), matrixHelper.applyToY(pathNodes.i[k3][0], pathNodes.i[k3][1], 0), matrixHelper.applyToX(pathNodes.v[k3][0], pathNodes.v[k3][1], 0), matrixHelper.applyToY(pathNodes.v[k3][0], pathNodes.v[k3][1], 0));
                }
                pathArr.push(matrixHelper.applyToX(pathNodes.o[k3 - 1][0], pathNodes.o[k3 - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k3 - 1][0], pathNodes.o[k3 - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
                commands[commandsCounter] = pathArr;
                commandsCounter += 1;
              }
            }
            if (singleShape) {
              xPos += letters[i6].l;
              xPos += trackingOffset;
            }
            if (this.textSpans[cnt]) {
              this.textSpans[cnt].elem = commands;
            } else {
              this.textSpans[cnt] = {
                elem: commands
              };
            }
            cnt += 1;
          }
        };
        CVTextElement.prototype.renderInnerContent = function() {
          this.validateText();
          var ctx = this.canvasContext;
          ctx.font = this.values.fValue;
          this.globalData.renderer.ctxLineCap("butt");
          this.globalData.renderer.ctxLineJoin("miter");
          this.globalData.renderer.ctxMiterLimit(4);
          if (!this.data.singleShape) {
            this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
          }
          var i6;
          var len;
          var j3;
          var jLen;
          var k3;
          var kLen;
          var renderedLetters = this.textAnimator.renderedLetters;
          var letters = this.textProperty.currentData.l;
          len = letters.length;
          var renderedLetter;
          var lastFill = null;
          var lastStroke = null;
          var lastStrokeW = null;
          var commands;
          var pathArr;
          var renderer2 = this.globalData.renderer;
          for (i6 = 0; i6 < len; i6 += 1) {
            if (!letters[i6].n) {
              renderedLetter = renderedLetters[i6];
              if (renderedLetter) {
                renderer2.save();
                renderer2.ctxTransform(renderedLetter.p);
                renderer2.ctxOpacity(renderedLetter.o);
              }
              if (this.fill) {
                if (renderedLetter && renderedLetter.fc) {
                  if (lastFill !== renderedLetter.fc) {
                    renderer2.ctxFillStyle(renderedLetter.fc);
                    lastFill = renderedLetter.fc;
                  }
                } else if (lastFill !== this.values.fill) {
                  lastFill = this.values.fill;
                  renderer2.ctxFillStyle(this.values.fill);
                }
                commands = this.textSpans[i6].elem;
                jLen = commands.length;
                this.globalData.canvasContext.beginPath();
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  pathArr = commands[j3];
                  kLen = pathArr.length;
                  this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
                  for (k3 = 2; k3 < kLen; k3 += 6) {
                    this.globalData.canvasContext.bezierCurveTo(pathArr[k3], pathArr[k3 + 1], pathArr[k3 + 2], pathArr[k3 + 3], pathArr[k3 + 4], pathArr[k3 + 5]);
                  }
                }
                this.globalData.canvasContext.closePath();
                renderer2.ctxFill();
              }
              if (this.stroke) {
                if (renderedLetter && renderedLetter.sw) {
                  if (lastStrokeW !== renderedLetter.sw) {
                    lastStrokeW = renderedLetter.sw;
                    renderer2.ctxLineWidth(renderedLetter.sw);
                  }
                } else if (lastStrokeW !== this.values.sWidth) {
                  lastStrokeW = this.values.sWidth;
                  renderer2.ctxLineWidth(this.values.sWidth);
                }
                if (renderedLetter && renderedLetter.sc) {
                  if (lastStroke !== renderedLetter.sc) {
                    lastStroke = renderedLetter.sc;
                    renderer2.ctxStrokeStyle(renderedLetter.sc);
                  }
                } else if (lastStroke !== this.values.stroke) {
                  lastStroke = this.values.stroke;
                  renderer2.ctxStrokeStyle(this.values.stroke);
                }
                commands = this.textSpans[i6].elem;
                jLen = commands.length;
                this.globalData.canvasContext.beginPath();
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  pathArr = commands[j3];
                  kLen = pathArr.length;
                  this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
                  for (k3 = 2; k3 < kLen; k3 += 6) {
                    this.globalData.canvasContext.bezierCurveTo(pathArr[k3], pathArr[k3 + 1], pathArr[k3 + 2], pathArr[k3 + 3], pathArr[k3 + 4], pathArr[k3 + 5]);
                  }
                }
                this.globalData.canvasContext.closePath();
                renderer2.ctxStroke();
              }
              if (renderedLetter) {
                this.globalData.renderer.restore();
              }
            }
          }
        };
        function CVImageElement(data2, globalData2, comp2) {
          this.assetData = globalData2.getAssetData(data2.refId);
          this.img = globalData2.imageLoader.getAsset(this.assetData);
          this.initElement(data2, globalData2, comp2);
        }
        extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement);
        CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;
        CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
        CVImageElement.prototype.createContent = function() {
          if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
            var canvas = createTag("canvas");
            canvas.width = this.assetData.w;
            canvas.height = this.assetData.h;
            var ctx = canvas.getContext("2d");
            var imgW = this.img.width;
            var imgH = this.img.height;
            var imgRel = imgW / imgH;
            var canvasRel = this.assetData.w / this.assetData.h;
            var widthCrop;
            var heightCrop;
            var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
            if (imgRel > canvasRel && par === "xMidYMid slice" || imgRel < canvasRel && par !== "xMidYMid slice") {
              heightCrop = imgH;
              widthCrop = heightCrop * canvasRel;
            } else {
              widthCrop = imgW;
              heightCrop = widthCrop / canvasRel;
            }
            ctx.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h);
            this.img = canvas;
          }
        };
        CVImageElement.prototype.renderInnerContent = function() {
          this.canvasContext.drawImage(this.img, 0, 0);
        };
        CVImageElement.prototype.destroy = function() {
          this.img = null;
        };
        function CVSolidElement(data2, globalData2, comp2) {
          this.initElement(data2, globalData2, comp2);
        }
        extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement);
        CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;
        CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
        CVSolidElement.prototype.renderInnerContent = function() {
          this.globalData.renderer.ctxFillStyle(this.data.sc);
          this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh);
        };
        function CanvasRendererBase() {
        }
        extendPrototype([BaseRenderer], CanvasRendererBase);
        CanvasRendererBase.prototype.createShape = function(data2) {
          return new CVShapeElement(data2, this.globalData, this);
        };
        CanvasRendererBase.prototype.createText = function(data2) {
          return new CVTextElement(data2, this.globalData, this);
        };
        CanvasRendererBase.prototype.createImage = function(data2) {
          return new CVImageElement(data2, this.globalData, this);
        };
        CanvasRendererBase.prototype.createSolid = function(data2) {
          return new CVSolidElement(data2, this.globalData, this);
        };
        CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
        CanvasRendererBase.prototype.ctxTransform = function(props) {
          if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) {
            return;
          }
          this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13]);
        };
        CanvasRendererBase.prototype.ctxOpacity = function(op) {
          this.canvasContext.globalAlpha *= op < 0 ? 0 : op;
        };
        CanvasRendererBase.prototype.ctxFillStyle = function(value2) {
          this.canvasContext.fillStyle = value2;
        };
        CanvasRendererBase.prototype.ctxStrokeStyle = function(value2) {
          this.canvasContext.strokeStyle = value2;
        };
        CanvasRendererBase.prototype.ctxLineWidth = function(value2) {
          this.canvasContext.lineWidth = value2;
        };
        CanvasRendererBase.prototype.ctxLineCap = function(value2) {
          this.canvasContext.lineCap = value2;
        };
        CanvasRendererBase.prototype.ctxLineJoin = function(value2) {
          this.canvasContext.lineJoin = value2;
        };
        CanvasRendererBase.prototype.ctxMiterLimit = function(value2) {
          this.canvasContext.miterLimit = value2;
        };
        CanvasRendererBase.prototype.ctxFill = function(rule) {
          this.canvasContext.fill(rule);
        };
        CanvasRendererBase.prototype.ctxFillRect = function(x3, y3, w3, h2) {
          this.canvasContext.fillRect(x3, y3, w3, h2);
        };
        CanvasRendererBase.prototype.ctxStroke = function() {
          this.canvasContext.stroke();
        };
        CanvasRendererBase.prototype.reset = function() {
          if (!this.renderConfig.clearCanvas) {
            this.canvasContext.restore();
            return;
          }
          this.contextData.reset();
        };
        CanvasRendererBase.prototype.save = function() {
          this.canvasContext.save();
        };
        CanvasRendererBase.prototype.restore = function(actionFlag) {
          if (!this.renderConfig.clearCanvas) {
            this.canvasContext.restore();
            return;
          }
          if (actionFlag) {
            this.globalData.blendMode = "source-over";
          }
          this.contextData.restore(actionFlag);
        };
        CanvasRendererBase.prototype.configAnimation = function(animData) {
          if (this.animationItem.wrapper) {
            this.animationItem.container = createTag("canvas");
            var containerStyle = this.animationItem.container.style;
            containerStyle.width = "100%";
            containerStyle.height = "100%";
            var origin = "0px 0px 0px";
            containerStyle.transformOrigin = origin;
            containerStyle.mozTransformOrigin = origin;
            containerStyle.webkitTransformOrigin = origin;
            containerStyle["-webkit-transform"] = origin;
            containerStyle.contentVisibility = this.renderConfig.contentVisibility;
            this.animationItem.wrapper.appendChild(this.animationItem.container);
            this.canvasContext = this.animationItem.container.getContext("2d");
            if (this.renderConfig.className) {
              this.animationItem.container.setAttribute("class", this.renderConfig.className);
            }
            if (this.renderConfig.id) {
              this.animationItem.container.setAttribute("id", this.renderConfig.id);
            }
          } else {
            this.canvasContext = this.renderConfig.context;
          }
          this.contextData.setContext(this.canvasContext);
          this.data = animData;
          this.layers = animData.layers;
          this.transformCanvas = {
            w: animData.w,
            h: animData.h,
            sx: 0,
            sy: 0,
            tx: 0,
            ty: 0
          };
          this.setupGlobalData(animData, document.body);
          this.globalData.canvasContext = this.canvasContext;
          this.globalData.renderer = this;
          this.globalData.isDashed = false;
          this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
          this.globalData.transformCanvas = this.transformCanvas;
          this.elements = createSizedArray(animData.layers.length);
          this.updateContainerSize();
        };
        CanvasRendererBase.prototype.updateContainerSize = function(width2, height2) {
          this.reset();
          var elementWidth;
          var elementHeight;
          if (width2) {
            elementWidth = width2;
            elementHeight = height2;
            this.canvasContext.canvas.width = elementWidth;
            this.canvasContext.canvas.height = elementHeight;
          } else {
            if (this.animationItem.wrapper && this.animationItem.container) {
              elementWidth = this.animationItem.wrapper.offsetWidth;
              elementHeight = this.animationItem.wrapper.offsetHeight;
            } else {
              elementWidth = this.canvasContext.canvas.width;
              elementHeight = this.canvasContext.canvas.height;
            }
            this.canvasContext.canvas.width = elementWidth * this.renderConfig.dpr;
            this.canvasContext.canvas.height = elementHeight * this.renderConfig.dpr;
          }
          var elementRel;
          var animationRel;
          if (this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 || this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1) {
            var par = this.renderConfig.preserveAspectRatio.split(" ");
            var fillType = par[1] || "meet";
            var pos = par[0] || "xMidYMid";
            var xPos = pos.substr(0, 4);
            var yPos = pos.substr(4);
            elementRel = elementWidth / elementHeight;
            animationRel = this.transformCanvas.w / this.transformCanvas.h;
            if (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice") {
              this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
              this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
            } else {
              this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
              this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
            }
            if (xPos === "xMid" && (animationRel < elementRel && fillType === "meet" || animationRel > elementRel && fillType === "slice")) {
              this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2 * this.renderConfig.dpr;
            } else if (xPos === "xMax" && (animationRel < elementRel && fillType === "meet" || animationRel > elementRel && fillType === "slice")) {
              this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr;
            } else {
              this.transformCanvas.tx = 0;
            }
            if (yPos === "YMid" && (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice")) {
              this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2 * this.renderConfig.dpr;
            } else if (yPos === "YMax" && (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice")) {
              this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) * this.renderConfig.dpr;
            } else {
              this.transformCanvas.ty = 0;
            }
          } else if (this.renderConfig.preserveAspectRatio === "none") {
            this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
            this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
            this.transformCanvas.tx = 0;
            this.transformCanvas.ty = 0;
          } else {
            this.transformCanvas.sx = this.renderConfig.dpr;
            this.transformCanvas.sy = this.renderConfig.dpr;
            this.transformCanvas.tx = 0;
            this.transformCanvas.ty = 0;
          }
          this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1];
          this.ctxTransform(this.transformCanvas.props);
          this.canvasContext.beginPath();
          this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
          this.canvasContext.closePath();
          this.canvasContext.clip();
          this.renderFrame(this.renderedFrame, true);
        };
        CanvasRendererBase.prototype.destroy = function() {
          if (this.renderConfig.clearCanvas && this.animationItem.wrapper) {
            this.animationItem.wrapper.innerText = "";
          }
          var i6;
          var len = this.layers ? this.layers.length : 0;
          for (i6 = len - 1; i6 >= 0; i6 -= 1) {
            if (this.elements[i6] && this.elements[i6].destroy) {
              this.elements[i6].destroy();
            }
          }
          this.elements.length = 0;
          this.globalData.canvasContext = null;
          this.animationItem.container = null;
          this.destroyed = true;
        };
        CanvasRendererBase.prototype.renderFrame = function(num, forceRender) {
          if (this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender || this.destroyed || num === -1) {
            return;
          }
          this.renderedFrame = num;
          this.globalData.frameNum = num - this.animationItem._isFirstFrame;
          this.globalData.frameId += 1;
          this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;
          this.globalData.projectInterface.currentFrame = num;
          var i6;
          var len = this.layers.length;
          if (!this.completeLayers) {
            this.checkLayers(num);
          }
          for (i6 = len - 1; i6 >= 0; i6 -= 1) {
            if (this.completeLayers || this.elements[i6]) {
              this.elements[i6].prepareFrame(num - this.layers[i6].st);
            }
          }
          if (this.globalData._mdf) {
            if (this.renderConfig.clearCanvas === true) {
              this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
            } else {
              this.save();
            }
            for (i6 = len - 1; i6 >= 0; i6 -= 1) {
              if (this.completeLayers || this.elements[i6]) {
                this.elements[i6].renderFrame();
              }
            }
            if (this.renderConfig.clearCanvas !== true) {
              this.restore();
            }
          }
        };
        CanvasRendererBase.prototype.buildItem = function(pos) {
          var elements = this.elements;
          if (elements[pos] || this.layers[pos].ty === 99) {
            return;
          }
          var element = this.createItem(this.layers[pos], this, this.globalData);
          elements[pos] = element;
          element.initExpressions();
        };
        CanvasRendererBase.prototype.checkPendingElements = function() {
          while (this.pendingElements.length) {
            var element = this.pendingElements.pop();
            element.checkParenting();
          }
        };
        CanvasRendererBase.prototype.hide = function() {
          this.animationItem.container.style.display = "none";
        };
        CanvasRendererBase.prototype.show = function() {
          this.animationItem.container.style.display = "block";
        };
        function CanvasContext() {
          this.opacity = -1;
          this.transform = createTypedArray("float32", 16);
          this.fillStyle = "";
          this.strokeStyle = "";
          this.lineWidth = "";
          this.lineCap = "";
          this.lineJoin = "";
          this.miterLimit = "";
          this.id = Math.random();
        }
        function CVContextData() {
          this.stack = [];
          this.cArrPos = 0;
          this.cTr = new Matrix();
          var i6;
          var len = 15;
          for (i6 = 0; i6 < len; i6 += 1) {
            var canvasContext = new CanvasContext();
            this.stack[i6] = canvasContext;
          }
          this._length = len;
          this.nativeContext = null;
          this.transformMat = new Matrix();
          this.currentOpacity = 1;
          this.currentFillStyle = "";
          this.appliedFillStyle = "";
          this.currentStrokeStyle = "";
          this.appliedStrokeStyle = "";
          this.currentLineWidth = "";
          this.appliedLineWidth = "";
          this.currentLineCap = "";
          this.appliedLineCap = "";
          this.currentLineJoin = "";
          this.appliedLineJoin = "";
          this.appliedMiterLimit = "";
          this.currentMiterLimit = "";
        }
        CVContextData.prototype.duplicate = function() {
          var newLength = this._length * 2;
          var i6 = 0;
          for (i6 = this._length; i6 < newLength; i6 += 1) {
            this.stack[i6] = new CanvasContext();
          }
          this._length = newLength;
        };
        CVContextData.prototype.reset = function() {
          this.cArrPos = 0;
          this.cTr.reset();
          this.stack[this.cArrPos].opacity = 1;
        };
        CVContextData.prototype.restore = function(forceRestore) {
          this.cArrPos -= 1;
          var currentContext = this.stack[this.cArrPos];
          var transform2 = currentContext.transform;
          var i6;
          var arr = this.cTr.props;
          for (i6 = 0; i6 < 16; i6 += 1) {
            arr[i6] = transform2[i6];
          }
          if (forceRestore) {
            this.nativeContext.restore();
            var prevStack = this.stack[this.cArrPos + 1];
            this.appliedFillStyle = prevStack.fillStyle;
            this.appliedStrokeStyle = prevStack.strokeStyle;
            this.appliedLineWidth = prevStack.lineWidth;
            this.appliedLineCap = prevStack.lineCap;
            this.appliedLineJoin = prevStack.lineJoin;
            this.appliedMiterLimit = prevStack.miterLimit;
          }
          this.nativeContext.setTransform(transform2[0], transform2[1], transform2[4], transform2[5], transform2[12], transform2[13]);
          if (forceRestore || currentContext.opacity !== -1 && this.currentOpacity !== currentContext.opacity) {
            this.nativeContext.globalAlpha = currentContext.opacity;
            this.currentOpacity = currentContext.opacity;
          }
          this.currentFillStyle = currentContext.fillStyle;
          this.currentStrokeStyle = currentContext.strokeStyle;
          this.currentLineWidth = currentContext.lineWidth;
          this.currentLineCap = currentContext.lineCap;
          this.currentLineJoin = currentContext.lineJoin;
          this.currentMiterLimit = currentContext.miterLimit;
        };
        CVContextData.prototype.save = function(saveOnNativeFlag) {
          if (saveOnNativeFlag) {
            this.nativeContext.save();
          }
          var props = this.cTr.props;
          if (this._length <= this.cArrPos) {
            this.duplicate();
          }
          var currentStack = this.stack[this.cArrPos];
          var i6;
          for (i6 = 0; i6 < 16; i6 += 1) {
            currentStack.transform[i6] = props[i6];
          }
          this.cArrPos += 1;
          var newStack = this.stack[this.cArrPos];
          newStack.opacity = currentStack.opacity;
          newStack.fillStyle = currentStack.fillStyle;
          newStack.strokeStyle = currentStack.strokeStyle;
          newStack.lineWidth = currentStack.lineWidth;
          newStack.lineCap = currentStack.lineCap;
          newStack.lineJoin = currentStack.lineJoin;
          newStack.miterLimit = currentStack.miterLimit;
        };
        CVContextData.prototype.setOpacity = function(value2) {
          this.stack[this.cArrPos].opacity = value2;
        };
        CVContextData.prototype.setContext = function(value2) {
          this.nativeContext = value2;
        };
        CVContextData.prototype.fillStyle = function(value2) {
          if (this.stack[this.cArrPos].fillStyle !== value2) {
            this.currentFillStyle = value2;
            this.stack[this.cArrPos].fillStyle = value2;
          }
        };
        CVContextData.prototype.strokeStyle = function(value2) {
          if (this.stack[this.cArrPos].strokeStyle !== value2) {
            this.currentStrokeStyle = value2;
            this.stack[this.cArrPos].strokeStyle = value2;
          }
        };
        CVContextData.prototype.lineWidth = function(value2) {
          if (this.stack[this.cArrPos].lineWidth !== value2) {
            this.currentLineWidth = value2;
            this.stack[this.cArrPos].lineWidth = value2;
          }
        };
        CVContextData.prototype.lineCap = function(value2) {
          if (this.stack[this.cArrPos].lineCap !== value2) {
            this.currentLineCap = value2;
            this.stack[this.cArrPos].lineCap = value2;
          }
        };
        CVContextData.prototype.lineJoin = function(value2) {
          if (this.stack[this.cArrPos].lineJoin !== value2) {
            this.currentLineJoin = value2;
            this.stack[this.cArrPos].lineJoin = value2;
          }
        };
        CVContextData.prototype.miterLimit = function(value2) {
          if (this.stack[this.cArrPos].miterLimit !== value2) {
            this.currentMiterLimit = value2;
            this.stack[this.cArrPos].miterLimit = value2;
          }
        };
        CVContextData.prototype.transform = function(props) {
          this.transformMat.cloneFromProps(props);
          var currentTransform = this.cTr;
          this.transformMat.multiply(currentTransform);
          currentTransform.cloneFromProps(this.transformMat.props);
          var trProps = currentTransform.props;
          this.nativeContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13]);
        };
        CVContextData.prototype.opacity = function(op) {
          var currentOpacity = this.stack[this.cArrPos].opacity;
          currentOpacity *= op < 0 ? 0 : op;
          if (this.stack[this.cArrPos].opacity !== currentOpacity) {
            if (this.currentOpacity !== op) {
              this.nativeContext.globalAlpha = op;
              this.currentOpacity = op;
            }
            this.stack[this.cArrPos].opacity = currentOpacity;
          }
        };
        CVContextData.prototype.fill = function(rule) {
          if (this.appliedFillStyle !== this.currentFillStyle) {
            this.appliedFillStyle = this.currentFillStyle;
            this.nativeContext.fillStyle = this.appliedFillStyle;
          }
          this.nativeContext.fill(rule);
        };
        CVContextData.prototype.fillRect = function(x3, y3, w3, h2) {
          if (this.appliedFillStyle !== this.currentFillStyle) {
            this.appliedFillStyle = this.currentFillStyle;
            this.nativeContext.fillStyle = this.appliedFillStyle;
          }
          this.nativeContext.fillRect(x3, y3, w3, h2);
        };
        CVContextData.prototype.stroke = function() {
          if (this.appliedStrokeStyle !== this.currentStrokeStyle) {
            this.appliedStrokeStyle = this.currentStrokeStyle;
            this.nativeContext.strokeStyle = this.appliedStrokeStyle;
          }
          if (this.appliedLineWidth !== this.currentLineWidth) {
            this.appliedLineWidth = this.currentLineWidth;
            this.nativeContext.lineWidth = this.appliedLineWidth;
          }
          if (this.appliedLineCap !== this.currentLineCap) {
            this.appliedLineCap = this.currentLineCap;
            this.nativeContext.lineCap = this.appliedLineCap;
          }
          if (this.appliedLineJoin !== this.currentLineJoin) {
            this.appliedLineJoin = this.currentLineJoin;
            this.nativeContext.lineJoin = this.appliedLineJoin;
          }
          if (this.appliedMiterLimit !== this.currentMiterLimit) {
            this.appliedMiterLimit = this.currentMiterLimit;
            this.nativeContext.miterLimit = this.appliedMiterLimit;
          }
          this.nativeContext.stroke();
        };
        function CVCompElement(data2, globalData2, comp2) {
          this.completeLayers = false;
          this.layers = data2.layers;
          this.pendingElements = [];
          this.elements = createSizedArray(this.layers.length);
          this.initElement(data2, globalData2, comp2);
          this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
            _placeholder: true
          };
        }
        extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement);
        CVCompElement.prototype.renderInnerContent = function() {
          var ctx = this.canvasContext;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(this.data.w, 0);
          ctx.lineTo(this.data.w, this.data.h);
          ctx.lineTo(0, this.data.h);
          ctx.lineTo(0, 0);
          ctx.clip();
          var i6;
          var len = this.layers.length;
          for (i6 = len - 1; i6 >= 0; i6 -= 1) {
            if (this.completeLayers || this.elements[i6]) {
              this.elements[i6].renderFrame();
            }
          }
        };
        CVCompElement.prototype.destroy = function() {
          var i6;
          var len = this.layers.length;
          for (i6 = len - 1; i6 >= 0; i6 -= 1) {
            if (this.elements[i6]) {
              this.elements[i6].destroy();
            }
          }
          this.layers = null;
          this.elements = null;
        };
        CVCompElement.prototype.createComp = function(data2) {
          return new CVCompElement(data2, this.globalData, this);
        };
        function CanvasRenderer(animationItem, config3) {
          this.animationItem = animationItem;
          this.renderConfig = {
            clearCanvas: config3 && config3.clearCanvas !== void 0 ? config3.clearCanvas : true,
            context: config3 && config3.context || null,
            progressiveLoad: config3 && config3.progressiveLoad || false,
            preserveAspectRatio: config3 && config3.preserveAspectRatio || "xMidYMid meet",
            imagePreserveAspectRatio: config3 && config3.imagePreserveAspectRatio || "xMidYMid slice",
            contentVisibility: config3 && config3.contentVisibility || "visible",
            className: config3 && config3.className || "",
            id: config3 && config3.id || "",
            runExpressions: !config3 || config3.runExpressions === void 0 || config3.runExpressions
          };
          this.renderConfig.dpr = config3 && config3.dpr || 1;
          if (this.animationItem.wrapper) {
            this.renderConfig.dpr = config3 && config3.dpr || window.devicePixelRatio || 1;
          }
          this.renderedFrame = -1;
          this.globalData = {
            frameNum: -1,
            _mdf: false,
            renderConfig: this.renderConfig,
            currentGlobalAlpha: -1
          };
          this.contextData = new CVContextData();
          this.elements = [];
          this.pendingElements = [];
          this.transformMat = new Matrix();
          this.completeLayers = false;
          this.rendererType = "canvas";
          if (this.renderConfig.clearCanvas) {
            this.ctxTransform = this.contextData.transform.bind(this.contextData);
            this.ctxOpacity = this.contextData.opacity.bind(this.contextData);
            this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData);
            this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData);
            this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData);
            this.ctxLineCap = this.contextData.lineCap.bind(this.contextData);
            this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData);
            this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData);
            this.ctxFill = this.contextData.fill.bind(this.contextData);
            this.ctxFillRect = this.contextData.fillRect.bind(this.contextData);
            this.ctxStroke = this.contextData.stroke.bind(this.contextData);
            this.save = this.contextData.save.bind(this.contextData);
          }
        }
        extendPrototype([CanvasRendererBase], CanvasRenderer);
        CanvasRenderer.prototype.createComp = function(data2) {
          return new CVCompElement(data2, this.globalData, this);
        };
        function HBaseElement() {
        }
        HBaseElement.prototype = {
          checkBlendMode: function checkBlendMode() {
          },
          initRendererElement: function initRendererElement() {
            this.baseElement = createTag(this.data.tg || "div");
            if (this.data.hasMask) {
              this.svgElement = createNS("svg");
              this.layerElement = createNS("g");
              this.maskedElement = this.layerElement;
              this.svgElement.appendChild(this.layerElement);
              this.baseElement.appendChild(this.svgElement);
            } else {
              this.layerElement = this.baseElement;
            }
            styleDiv(this.baseElement);
          },
          createContainerElements: function createContainerElements() {
            this.renderableEffectsManager = new CVEffects(this);
            this.transformedElement = this.baseElement;
            this.maskedElement = this.layerElement;
            if (this.data.ln) {
              this.layerElement.setAttribute("id", this.data.ln);
            }
            if (this.data.cl) {
              this.layerElement.setAttribute("class", this.data.cl);
            }
            if (this.data.bm !== 0) {
              this.setBlendMode();
            }
          },
          renderElement: function renderElement() {
            var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};
            if (this.finalTransform._matMdf) {
              var matrixValue = this.finalTransform.mat.toCSS();
              transformedElementStyle.transform = matrixValue;
              transformedElementStyle.webkitTransform = matrixValue;
            }
            if (this.finalTransform._opMdf) {
              transformedElementStyle.opacity = this.finalTransform.mProp.o.v;
            }
          },
          renderFrame: function renderFrame() {
            if (this.data.hd || this.hidden) {
              return;
            }
            this.renderTransform();
            this.renderRenderable();
            this.renderElement();
            this.renderInnerContent();
            if (this._isFirstFrame) {
              this._isFirstFrame = false;
            }
          },
          destroy: function destroy() {
            this.layerElement = null;
            this.transformedElement = null;
            if (this.matteElement) {
              this.matteElement = null;
            }
            if (this.maskManager) {
              this.maskManager.destroy();
              this.maskManager = null;
            }
          },
          createRenderableComponents: function createRenderableComponents() {
            this.maskManager = new MaskElement(this.data, this, this.globalData);
          },
          addEffects: function addEffects() {
          },
          setMatte: function setMatte() {
          }
        };
        HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;
        HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;
        HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;
        function HSolidElement(data2, globalData2, comp2) {
          this.initElement(data2, globalData2, comp2);
        }
        extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement);
        HSolidElement.prototype.createContent = function() {
          var rect;
          if (this.data.hasMask) {
            rect = createNS("rect");
            rect.setAttribute("width", this.data.sw);
            rect.setAttribute("height", this.data.sh);
            rect.setAttribute("fill", this.data.sc);
            this.svgElement.setAttribute("width", this.data.sw);
            this.svgElement.setAttribute("height", this.data.sh);
          } else {
            rect = createTag("div");
            rect.style.width = this.data.sw + "px";
            rect.style.height = this.data.sh + "px";
            rect.style.backgroundColor = this.data.sc;
          }
          this.layerElement.appendChild(rect);
        };
        function HShapeElement(data2, globalData2, comp2) {
          this.shapes = [];
          this.shapesData = data2.shapes;
          this.stylesList = [];
          this.shapeModifiers = [];
          this.itemsData = [];
          this.processedElements = [];
          this.animatedContents = [];
          this.shapesContainer = createNS("g");
          this.initElement(data2, globalData2, comp2);
          this.prevViewData = [];
          this.currentBBox = {
            x: 999999,
            y: -999999,
            h: 0,
            w: 0
          };
        }
        extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement);
        HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;
        HShapeElement.prototype.createContent = function() {
          var cont;
          this.baseElement.style.fontSize = 0;
          if (this.data.hasMask) {
            this.layerElement.appendChild(this.shapesContainer);
            cont = this.svgElement;
          } else {
            cont = createNS("svg");
            var size = this.comp.data ? this.comp.data : this.globalData.compSize;
            cont.setAttribute("width", size.w);
            cont.setAttribute("height", size.h);
            cont.appendChild(this.shapesContainer);
            this.layerElement.appendChild(cont);
          }
          this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], true);
          this.filterUniqueShapes();
          this.shapeCont = cont;
        };
        HShapeElement.prototype.getTransformedPoint = function(transformers, point) {
          var i6;
          var len = transformers.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            point = transformers[i6].mProps.v.applyToPointArray(point[0], point[1], 0);
          }
          return point;
        };
        HShapeElement.prototype.calculateShapeBoundingBox = function(item, boundingBox) {
          var shape = item.sh.v;
          var transformers = item.transformers;
          var i6;
          var len = shape._length;
          var vPoint;
          var oPoint;
          var nextIPoint;
          var nextVPoint;
          if (len <= 1) {
            return;
          }
          for (i6 = 0; i6 < len - 1; i6 += 1) {
            vPoint = this.getTransformedPoint(transformers, shape.v[i6]);
            oPoint = this.getTransformedPoint(transformers, shape.o[i6]);
            nextIPoint = this.getTransformedPoint(transformers, shape.i[i6 + 1]);
            nextVPoint = this.getTransformedPoint(transformers, shape.v[i6 + 1]);
            this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
          }
          if (shape.c) {
            vPoint = this.getTransformedPoint(transformers, shape.v[i6]);
            oPoint = this.getTransformedPoint(transformers, shape.o[i6]);
            nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);
            nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);
            this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
          }
        };
        HShapeElement.prototype.checkBounds = function(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {
          this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);
          var bounds = this.shapeBoundingBox;
          boundingBox.x = bmMin(bounds.left, boundingBox.x);
          boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax);
          boundingBox.y = bmMin(bounds.top, boundingBox.y);
          boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax);
        };
        HShapeElement.prototype.shapeBoundingBox = {
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        };
        HShapeElement.prototype.tempBoundingBox = {
          x: 0,
          xMax: 0,
          y: 0,
          yMax: 0,
          width: 0,
          height: 0
        };
        HShapeElement.prototype.getBoundsOfCurve = function(p0, p1, p22, p3) {
          var bounds = [[p0[0], p3[0]], [p0[1], p3[1]]];
          for (var a5, b3, c4, t4, b2ac, t1, t22, i6 = 0; i6 < 2; ++i6) {
            b3 = 6 * p0[i6] - 12 * p1[i6] + 6 * p22[i6];
            a5 = -3 * p0[i6] + 9 * p1[i6] - 9 * p22[i6] + 3 * p3[i6];
            c4 = 3 * p1[i6] - 3 * p0[i6];
            b3 |= 0;
            a5 |= 0;
            c4 |= 0;
            if (a5 === 0 && b3 === 0) {
            } else if (a5 === 0) {
              t4 = -c4 / b3;
              if (t4 > 0 && t4 < 1) {
                bounds[i6].push(this.calculateF(t4, p0, p1, p22, p3, i6));
              }
            } else {
              b2ac = b3 * b3 - 4 * c4 * a5;
              if (b2ac >= 0) {
                t1 = (-b3 + bmSqrt(b2ac)) / (2 * a5);
                if (t1 > 0 && t1 < 1) bounds[i6].push(this.calculateF(t1, p0, p1, p22, p3, i6));
                t22 = (-b3 - bmSqrt(b2ac)) / (2 * a5);
                if (t22 > 0 && t22 < 1) bounds[i6].push(this.calculateF(t22, p0, p1, p22, p3, i6));
              }
            }
          }
          this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]);
          this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]);
          this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]);
          this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1]);
        };
        HShapeElement.prototype.calculateF = function(t4, p0, p1, p22, p3, i6) {
          return bmPow(1 - t4, 3) * p0[i6] + 3 * bmPow(1 - t4, 2) * t4 * p1[i6] + 3 * (1 - t4) * bmPow(t4, 2) * p22[i6] + bmPow(t4, 3) * p3[i6];
        };
        HShapeElement.prototype.calculateBoundingBox = function(itemsData, boundingBox) {
          var i6;
          var len = itemsData.length;
          for (i6 = 0; i6 < len; i6 += 1) {
            if (itemsData[i6] && itemsData[i6].sh) {
              this.calculateShapeBoundingBox(itemsData[i6], boundingBox);
            } else if (itemsData[i6] && itemsData[i6].it) {
              this.calculateBoundingBox(itemsData[i6].it, boundingBox);
            } else if (itemsData[i6] && itemsData[i6].style && itemsData[i6].w) {
              this.expandStrokeBoundingBox(itemsData[i6].w, boundingBox);
            }
          }
        };
        HShapeElement.prototype.expandStrokeBoundingBox = function(widthProperty, boundingBox) {
          var width2 = 0;
          if (widthProperty.keyframes) {
            for (var i6 = 0; i6 < widthProperty.keyframes.length; i6 += 1) {
              var kfw = widthProperty.keyframes[i6].s;
              if (kfw > width2) {
                width2 = kfw;
              }
            }
            width2 *= widthProperty.mult;
          } else {
            width2 = widthProperty.v * widthProperty.mult;
          }
          boundingBox.x -= width2;
          boundingBox.xMax += width2;
          boundingBox.y -= width2;
          boundingBox.yMax += width2;
        };
        HShapeElement.prototype.currentBoxContains = function(box) {
          return this.currentBBox.x <= box.x && this.currentBBox.y <= box.y && this.currentBBox.width + this.currentBBox.x >= box.x + box.width && this.currentBBox.height + this.currentBBox.y >= box.y + box.height;
        };
        HShapeElement.prototype.renderInnerContent = function() {
          this._renderShapeFrame();
          if (!this.hidden && (this._isFirstFrame || this._mdf)) {
            var tempBoundingBox = this.tempBoundingBox;
            var max = 999999;
            tempBoundingBox.x = max;
            tempBoundingBox.xMax = -max;
            tempBoundingBox.y = max;
            tempBoundingBox.yMax = -max;
            this.calculateBoundingBox(this.itemsData, tempBoundingBox);
            tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;
            tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y;
            if (this.currentBoxContains(tempBoundingBox)) {
              return;
            }
            var changed = false;
            if (this.currentBBox.w !== tempBoundingBox.width) {
              this.currentBBox.w = tempBoundingBox.width;
              this.shapeCont.setAttribute("width", tempBoundingBox.width);
              changed = true;
            }
            if (this.currentBBox.h !== tempBoundingBox.height) {
              this.currentBBox.h = tempBoundingBox.height;
              this.shapeCont.setAttribute("height", tempBoundingBox.height);
              changed = true;
            }
            if (changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {
              this.currentBBox.w = tempBoundingBox.width;
              this.currentBBox.h = tempBoundingBox.height;
              this.currentBBox.x = tempBoundingBox.x;
              this.currentBBox.y = tempBoundingBox.y;
              this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
              var shapeStyle = this.shapeCont.style;
              var shapeTransform = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
              shapeStyle.transform = shapeTransform;
              shapeStyle.webkitTransform = shapeTransform;
            }
          }
        };
        function HTextElement(data2, globalData2, comp2) {
          this.textSpans = [];
          this.textPaths = [];
          this.currentBBox = {
            x: 999999,
            y: -999999,
            h: 0,
            w: 0
          };
          this.renderType = "svg";
          this.isMasked = false;
          this.initElement(data2, globalData2, comp2);
        }
        extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement);
        HTextElement.prototype.createContent = function() {
          this.isMasked = this.checkMasks();
          if (this.isMasked) {
            this.renderType = "svg";
            this.compW = this.comp.data.w;
            this.compH = this.comp.data.h;
            this.svgElement.setAttribute("width", this.compW);
            this.svgElement.setAttribute("height", this.compH);
            var g3 = createNS("g");
            this.maskedElement.appendChild(g3);
            this.innerElem = g3;
          } else {
            this.renderType = "html";
            this.innerElem = this.layerElement;
          }
          this.checkParenting();
        };
        HTextElement.prototype.buildNewText = function() {
          var documentData = this.textProperty.currentData;
          this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
          var innerElemStyle = this.innerElem.style;
          var textColor = documentData.fc ? this.buildColor(documentData.fc) : "rgba(0,0,0,0)";
          innerElemStyle.fill = textColor;
          innerElemStyle.color = textColor;
          if (documentData.sc) {
            innerElemStyle.stroke = this.buildColor(documentData.sc);
            innerElemStyle.strokeWidth = documentData.sw + "px";
          }
          var fontData = this.globalData.fontManager.getFontByName(documentData.f);
          if (!this.globalData.fontManager.chars) {
            innerElemStyle.fontSize = documentData.finalSize + "px";
            innerElemStyle.lineHeight = documentData.finalSize + "px";
            if (fontData.fClass) {
              this.innerElem.className = fontData.fClass;
            } else {
              innerElemStyle.fontFamily = fontData.fFamily;
              var fWeight = documentData.fWeight;
              var fStyle = documentData.fStyle;
              innerElemStyle.fontStyle = fStyle;
              innerElemStyle.fontWeight = fWeight;
            }
          }
          var i6;
          var len;
          var letters = documentData.l;
          len = letters.length;
          var tSpan;
          var tParent;
          var tCont;
          var matrixHelper = this.mHelper;
          var shapes;
          var shapeStr = "";
          var cnt = 0;
          for (i6 = 0; i6 < len; i6 += 1) {
            if (this.globalData.fontManager.chars) {
              if (!this.textPaths[cnt]) {
                tSpan = createNS("path");
                tSpan.setAttribute("stroke-linecap", lineCapEnum[1]);
                tSpan.setAttribute("stroke-linejoin", lineJoinEnum[2]);
                tSpan.setAttribute("stroke-miterlimit", "4");
              } else {
                tSpan = this.textPaths[cnt];
              }
              if (!this.isMasked) {
                if (this.textSpans[cnt]) {
                  tParent = this.textSpans[cnt];
                  tCont = tParent.children[0];
                } else {
                  tParent = createTag("div");
                  tParent.style.lineHeight = 0;
                  tCont = createNS("svg");
                  tCont.appendChild(tSpan);
                  styleDiv(tParent);
                }
              }
            } else if (!this.isMasked) {
              if (this.textSpans[cnt]) {
                tParent = this.textSpans[cnt];
                tSpan = this.textPaths[cnt];
              } else {
                tParent = createTag("span");
                styleDiv(tParent);
                tSpan = createTag("span");
                styleDiv(tSpan);
                tParent.appendChild(tSpan);
              }
            } else {
              tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS("text");
            }
            if (this.globalData.fontManager.chars) {
              var charData = this.globalData.fontManager.getCharData(documentData.finalText[i6], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
              var shapeData;
              if (charData) {
                shapeData = charData.data;
              } else {
                shapeData = null;
              }
              matrixHelper.reset();
              if (shapeData && shapeData.shapes && shapeData.shapes.length) {
                shapes = shapeData.shapes[0].it;
                matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
                shapeStr = this.createPathShape(matrixHelper, shapes);
                tSpan.setAttribute("d", shapeStr);
              }
              if (!this.isMasked) {
                this.innerElem.appendChild(tParent);
                if (shapeData && shapeData.shapes) {
                  document.body.appendChild(tCont);
                  var boundingBox = tCont.getBBox();
                  tCont.setAttribute("width", boundingBox.width + 2);
                  tCont.setAttribute("height", boundingBox.height + 2);
                  tCont.setAttribute("viewBox", boundingBox.x - 1 + " " + (boundingBox.y - 1) + " " + (boundingBox.width + 2) + " " + (boundingBox.height + 2));
                  var tContStyle = tCont.style;
                  var tContTranslation = "translate(" + (boundingBox.x - 1) + "px," + (boundingBox.y - 1) + "px)";
                  tContStyle.transform = tContTranslation;
                  tContStyle.webkitTransform = tContTranslation;
                  letters[i6].yOffset = boundingBox.y - 1;
                } else {
                  tCont.setAttribute("width", 1);
                  tCont.setAttribute("height", 1);
                }
                tParent.appendChild(tCont);
              } else {
                this.innerElem.appendChild(tSpan);
              }
            } else {
              tSpan.textContent = letters[i6].val;
              tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
              if (!this.isMasked) {
                this.innerElem.appendChild(tParent);
                var tStyle = tSpan.style;
                var tSpanTranslation = "translate3d(0," + -documentData.finalSize / 1.2 + "px,0)";
                tStyle.transform = tSpanTranslation;
                tStyle.webkitTransform = tSpanTranslation;
              } else {
                this.innerElem.appendChild(tSpan);
              }
            }
            if (!this.isMasked) {
              this.textSpans[cnt] = tParent;
            } else {
              this.textSpans[cnt] = tSpan;
            }
            this.textSpans[cnt].style.display = "block";
            this.textPaths[cnt] = tSpan;
            cnt += 1;
          }
          while (cnt < this.textSpans.length) {
            this.textSpans[cnt].style.display = "none";
            cnt += 1;
          }
        };
        HTextElement.prototype.renderInnerContent = function() {
          this.validateText();
          var svgStyle;
          if (this.data.singleShape) {
            if (!this._isFirstFrame && !this.lettersChangedFlag) {
              return;
            }
            if (this.isMasked && this.finalTransform._matMdf) {
              this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH);
              svgStyle = this.svgElement.style;
              var translation = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)";
              svgStyle.transform = translation;
              svgStyle.webkitTransform = translation;
            }
          }
          this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
          if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) {
            return;
          }
          var i6;
          var len;
          var count = 0;
          var renderedLetters = this.textAnimator.renderedLetters;
          var letters = this.textProperty.currentData.l;
          len = letters.length;
          var renderedLetter;
          var textSpan;
          var textPath;
          for (i6 = 0; i6 < len; i6 += 1) {
            if (letters[i6].n) {
              count += 1;
            } else {
              textSpan = this.textSpans[i6];
              textPath = this.textPaths[i6];
              renderedLetter = renderedLetters[count];
              count += 1;
              if (renderedLetter._mdf.m) {
                if (!this.isMasked) {
                  textSpan.style.webkitTransform = renderedLetter.m;
                  textSpan.style.transform = renderedLetter.m;
                } else {
                  textSpan.setAttribute("transform", renderedLetter.m);
                }
              }
              textSpan.style.opacity = renderedLetter.o;
              if (renderedLetter.sw && renderedLetter._mdf.sw) {
                textPath.setAttribute("stroke-width", renderedLetter.sw);
              }
              if (renderedLetter.sc && renderedLetter._mdf.sc) {
                textPath.setAttribute("stroke", renderedLetter.sc);
              }
              if (renderedLetter.fc && renderedLetter._mdf.fc) {
                textPath.setAttribute("fill", renderedLetter.fc);
                textPath.style.color = renderedLetter.fc;
              }
            }
          }
          if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
            var boundingBox = this.innerElem.getBBox();
            if (this.currentBBox.w !== boundingBox.width) {
              this.currentBBox.w = boundingBox.width;
              this.svgElement.setAttribute("width", boundingBox.width);
            }
            if (this.currentBBox.h !== boundingBox.height) {
              this.currentBBox.h = boundingBox.height;
              this.svgElement.setAttribute("height", boundingBox.height);
            }
            var margin = 1;
            if (this.currentBBox.w !== boundingBox.width + margin * 2 || this.currentBBox.h !== boundingBox.height + margin * 2 || this.currentBBox.x !== boundingBox.x - margin || this.currentBBox.y !== boundingBox.y - margin) {
              this.currentBBox.w = boundingBox.width + margin * 2;
              this.currentBBox.h = boundingBox.height + margin * 2;
              this.currentBBox.x = boundingBox.x - margin;
              this.currentBBox.y = boundingBox.y - margin;
              this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
              svgStyle = this.svgElement.style;
              var svgTransform = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
              svgStyle.transform = svgTransform;
              svgStyle.webkitTransform = svgTransform;
            }
          }
        };
        function HCameraElement(data2, globalData2, comp2) {
          this.initFrame();
          this.initBaseData(data2, globalData2, comp2);
          this.initHierarchy();
          var getProp = PropertyFactory.getProp;
          this.pe = getProp(this, data2.pe, 0, 0, this);
          if (data2.ks.p.s) {
            this.px = getProp(this, data2.ks.p.x, 1, 0, this);
            this.py = getProp(this, data2.ks.p.y, 1, 0, this);
            this.pz = getProp(this, data2.ks.p.z, 1, 0, this);
          } else {
            this.p = getProp(this, data2.ks.p, 1, 0, this);
          }
          if (data2.ks.a) {
            this.a = getProp(this, data2.ks.a, 1, 0, this);
          }
          if (data2.ks.or.k.length && data2.ks.or.k[0].to) {
            var i6;
            var len = data2.ks.or.k.length;
            for (i6 = 0; i6 < len; i6 += 1) {
              data2.ks.or.k[i6].to = null;
              data2.ks.or.k[i6].ti = null;
            }
          }
          this.or = getProp(this, data2.ks.or, 1, degToRads, this);
          this.or.sh = true;
          this.rx = getProp(this, data2.ks.rx, 0, degToRads, this);
          this.ry = getProp(this, data2.ks.ry, 0, degToRads, this);
          this.rz = getProp(this, data2.ks.rz, 0, degToRads, this);
          this.mat = new Matrix();
          this._prevMat = new Matrix();
          this._isFirstFrame = true;
          this.finalTransform = {
            mProp: this
          };
        }
        extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement);
        HCameraElement.prototype.setup = function() {
          var i6;
          var len = this.comp.threeDElements.length;
          var comp2;
          var perspectiveStyle;
          var containerStyle;
          for (i6 = 0; i6 < len; i6 += 1) {
            comp2 = this.comp.threeDElements[i6];
            if (comp2.type === "3d") {
              perspectiveStyle = comp2.perspectiveElem.style;
              containerStyle = comp2.container.style;
              var perspective = this.pe.v + "px";
              var origin = "0px 0px 0px";
              var matrix = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
              perspectiveStyle.perspective = perspective;
              perspectiveStyle.webkitPerspective = perspective;
              containerStyle.transformOrigin = origin;
              containerStyle.mozTransformOrigin = origin;
              containerStyle.webkitTransformOrigin = origin;
              perspectiveStyle.transform = matrix;
              perspectiveStyle.webkitTransform = matrix;
            }
          }
        };
        HCameraElement.prototype.createElements = function() {
        };
        HCameraElement.prototype.hide = function() {
        };
        HCameraElement.prototype.renderFrame = function() {
          var _mdf = this._isFirstFrame;
          var i6;
          var len;
          if (this.hierarchy) {
            len = this.hierarchy.length;
            for (i6 = 0; i6 < len; i6 += 1) {
              _mdf = this.hierarchy[i6].finalTransform.mProp._mdf || _mdf;
            }
          }
          if (_mdf || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
            this.mat.reset();
            if (this.hierarchy) {
              len = this.hierarchy.length - 1;
              for (i6 = len; i6 >= 0; i6 -= 1) {
                var mTransf = this.hierarchy[i6].finalTransform.mProp;
                this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]);
                this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);
                this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);
                this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]);
                this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2]);
              }
            }
            if (this.p) {
              this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]);
            } else {
              this.mat.translate(-this.px.v, -this.py.v, this.pz.v);
            }
            if (this.a) {
              var diffVector;
              if (this.p) {
                diffVector = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]];
              } else {
                diffVector = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
              }
              var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2));
              var lookDir = [diffVector[0] / mag, diffVector[1] / mag, diffVector[2] / mag];
              var lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]);
              var mRotationX = Math.atan2(lookDir[1], lookLengthOnXZ);
              var mRotationY = Math.atan2(lookDir[0], -lookDir[2]);
              this.mat.rotateY(mRotationY).rotateX(-mRotationX);
            }
            this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
            this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);
            this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0);
            this.mat.translate(0, 0, this.pe.v);
            var hasMatrixChanged = !this._prevMat.equals(this.mat);
            if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {
              len = this.comp.threeDElements.length;
              var comp2;
              var perspectiveStyle;
              var containerStyle;
              for (i6 = 0; i6 < len; i6 += 1) {
                comp2 = this.comp.threeDElements[i6];
                if (comp2.type === "3d") {
                  if (hasMatrixChanged) {
                    var matValue = this.mat.toCSS();
                    containerStyle = comp2.container.style;
                    containerStyle.transform = matValue;
                    containerStyle.webkitTransform = matValue;
                  }
                  if (this.pe._mdf) {
                    perspectiveStyle = comp2.perspectiveElem.style;
                    perspectiveStyle.perspective = this.pe.v + "px";
                    perspectiveStyle.webkitPerspective = this.pe.v + "px";
                  }
                }
              }
              this.mat.clone(this._prevMat);
            }
          }
          this._isFirstFrame = false;
        };
        HCameraElement.prototype.prepareFrame = function(num) {
          this.prepareProperties(num, true);
        };
        HCameraElement.prototype.destroy = function() {
        };
        HCameraElement.prototype.getBaseElement = function() {
          return null;
        };
        function HImageElement(data2, globalData2, comp2) {
          this.assetData = globalData2.getAssetData(data2.refId);
          this.initElement(data2, globalData2, comp2);
        }
        extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement);
        HImageElement.prototype.createContent = function() {
          var assetPath = this.globalData.getAssetsPath(this.assetData);
          var img = new Image();
          if (this.data.hasMask) {
            this.imageElem = createNS("image");
            this.imageElem.setAttribute("width", this.assetData.w + "px");
            this.imageElem.setAttribute("height", this.assetData.h + "px");
            this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", assetPath);
            this.layerElement.appendChild(this.imageElem);
            this.baseElement.setAttribute("width", this.assetData.w);
            this.baseElement.setAttribute("height", this.assetData.h);
          } else {
            this.layerElement.appendChild(img);
          }
          img.crossOrigin = "anonymous";
          img.src = assetPath;
          if (this.data.ln) {
            this.baseElement.setAttribute("id", this.data.ln);
          }
        };
        function HybridRendererBase(animationItem, config3) {
          this.animationItem = animationItem;
          this.layers = null;
          this.renderedFrame = -1;
          this.renderConfig = {
            className: config3 && config3.className || "",
            imagePreserveAspectRatio: config3 && config3.imagePreserveAspectRatio || "xMidYMid slice",
            hideOnTransparent: !(config3 && config3.hideOnTransparent === false),
            filterSize: {
              width: config3 && config3.filterSize && config3.filterSize.width || "400%",
              height: config3 && config3.filterSize && config3.filterSize.height || "400%",
              x: config3 && config3.filterSize && config3.filterSize.x || "-100%",
              y: config3 && config3.filterSize && config3.filterSize.y || "-100%"
            }
          };
          this.globalData = {
            _mdf: false,
            frameNum: -1,
            renderConfig: this.renderConfig
          };
          this.pendingElements = [];
          this.elements = [];
          this.threeDElements = [];
          this.destroyed = false;
          this.camera = null;
          this.supports3d = true;
          this.rendererType = "html";
        }
        extendPrototype([BaseRenderer], HybridRendererBase);
        HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem;
        HybridRendererBase.prototype.checkPendingElements = function() {
          while (this.pendingElements.length) {
            var element = this.pendingElements.pop();
            element.checkParenting();
          }
        };
        HybridRendererBase.prototype.appendElementInPos = function(element, pos) {
          var newDOMElement = element.getBaseElement();
          if (!newDOMElement) {
            return;
          }
          var layer = this.layers[pos];
          if (!layer.ddd || !this.supports3d) {
            if (this.threeDElements) {
              this.addTo3dContainer(newDOMElement, pos);
            } else {
              var i6 = 0;
              var nextDOMElement;
              var nextLayer;
              var tmpDOMElement;
              while (i6 < pos) {
                if (this.elements[i6] && this.elements[i6] !== true && this.elements[i6].getBaseElement) {
                  nextLayer = this.elements[i6];
                  tmpDOMElement = this.layers[i6].ddd ? this.getThreeDContainerByPos(i6) : nextLayer.getBaseElement();
                  nextDOMElement = tmpDOMElement || nextDOMElement;
                }
                i6 += 1;
              }
              if (nextDOMElement) {
                if (!layer.ddd || !this.supports3d) {
                  this.layerElement.insertBefore(newDOMElement, nextDOMElement);
                }
              } else if (!layer.ddd || !this.supports3d) {
                this.layerElement.appendChild(newDOMElement);
              }
            }
          } else {
            this.addTo3dContainer(newDOMElement, pos);
          }
        };
        HybridRendererBase.prototype.createShape = function(data2) {
          if (!this.supports3d) {
            return new SVGShapeElement(data2, this.globalData, this);
          }
          return new HShapeElement(data2, this.globalData, this);
        };
        HybridRendererBase.prototype.createText = function(data2) {
          if (!this.supports3d) {
            return new SVGTextLottieElement(data2, this.globalData, this);
          }
          return new HTextElement(data2, this.globalData, this);
        };
        HybridRendererBase.prototype.createCamera = function(data2) {
          this.camera = new HCameraElement(data2, this.globalData, this);
          return this.camera;
        };
        HybridRendererBase.prototype.createImage = function(data2) {
          if (!this.supports3d) {
            return new IImageElement(data2, this.globalData, this);
          }
          return new HImageElement(data2, this.globalData, this);
        };
        HybridRendererBase.prototype.createSolid = function(data2) {
          if (!this.supports3d) {
            return new ISolidElement(data2, this.globalData, this);
          }
          return new HSolidElement(data2, this.globalData, this);
        };
        HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
        HybridRendererBase.prototype.getThreeDContainerByPos = function(pos) {
          var i6 = 0;
          var len = this.threeDElements.length;
          while (i6 < len) {
            if (this.threeDElements[i6].startPos <= pos && this.threeDElements[i6].endPos >= pos) {
              return this.threeDElements[i6].perspectiveElem;
            }
            i6 += 1;
          }
          return null;
        };
        HybridRendererBase.prototype.createThreeDContainer = function(pos, type) {
          var perspectiveElem = createTag("div");
          var style;
          var containerStyle;
          styleDiv(perspectiveElem);
          var container = createTag("div");
          styleDiv(container);
          if (type === "3d") {
            style = perspectiveElem.style;
            style.width = this.globalData.compSize.w + "px";
            style.height = this.globalData.compSize.h + "px";
            var center = "50% 50%";
            style.webkitTransformOrigin = center;
            style.mozTransformOrigin = center;
            style.transformOrigin = center;
            containerStyle = container.style;
            var matrix = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
            containerStyle.transform = matrix;
            containerStyle.webkitTransform = matrix;
          }
          perspectiveElem.appendChild(container);
          var threeDContainerData = {
            container,
            perspectiveElem,
            startPos: pos,
            endPos: pos,
            type
          };
          this.threeDElements.push(threeDContainerData);
          return threeDContainerData;
        };
        HybridRendererBase.prototype.build3dContainers = function() {
          var i6;
          var len = this.layers.length;
          var lastThreeDContainerData;
          var currentContainer = "";
          for (i6 = 0; i6 < len; i6 += 1) {
            if (this.layers[i6].ddd && this.layers[i6].ty !== 3) {
              if (currentContainer !== "3d") {
                currentContainer = "3d";
                lastThreeDContainerData = this.createThreeDContainer(i6, "3d");
              }
              lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i6);
            } else {
              if (currentContainer !== "2d") {
                currentContainer = "2d";
                lastThreeDContainerData = this.createThreeDContainer(i6, "2d");
              }
              lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i6);
            }
          }
          len = this.threeDElements.length;
          for (i6 = len - 1; i6 >= 0; i6 -= 1) {
            this.resizerElem.appendChild(this.threeDElements[i6].perspectiveElem);
          }
        };
        HybridRendererBase.prototype.addTo3dContainer = function(elem2, pos) {
          var i6 = 0;
          var len = this.threeDElements.length;
          while (i6 < len) {
            if (pos <= this.threeDElements[i6].endPos) {
              var j3 = this.threeDElements[i6].startPos;
              var nextElement;
              while (j3 < pos) {
                if (this.elements[j3] && this.elements[j3].getBaseElement) {
                  nextElement = this.elements[j3].getBaseElement();
                }
                j3 += 1;
              }
              if (nextElement) {
                this.threeDElements[i6].container.insertBefore(elem2, nextElement);
              } else {
                this.threeDElements[i6].container.appendChild(elem2);
              }
              break;
            }
            i6 += 1;
          }
        };
        HybridRendererBase.prototype.configAnimation = function(animData) {
          var resizerElem = createTag("div");
          var wrapper = this.animationItem.wrapper;
          var style = resizerElem.style;
          style.width = animData.w + "px";
          style.height = animData.h + "px";
          this.resizerElem = resizerElem;
          styleDiv(resizerElem);
          style.transformStyle = "flat";
          style.mozTransformStyle = "flat";
          style.webkitTransformStyle = "flat";
          if (this.renderConfig.className) {
            resizerElem.setAttribute("class", this.renderConfig.className);
          }
          wrapper.appendChild(resizerElem);
          style.overflow = "hidden";
          var svg = createNS("svg");
          svg.setAttribute("width", "1");
          svg.setAttribute("height", "1");
          styleDiv(svg);
          this.resizerElem.appendChild(svg);
          var defs = createNS("defs");
          svg.appendChild(defs);
          this.data = animData;
          this.setupGlobalData(animData, svg);
          this.globalData.defs = defs;
          this.layers = animData.layers;
          this.layerElement = this.resizerElem;
          this.build3dContainers();
          this.updateContainerSize();
        };
        HybridRendererBase.prototype.destroy = function() {
          if (this.animationItem.wrapper) {
            this.animationItem.wrapper.innerText = "";
          }
          this.animationItem.container = null;
          this.globalData.defs = null;
          var i6;
          var len = this.layers ? this.layers.length : 0;
          for (i6 = 0; i6 < len; i6 += 1) {
            if (this.elements[i6] && this.elements[i6].destroy) {
              this.elements[i6].destroy();
            }
          }
          this.elements.length = 0;
          this.destroyed = true;
          this.animationItem = null;
        };
        HybridRendererBase.prototype.updateContainerSize = function() {
          var elementWidth = this.animationItem.wrapper.offsetWidth;
          var elementHeight = this.animationItem.wrapper.offsetHeight;
          var elementRel = elementWidth / elementHeight;
          var animationRel = this.globalData.compSize.w / this.globalData.compSize.h;
          var sx;
          var sy;
          var tx;
          var ty;
          if (animationRel > elementRel) {
            sx = elementWidth / this.globalData.compSize.w;
            sy = elementWidth / this.globalData.compSize.w;
            tx = 0;
            ty = (elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2;
          } else {
            sx = elementHeight / this.globalData.compSize.h;
            sy = elementHeight / this.globalData.compSize.h;
            tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2;
            ty = 0;
          }
          var style = this.resizerElem.style;
          style.webkitTransform = "matrix3d(" + sx + ",0,0,0,0," + sy + ",0,0,0,0,1,0," + tx + "," + ty + ",0,1)";
          style.transform = style.webkitTransform;
        };
        HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame;
        HybridRendererBase.prototype.hide = function() {
          this.resizerElem.style.display = "none";
        };
        HybridRendererBase.prototype.show = function() {
          this.resizerElem.style.display = "block";
        };
        HybridRendererBase.prototype.initItems = function() {
          this.buildAllItems();
          if (this.camera) {
            this.camera.setup();
          } else {
            var cWidth = this.globalData.compSize.w;
            var cHeight = this.globalData.compSize.h;
            var i6;
            var len = this.threeDElements.length;
            for (i6 = 0; i6 < len; i6 += 1) {
              var style = this.threeDElements[i6].perspectiveElem.style;
              style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + "px";
              style.perspective = style.webkitPerspective;
            }
          }
        };
        HybridRendererBase.prototype.searchExtraCompositions = function(assets) {
          var i6;
          var len = assets.length;
          var floatingContainer = createTag("div");
          for (i6 = 0; i6 < len; i6 += 1) {
            if (assets[i6].xt) {
              var comp2 = this.createComp(assets[i6], floatingContainer, this.globalData.comp, null);
              comp2.initExpressions();
              this.globalData.projectInterface.registerComposition(comp2);
            }
          }
        };
        function HCompElement(data2, globalData2, comp2) {
          this.layers = data2.layers;
          this.supports3d = !data2.hasMask;
          this.completeLayers = false;
          this.pendingElements = [];
          this.elements = this.layers ? createSizedArray(this.layers.length) : [];
          this.initElement(data2, globalData2, comp2);
          this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
            _placeholder: true
          };
        }
        extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement);
        HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;
        HCompElement.prototype.createContainerElements = function() {
          this._createBaseContainerElements();
          if (this.data.hasMask) {
            this.svgElement.setAttribute("width", this.data.w);
            this.svgElement.setAttribute("height", this.data.h);
            this.transformedElement = this.baseElement;
          } else {
            this.transformedElement = this.layerElement;
          }
        };
        HCompElement.prototype.addTo3dContainer = function(elem2, pos) {
          var j3 = 0;
          var nextElement;
          while (j3 < pos) {
            if (this.elements[j3] && this.elements[j3].getBaseElement) {
              nextElement = this.elements[j3].getBaseElement();
            }
            j3 += 1;
          }
          if (nextElement) {
            this.layerElement.insertBefore(elem2, nextElement);
          } else {
            this.layerElement.appendChild(elem2);
          }
        };
        HCompElement.prototype.createComp = function(data2) {
          if (!this.supports3d) {
            return new SVGCompElement(data2, this.globalData, this);
          }
          return new HCompElement(data2, this.globalData, this);
        };
        function HybridRenderer(animationItem, config3) {
          this.animationItem = animationItem;
          this.layers = null;
          this.renderedFrame = -1;
          this.renderConfig = {
            className: config3 && config3.className || "",
            imagePreserveAspectRatio: config3 && config3.imagePreserveAspectRatio || "xMidYMid slice",
            hideOnTransparent: !(config3 && config3.hideOnTransparent === false),
            filterSize: {
              width: config3 && config3.filterSize && config3.filterSize.width || "400%",
              height: config3 && config3.filterSize && config3.filterSize.height || "400%",
              x: config3 && config3.filterSize && config3.filterSize.x || "-100%",
              y: config3 && config3.filterSize && config3.filterSize.y || "-100%"
            },
            runExpressions: !config3 || config3.runExpressions === void 0 || config3.runExpressions
          };
          this.globalData = {
            _mdf: false,
            frameNum: -1,
            renderConfig: this.renderConfig
          };
          this.pendingElements = [];
          this.elements = [];
          this.threeDElements = [];
          this.destroyed = false;
          this.camera = null;
          this.supports3d = true;
          this.rendererType = "html";
        }
        extendPrototype([HybridRendererBase], HybridRenderer);
        HybridRenderer.prototype.createComp = function(data2) {
          if (!this.supports3d) {
            return new SVGCompElement(data2, this.globalData, this);
          }
          return new HCompElement(data2, this.globalData, this);
        };
        var CompExpressionInterface = /* @__PURE__ */ function() {
          return function(comp2) {
            function _thisLayerFunction(name2) {
              var i6 = 0;
              var len = comp2.layers.length;
              while (i6 < len) {
                if (comp2.layers[i6].nm === name2 || comp2.layers[i6].ind === name2) {
                  return comp2.elements[i6].layerInterface;
                }
                i6 += 1;
              }
              return null;
            }
            Object.defineProperty(_thisLayerFunction, "_name", {
              value: comp2.data.nm
            });
            _thisLayerFunction.layer = _thisLayerFunction;
            _thisLayerFunction.pixelAspect = 1;
            _thisLayerFunction.height = comp2.data.h || comp2.globalData.compSize.h;
            _thisLayerFunction.width = comp2.data.w || comp2.globalData.compSize.w;
            _thisLayerFunction.pixelAspect = 1;
            _thisLayerFunction.frameDuration = 1 / comp2.globalData.frameRate;
            _thisLayerFunction.displayStartTime = 0;
            _thisLayerFunction.numLayers = comp2.layers.length;
            return _thisLayerFunction;
          };
        }();
        function _typeof$2(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof$2 = function _typeof3(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof$2 = function _typeof3(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof$2(obj);
        }
        function seedRandom(pool, math) {
          var global = this, width2 = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width2, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask2 = width2 - 1, nodecrypto;
          function seedrandom(seed, options, callback) {
            var key2 = [];
            options = options === true ? {
              entropy: true
            } : options || {};
            var shortseed = mixkey(flatten(options.entropy ? [seed, tostring(pool)] : seed === null ? autoseed() : seed, 3), key2);
            var arc4 = new ARC4(key2);
            var prng = function prng2() {
              var n6 = arc4.g(chunks), d3 = startdenom, x3 = 0;
              while (n6 < significance) {
                n6 = (n6 + x3) * width2;
                d3 *= width2;
                x3 = arc4.g(1);
              }
              while (n6 >= overflow) {
                n6 /= 2;
                d3 /= 2;
                x3 >>>= 1;
              }
              return (n6 + x3) / d3;
            };
            prng.int32 = function() {
              return arc4.g(4) | 0;
            };
            prng.quick = function() {
              return arc4.g(4) / 4294967296;
            };
            prng["double"] = prng;
            mixkey(tostring(arc4.S), pool);
            return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
              if (state) {
                if (state.S) {
                  copy(state, arc4);
                }
                prng2.state = function() {
                  return copy(arc4, {});
                };
              }
              if (is_math_call) {
                math[rngname] = prng2;
                return seed2;
              } else return prng2;
            })(prng, shortseed, "global" in options ? options.global : this == math, options.state);
          }
          math["seed" + rngname] = seedrandom;
          function ARC4(key2) {
            var t4, keylen = key2.length, me2 = this, i6 = 0, j3 = me2.i = me2.j = 0, s4 = me2.S = [];
            if (!keylen) {
              key2 = [keylen++];
            }
            while (i6 < width2) {
              s4[i6] = i6++;
            }
            for (i6 = 0; i6 < width2; i6++) {
              s4[i6] = s4[j3 = mask2 & j3 + key2[i6 % keylen] + (t4 = s4[i6])];
              s4[j3] = t4;
            }
            me2.g = function(count) {
              var t5, r6 = 0, i7 = me2.i, j4 = me2.j, s5 = me2.S;
              while (count--) {
                t5 = s5[i7 = mask2 & i7 + 1];
                r6 = r6 * width2 + s5[mask2 & (s5[i7] = s5[j4 = mask2 & j4 + t5]) + (s5[j4] = t5)];
              }
              me2.i = i7;
              me2.j = j4;
              return r6;
            };
          }
          function copy(f3, t4) {
            t4.i = f3.i;
            t4.j = f3.j;
            t4.S = f3.S.slice();
            return t4;
          }
          function flatten(obj, depth) {
            var result = [], typ = _typeof$2(obj), prop;
            if (depth && typ == "object") {
              for (prop in obj) {
                try {
                  result.push(flatten(obj[prop], depth - 1));
                } catch (e5) {
                }
              }
            }
            return result.length ? result : typ == "string" ? obj : obj + "\0";
          }
          function mixkey(seed, key2) {
            var stringseed = seed + "", smear, j3 = 0;
            while (j3 < stringseed.length) {
              key2[mask2 & j3] = mask2 & (smear ^= key2[mask2 & j3] * 19) + stringseed.charCodeAt(j3++);
            }
            return tostring(key2);
          }
          function autoseed() {
            try {
              if (nodecrypto) {
                return tostring(nodecrypto.randomBytes(width2));
              }
              var out = new Uint8Array(width2);
              (global.crypto || global.msCrypto).getRandomValues(out);
              return tostring(out);
            } catch (e5) {
              var browser2 = global.navigator, plugins = browser2 && browser2.plugins;
              return [+/* @__PURE__ */ new Date(), global, plugins, global.screen, tostring(pool)];
            }
          }
          function tostring(a5) {
            return String.fromCharCode.apply(0, a5);
          }
          mixkey(math.random(), pool);
        }
        ;
        function initialize$2(BMMath2) {
          seedRandom([], BMMath2);
        }
        var propTypes = {
          SHAPE: "shape"
        };
        function _typeof$1(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof$1 = function _typeof3(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof$1 = function _typeof3(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof$1(obj);
        }
        var ExpressionManager = function() {
          "use strict";
          var ob = {};
          var Math = BMMath;
          var window = null;
          var document = null;
          var XMLHttpRequest = null;
          var fetch = null;
          var frames = null;
          var _lottieGlobal = {};
          initialize$2(BMMath);
          function resetFrame() {
            _lottieGlobal = {};
          }
          function $bm_isInstanceOfArray(arr) {
            return arr.constructor === Array || arr.constructor === Float32Array;
          }
          function isNumerable(tOfV, v2) {
            return tOfV === "number" || v2 instanceof Number || tOfV === "boolean" || tOfV === "string";
          }
          function $bm_neg(a5) {
            var tOfA = _typeof$1(a5);
            if (tOfA === "number" || a5 instanceof Number || tOfA === "boolean") {
              return -a5;
            }
            if ($bm_isInstanceOfArray(a5)) {
              var i6;
              var lenA = a5.length;
              var retArr = [];
              for (i6 = 0; i6 < lenA; i6 += 1) {
                retArr[i6] = -a5[i6];
              }
              return retArr;
            }
            if (a5.propType) {
              return a5.v;
            }
            return -a5;
          }
          var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, "easeIn").get;
          var easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, "easeOut").get;
          var easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, "easeInOut").get;
          function sum(a5, b3) {
            var tOfA = _typeof$1(a5);
            var tOfB = _typeof$1(b3);
            if (isNumerable(tOfA, a5) && isNumerable(tOfB, b3) || tOfA === "string" || tOfB === "string") {
              return a5 + b3;
            }
            if ($bm_isInstanceOfArray(a5) && isNumerable(tOfB, b3)) {
              a5 = a5.slice(0);
              a5[0] += b3;
              return a5;
            }
            if (isNumerable(tOfA, a5) && $bm_isInstanceOfArray(b3)) {
              b3 = b3.slice(0);
              b3[0] = a5 + b3[0];
              return b3;
            }
            if ($bm_isInstanceOfArray(a5) && $bm_isInstanceOfArray(b3)) {
              var i6 = 0;
              var lenA = a5.length;
              var lenB = b3.length;
              var retArr = [];
              while (i6 < lenA || i6 < lenB) {
                if ((typeof a5[i6] === "number" || a5[i6] instanceof Number) && (typeof b3[i6] === "number" || b3[i6] instanceof Number)) {
                  retArr[i6] = a5[i6] + b3[i6];
                } else {
                  retArr[i6] = b3[i6] === void 0 ? a5[i6] : a5[i6] || b3[i6];
                }
                i6 += 1;
              }
              return retArr;
            }
            return 0;
          }
          var add = sum;
          function sub(a5, b3) {
            var tOfA = _typeof$1(a5);
            var tOfB = _typeof$1(b3);
            if (isNumerable(tOfA, a5) && isNumerable(tOfB, b3)) {
              if (tOfA === "string") {
                a5 = parseInt(a5, 10);
              }
              if (tOfB === "string") {
                b3 = parseInt(b3, 10);
              }
              return a5 - b3;
            }
            if ($bm_isInstanceOfArray(a5) && isNumerable(tOfB, b3)) {
              a5 = a5.slice(0);
              a5[0] -= b3;
              return a5;
            }
            if (isNumerable(tOfA, a5) && $bm_isInstanceOfArray(b3)) {
              b3 = b3.slice(0);
              b3[0] = a5 - b3[0];
              return b3;
            }
            if ($bm_isInstanceOfArray(a5) && $bm_isInstanceOfArray(b3)) {
              var i6 = 0;
              var lenA = a5.length;
              var lenB = b3.length;
              var retArr = [];
              while (i6 < lenA || i6 < lenB) {
                if ((typeof a5[i6] === "number" || a5[i6] instanceof Number) && (typeof b3[i6] === "number" || b3[i6] instanceof Number)) {
                  retArr[i6] = a5[i6] - b3[i6];
                } else {
                  retArr[i6] = b3[i6] === void 0 ? a5[i6] : a5[i6] || b3[i6];
                }
                i6 += 1;
              }
              return retArr;
            }
            return 0;
          }
          function mul(a5, b3) {
            var tOfA = _typeof$1(a5);
            var tOfB = _typeof$1(b3);
            var arr;
            if (isNumerable(tOfA, a5) && isNumerable(tOfB, b3)) {
              return a5 * b3;
            }
            var i6;
            var len;
            if ($bm_isInstanceOfArray(a5) && isNumerable(tOfB, b3)) {
              len = a5.length;
              arr = createTypedArray("float32", len);
              for (i6 = 0; i6 < len; i6 += 1) {
                arr[i6] = a5[i6] * b3;
              }
              return arr;
            }
            if (isNumerable(tOfA, a5) && $bm_isInstanceOfArray(b3)) {
              len = b3.length;
              arr = createTypedArray("float32", len);
              for (i6 = 0; i6 < len; i6 += 1) {
                arr[i6] = a5 * b3[i6];
              }
              return arr;
            }
            return 0;
          }
          function div(a5, b3) {
            var tOfA = _typeof$1(a5);
            var tOfB = _typeof$1(b3);
            var arr;
            if (isNumerable(tOfA, a5) && isNumerable(tOfB, b3)) {
              return a5 / b3;
            }
            var i6;
            var len;
            if ($bm_isInstanceOfArray(a5) && isNumerable(tOfB, b3)) {
              len = a5.length;
              arr = createTypedArray("float32", len);
              for (i6 = 0; i6 < len; i6 += 1) {
                arr[i6] = a5[i6] / b3;
              }
              return arr;
            }
            if (isNumerable(tOfA, a5) && $bm_isInstanceOfArray(b3)) {
              len = b3.length;
              arr = createTypedArray("float32", len);
              for (i6 = 0; i6 < len; i6 += 1) {
                arr[i6] = a5 / b3[i6];
              }
              return arr;
            }
            return 0;
          }
          function mod(a5, b3) {
            if (typeof a5 === "string") {
              a5 = parseInt(a5, 10);
            }
            if (typeof b3 === "string") {
              b3 = parseInt(b3, 10);
            }
            return a5 % b3;
          }
          var $bm_sum = sum;
          var $bm_sub = sub;
          var $bm_mul = mul;
          var $bm_div = div;
          var $bm_mod = mod;
          function clamp(num, min, max) {
            if (min > max) {
              var mm = max;
              max = min;
              min = mm;
            }
            return Math.min(Math.max(num, min), max);
          }
          function radiansToDegrees(val2) {
            return val2 / degToRads;
          }
          var radians_to_degrees = radiansToDegrees;
          function degreesToRadians(val2) {
            return val2 * degToRads;
          }
          var degrees_to_radians = radiansToDegrees;
          var helperLengthArray = [0, 0, 0, 0, 0, 0];
          function length(arr1, arr2) {
            if (typeof arr1 === "number" || arr1 instanceof Number) {
              arr2 = arr2 || 0;
              return Math.abs(arr1 - arr2);
            }
            if (!arr2) {
              arr2 = helperLengthArray;
            }
            var i6;
            var len = Math.min(arr1.length, arr2.length);
            var addedLength = 0;
            for (i6 = 0; i6 < len; i6 += 1) {
              addedLength += Math.pow(arr2[i6] - arr1[i6], 2);
            }
            return Math.sqrt(addedLength);
          }
          function normalize(vec) {
            return div(vec, length(vec));
          }
          function rgbToHsl(val2) {
            var r6 = val2[0];
            var g3 = val2[1];
            var b3 = val2[2];
            var max = Math.max(r6, g3, b3);
            var min = Math.min(r6, g3, b3);
            var h2;
            var s4;
            var l6 = (max + min) / 2;
            if (max === min) {
              h2 = 0;
              s4 = 0;
            } else {
              var d3 = max - min;
              s4 = l6 > 0.5 ? d3 / (2 - max - min) : d3 / (max + min);
              switch (max) {
                case r6:
                  h2 = (g3 - b3) / d3 + (g3 < b3 ? 6 : 0);
                  break;
                case g3:
                  h2 = (b3 - r6) / d3 + 2;
                  break;
                case b3:
                  h2 = (r6 - g3) / d3 + 4;
                  break;
                default:
                  break;
              }
              h2 /= 6;
            }
            return [h2, s4, l6, val2[3]];
          }
          function hue2rgb(p3, q3, t4) {
            if (t4 < 0) t4 += 1;
            if (t4 > 1) t4 -= 1;
            if (t4 < 1 / 6) return p3 + (q3 - p3) * 6 * t4;
            if (t4 < 1 / 2) return q3;
            if (t4 < 2 / 3) return p3 + (q3 - p3) * (2 / 3 - t4) * 6;
            return p3;
          }
          function hslToRgb(val2) {
            var h2 = val2[0];
            var s4 = val2[1];
            var l6 = val2[2];
            var r6;
            var g3;
            var b3;
            if (s4 === 0) {
              r6 = l6;
              b3 = l6;
              g3 = l6;
            } else {
              var q3 = l6 < 0.5 ? l6 * (1 + s4) : l6 + s4 - l6 * s4;
              var p3 = 2 * l6 - q3;
              r6 = hue2rgb(p3, q3, h2 + 1 / 3);
              g3 = hue2rgb(p3, q3, h2);
              b3 = hue2rgb(p3, q3, h2 - 1 / 3);
            }
            return [r6, g3, b3, val2[3]];
          }
          function linear(t4, tMin, tMax, value1, value2) {
            if (value1 === void 0 || value2 === void 0) {
              value1 = tMin;
              value2 = tMax;
              tMin = 0;
              tMax = 1;
            }
            if (tMax < tMin) {
              var _tMin = tMax;
              tMax = tMin;
              tMin = _tMin;
            }
            if (t4 <= tMin) {
              return value1;
            }
            if (t4 >= tMax) {
              return value2;
            }
            var perc = tMax === tMin ? 0 : (t4 - tMin) / (tMax - tMin);
            if (!value1.length) {
              return value1 + (value2 - value1) * perc;
            }
            var i6;
            var len = value1.length;
            var arr = createTypedArray("float32", len);
            for (i6 = 0; i6 < len; i6 += 1) {
              arr[i6] = value1[i6] + (value2[i6] - value1[i6]) * perc;
            }
            return arr;
          }
          function random(min, max) {
            if (max === void 0) {
              if (min === void 0) {
                min = 0;
                max = 1;
              } else {
                max = min;
                min = void 0;
              }
            }
            if (max.length) {
              var i6;
              var len = max.length;
              if (!min) {
                min = createTypedArray("float32", len);
              }
              var arr = createTypedArray("float32", len);
              var rnd = BMMath.random();
              for (i6 = 0; i6 < len; i6 += 1) {
                arr[i6] = min[i6] + rnd * (max[i6] - min[i6]);
              }
              return arr;
            }
            if (min === void 0) {
              min = 0;
            }
            var rndm = BMMath.random();
            return min + rndm * (max - min);
          }
          function createPath(points, inTangents, outTangents, closed) {
            var i6;
            var len = points.length;
            var path = shapePool.newElement();
            path.setPathData(!!closed, len);
            var arrPlaceholder = [0, 0];
            var inVertexPoint;
            var outVertexPoint;
            for (i6 = 0; i6 < len; i6 += 1) {
              inVertexPoint = inTangents && inTangents[i6] ? inTangents[i6] : arrPlaceholder;
              outVertexPoint = outTangents && outTangents[i6] ? outTangents[i6] : arrPlaceholder;
              path.setTripleAt(points[i6][0], points[i6][1], outVertexPoint[0] + points[i6][0], outVertexPoint[1] + points[i6][1], inVertexPoint[0] + points[i6][0], inVertexPoint[1] + points[i6][1], i6, true);
            }
            return path;
          }
          function initiateExpression(elem, data, property) {
            function noOp(_value) {
              return _value;
            }
            if (!elem.globalData.renderConfig.runExpressions) {
              return noOp;
            }
            var val = data.x;
            var needsVelocity = /velocity(?![\w\d])/.test(val);
            var _needsRandom = val.indexOf("random") !== -1;
            var elemType = elem.data.ty;
            var transform;
            var $bm_transform;
            var content;
            var effect;
            var thisProperty = property;
            thisProperty.valueAtTime = thisProperty.getValueAtTime;
            Object.defineProperty(thisProperty, "value", {
              get: function get() {
                return thisProperty.v;
              }
            });
            elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;
            elem.comp.displayStartTime = 0;
            var inPoint = elem.data.ip / elem.comp.globalData.frameRate;
            var outPoint = elem.data.op / elem.comp.globalData.frameRate;
            var width = elem.data.sw ? elem.data.sw : 0;
            var height = elem.data.sh ? elem.data.sh : 0;
            var name = elem.data.nm;
            var loopIn;
            var loop_in;
            var loopOut;
            var loop_out;
            var smooth;
            var toWorld;
            var fromWorld;
            var fromComp;
            var toComp;
            var fromCompToSurface;
            var position;
            var rotation;
            var anchorPoint;
            var scale;
            var thisLayer;
            var thisComp;
            var mask;
            var valueAtTime;
            var velocityAtTime;
            var scoped_bm_rt;
            var expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0];
            var numKeys = property.kf ? data.k.length : 0;
            var active = !this.data || this.data.hd !== true;
            var wiggle = function wiggle2(freq, amp) {
              var iWiggle;
              var j3;
              var lenWiggle = this.pv.length ? this.pv.length : 1;
              var addedAmps = createTypedArray("float32", lenWiggle);
              freq = 5;
              var iterations = Math.floor(time * freq);
              iWiggle = 0;
              j3 = 0;
              while (iWiggle < iterations) {
                for (j3 = 0; j3 < lenWiggle; j3 += 1) {
                  addedAmps[j3] += -amp + amp * 2 * BMMath.random();
                }
                iWiggle += 1;
              }
              var periods = time * freq;
              var perc = periods - Math.floor(periods);
              var arr = createTypedArray("float32", lenWiggle);
              if (lenWiggle > 1) {
                for (j3 = 0; j3 < lenWiggle; j3 += 1) {
                  arr[j3] = this.pv[j3] + addedAmps[j3] + (-amp + amp * 2 * BMMath.random()) * perc;
                }
                return arr;
              }
              return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;
            }.bind(this);
            if (thisProperty.loopIn) {
              loopIn = thisProperty.loopIn.bind(thisProperty);
              loop_in = loopIn;
            }
            if (thisProperty.loopOut) {
              loopOut = thisProperty.loopOut.bind(thisProperty);
              loop_out = loopOut;
            }
            if (thisProperty.smooth) {
              smooth = thisProperty.smooth.bind(thisProperty);
            }
            function loopInDuration(type, duration) {
              return loopIn(type, duration, true);
            }
            function loopOutDuration(type, duration) {
              return loopOut(type, duration, true);
            }
            if (this.getValueAtTime) {
              valueAtTime = this.getValueAtTime.bind(this);
            }
            if (this.getVelocityAtTime) {
              velocityAtTime = this.getVelocityAtTime.bind(this);
            }
            var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);
            function lookAt(elem1, elem2) {
              var fVec = [elem2[0] - elem1[0], elem2[1] - elem1[1], elem2[2] - elem1[2]];
              var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;
              var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;
              return [yaw, pitch, 0];
            }
            function easeOut(t4, tMin, tMax, val1, val2) {
              return applyEase(easeOutBez, t4, tMin, tMax, val1, val2);
            }
            function easeIn(t4, tMin, tMax, val1, val2) {
              return applyEase(easeInBez, t4, tMin, tMax, val1, val2);
            }
            function ease(t4, tMin, tMax, val1, val2) {
              return applyEase(easeInOutBez, t4, tMin, tMax, val1, val2);
            }
            function applyEase(fn, t4, tMin, tMax, val1, val2) {
              if (val1 === void 0) {
                val1 = tMin;
                val2 = tMax;
              } else {
                t4 = (t4 - tMin) / (tMax - tMin);
              }
              if (t4 > 1) {
                t4 = 1;
              } else if (t4 < 0) {
                t4 = 0;
              }
              var mult = fn(t4);
              if ($bm_isInstanceOfArray(val1)) {
                var iKey;
                var lenKey = val1.length;
                var arr = createTypedArray("float32", lenKey);
                for (iKey = 0; iKey < lenKey; iKey += 1) {
                  arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];
                }
                return arr;
              }
              return (val2 - val1) * mult + val1;
            }
            function nearestKey(time2) {
              var iKey;
              var lenKey = data.k.length;
              var index2;
              var keyTime;
              if (!data.k.length || typeof data.k[0] === "number") {
                index2 = 0;
                keyTime = 0;
              } else {
                index2 = -1;
                time2 *= elem.comp.globalData.frameRate;
                if (time2 < data.k[0].t) {
                  index2 = 1;
                  keyTime = data.k[0].t;
                } else {
                  for (iKey = 0; iKey < lenKey - 1; iKey += 1) {
                    if (time2 === data.k[iKey].t) {
                      index2 = iKey + 1;
                      keyTime = data.k[iKey].t;
                      break;
                    } else if (time2 > data.k[iKey].t && time2 < data.k[iKey + 1].t) {
                      if (time2 - data.k[iKey].t > data.k[iKey + 1].t - time2) {
                        index2 = iKey + 2;
                        keyTime = data.k[iKey + 1].t;
                      } else {
                        index2 = iKey + 1;
                        keyTime = data.k[iKey].t;
                      }
                      break;
                    }
                  }
                  if (index2 === -1) {
                    index2 = iKey + 1;
                    keyTime = data.k[iKey].t;
                  }
                }
              }
              var obKey = {};
              obKey.index = index2;
              obKey.time = keyTime / elem.comp.globalData.frameRate;
              return obKey;
            }
            function key(ind) {
              var obKey;
              var iKey;
              var lenKey;
              if (!data.k.length || typeof data.k[0] === "number") {
                throw new Error("The property has no keyframe at index " + ind);
              }
              ind -= 1;
              obKey = {
                time: data.k[ind].t / elem.comp.globalData.frameRate,
                value: []
              };
              var arr = Object.prototype.hasOwnProperty.call(data.k[ind], "s") ? data.k[ind].s : data.k[ind - 1].e;
              lenKey = arr.length;
              for (iKey = 0; iKey < lenKey; iKey += 1) {
                obKey[iKey] = arr[iKey];
                obKey.value[iKey] = arr[iKey];
              }
              return obKey;
            }
            function framesToTime(fr, fps) {
              if (!fps) {
                fps = elem.comp.globalData.frameRate;
              }
              return fr / fps;
            }
            function timeToFrames(t4, fps) {
              if (!t4 && t4 !== 0) {
                t4 = time;
              }
              if (!fps) {
                fps = elem.comp.globalData.frameRate;
              }
              return t4 * fps;
            }
            function seedRandom(seed) {
              BMMath.seedrandom(randSeed + seed);
            }
            function sourceRectAtTime() {
              return elem.sourceRectAtTime();
            }
            function substring(init5, end) {
              if (typeof value === "string") {
                if (end === void 0) {
                  return value.substring(init5);
                }
                return value.substring(init5, end);
              }
              return "";
            }
            function substr(init5, end) {
              if (typeof value === "string") {
                if (end === void 0) {
                  return value.substr(init5);
                }
                return value.substr(init5, end);
              }
              return "";
            }
            function posterizeTime(framesPerSecond) {
              time = framesPerSecond === 0 ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond;
              value = valueAtTime(time);
            }
            var time;
            var velocity;
            var value;
            var text;
            var textIndex;
            var textTotal;
            var selectorValue;
            var index = elem.data.ind;
            var hasParent = !!(elem.hierarchy && elem.hierarchy.length);
            var parent;
            var randSeed = Math.floor(Math.random() * 1e6);
            var globalData = elem.globalData;
            function executeExpression(_value) {
              value = _value;
              if (this.frameExpressionId === elem.globalData.frameId && this.propType !== "textSelector") {
                return value;
              }
              if (this.propType === "textSelector") {
                textIndex = this.textIndex;
                textTotal = this.textTotal;
                selectorValue = this.selectorValue;
              }
              if (!thisLayer) {
                text = elem.layerInterface.text;
                thisLayer = elem.layerInterface;
                thisComp = elem.comp.compInterface;
                toWorld = thisLayer.toWorld.bind(thisLayer);
                fromWorld = thisLayer.fromWorld.bind(thisLayer);
                fromComp = thisLayer.fromComp.bind(thisLayer);
                toComp = thisLayer.toComp.bind(thisLayer);
                mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;
                fromCompToSurface = fromComp;
              }
              if (!transform) {
                transform = elem.layerInterface("ADBE Transform Group");
                $bm_transform = transform;
                if (transform) {
                  anchorPoint = transform.anchorPoint;
                }
              }
              if (elemType === 4 && !content) {
                content = thisLayer("ADBE Root Vectors Group");
              }
              if (!effect) {
                effect = thisLayer(4);
              }
              hasParent = !!(elem.hierarchy && elem.hierarchy.length);
              if (hasParent && !parent) {
                parent = elem.hierarchy[0].layerInterface;
              }
              time = this.comp.renderedFrame / this.comp.globalData.frameRate;
              if (_needsRandom) {
                seedRandom(randSeed + time);
              }
              if (needsVelocity) {
                velocity = velocityAtTime(time);
              }
              expression_function();
              this.frameExpressionId = elem.globalData.frameId;
              scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt;
              return scoped_bm_rt;
            }
            executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData];
            return executeExpression;
          }
          ob.initiateExpression = initiateExpression;
          ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal];
          ob.resetFrame = resetFrame;
          return ob;
        }();
        var Expressions = function() {
          var ob2 = {};
          ob2.initExpressions = initExpressions;
          ob2.resetFrame = ExpressionManager.resetFrame;
          function initExpressions(animation) {
            var stackCount = 0;
            var registers = [];
            function pushExpression() {
              stackCount += 1;
            }
            function popExpression() {
              stackCount -= 1;
              if (stackCount === 0) {
                releaseInstances();
              }
            }
            function registerExpressionProperty(expression) {
              if (registers.indexOf(expression) === -1) {
                registers.push(expression);
              }
            }
            function releaseInstances() {
              var i6;
              var len = registers.length;
              for (i6 = 0; i6 < len; i6 += 1) {
                registers[i6].release();
              }
              registers.length = 0;
            }
            animation.renderer.compInterface = CompExpressionInterface(animation.renderer);
            animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);
            animation.renderer.globalData.pushExpression = pushExpression;
            animation.renderer.globalData.popExpression = popExpression;
            animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;
          }
          return ob2;
        }();
        var MaskManagerInterface = function() {
          function MaskInterface(mask2, data2) {
            this._mask = mask2;
            this._data = data2;
          }
          Object.defineProperty(MaskInterface.prototype, "maskPath", {
            get: function get() {
              if (this._mask.prop.k) {
                this._mask.prop.getValue();
              }
              return this._mask.prop;
            }
          });
          Object.defineProperty(MaskInterface.prototype, "maskOpacity", {
            get: function get() {
              if (this._mask.op.k) {
                this._mask.op.getValue();
              }
              return this._mask.op.v * 100;
            }
          });
          var MaskManager = function MaskManager2(maskManager) {
            var _masksInterfaces = createSizedArray(maskManager.viewData.length);
            var i6;
            var len = maskManager.viewData.length;
            for (i6 = 0; i6 < len; i6 += 1) {
              _masksInterfaces[i6] = new MaskInterface(maskManager.viewData[i6], maskManager.masksProperties[i6]);
            }
            var maskFunction = function maskFunction2(name2) {
              i6 = 0;
              while (i6 < len) {
                if (maskManager.masksProperties[i6].nm === name2) {
                  return _masksInterfaces[i6];
                }
                i6 += 1;
              }
              return null;
            };
            return maskFunction;
          };
          return MaskManager;
        }();
        var ExpressionPropertyInterface = /* @__PURE__ */ function() {
          var defaultUnidimensionalValue = {
            pv: 0,
            v: 0,
            mult: 1
          };
          var defaultMultidimensionalValue = {
            pv: [0, 0, 0],
            v: [0, 0, 0],
            mult: 1
          };
          function completeProperty(expressionValue, property2, type) {
            Object.defineProperty(expressionValue, "velocity", {
              get: function get() {
                return property2.getVelocityAtTime(property2.comp.currentFrame);
              }
            });
            expressionValue.numKeys = property2.keyframes ? property2.keyframes.length : 0;
            expressionValue.key = function(pos) {
              if (!expressionValue.numKeys) {
                return 0;
              }
              var value2 = "";
              if ("s" in property2.keyframes[pos - 1]) {
                value2 = property2.keyframes[pos - 1].s;
              } else if ("e" in property2.keyframes[pos - 2]) {
                value2 = property2.keyframes[pos - 2].e;
              } else {
                value2 = property2.keyframes[pos - 2].s;
              }
              var valueProp = type === "unidimensional" ? new Number(value2) : Object.assign({}, value2);
              valueProp.time = property2.keyframes[pos - 1].t / property2.elem.comp.globalData.frameRate;
              valueProp.value = type === "unidimensional" ? value2[0] : value2;
              return valueProp;
            };
            expressionValue.valueAtTime = property2.getValueAtTime;
            expressionValue.speedAtTime = property2.getSpeedAtTime;
            expressionValue.velocityAtTime = property2.getVelocityAtTime;
            expressionValue.propertyGroup = property2.propertyGroup;
          }
          function UnidimensionalPropertyInterface(property2) {
            if (!property2 || !("pv" in property2)) {
              property2 = defaultUnidimensionalValue;
            }
            var mult = 1 / property2.mult;
            var val2 = property2.pv * mult;
            var expressionValue = new Number(val2);
            expressionValue.value = val2;
            completeProperty(expressionValue, property2, "unidimensional");
            return function() {
              if (property2.k) {
                property2.getValue();
              }
              val2 = property2.v * mult;
              if (expressionValue.value !== val2) {
                expressionValue = new Number(val2);
                expressionValue.value = val2;
                completeProperty(expressionValue, property2, "unidimensional");
              }
              return expressionValue;
            };
          }
          function MultidimensionalPropertyInterface(property2) {
            if (!property2 || !("pv" in property2)) {
              property2 = defaultMultidimensionalValue;
            }
            var mult = 1 / property2.mult;
            var len = property2.data && property2.data.l || property2.pv.length;
            var expressionValue = createTypedArray("float32", len);
            var arrValue = createTypedArray("float32", len);
            expressionValue.value = arrValue;
            completeProperty(expressionValue, property2, "multidimensional");
            return function() {
              if (property2.k) {
                property2.getValue();
              }
              for (var i6 = 0; i6 < len; i6 += 1) {
                arrValue[i6] = property2.v[i6] * mult;
                expressionValue[i6] = arrValue[i6];
              }
              return expressionValue;
            };
          }
          function defaultGetter() {
            return defaultUnidimensionalValue;
          }
          return function(property2) {
            if (!property2) {
              return defaultGetter;
            }
            if (property2.propType === "unidimensional") {
              return UnidimensionalPropertyInterface(property2);
            }
            return MultidimensionalPropertyInterface(property2);
          };
        }();
        var TransformExpressionInterface = /* @__PURE__ */ function() {
          return function(transform2) {
            function _thisFunction(name2) {
              switch (name2) {
                case "scale":
                case "Scale":
                case "ADBE Scale":
                case 6:
                  return _thisFunction.scale;
                case "rotation":
                case "Rotation":
                case "ADBE Rotation":
                case "ADBE Rotate Z":
                case 10:
                  return _thisFunction.rotation;
                case "ADBE Rotate X":
                  return _thisFunction.xRotation;
                case "ADBE Rotate Y":
                  return _thisFunction.yRotation;
                case "position":
                case "Position":
                case "ADBE Position":
                case 2:
                  return _thisFunction.position;
                case "ADBE Position_0":
                  return _thisFunction.xPosition;
                case "ADBE Position_1":
                  return _thisFunction.yPosition;
                case "ADBE Position_2":
                  return _thisFunction.zPosition;
                case "anchorPoint":
                case "AnchorPoint":
                case "Anchor Point":
                case "ADBE AnchorPoint":
                case 1:
                  return _thisFunction.anchorPoint;
                case "opacity":
                case "Opacity":
                case 11:
                  return _thisFunction.opacity;
                default:
                  return null;
              }
            }
            Object.defineProperty(_thisFunction, "rotation", {
              get: ExpressionPropertyInterface(transform2.r || transform2.rz)
            });
            Object.defineProperty(_thisFunction, "zRotation", {
              get: ExpressionPropertyInterface(transform2.rz || transform2.r)
            });
            Object.defineProperty(_thisFunction, "xRotation", {
              get: ExpressionPropertyInterface(transform2.rx)
            });
            Object.defineProperty(_thisFunction, "yRotation", {
              get: ExpressionPropertyInterface(transform2.ry)
            });
            Object.defineProperty(_thisFunction, "scale", {
              get: ExpressionPropertyInterface(transform2.s)
            });
            var _px;
            var _py;
            var _pz;
            var _transformFactory;
            if (transform2.p) {
              _transformFactory = ExpressionPropertyInterface(transform2.p);
            } else {
              _px = ExpressionPropertyInterface(transform2.px);
              _py = ExpressionPropertyInterface(transform2.py);
              if (transform2.pz) {
                _pz = ExpressionPropertyInterface(transform2.pz);
              }
            }
            Object.defineProperty(_thisFunction, "position", {
              get: function get() {
                if (transform2.p) {
                  return _transformFactory();
                }
                return [_px(), _py(), _pz ? _pz() : 0];
              }
            });
            Object.defineProperty(_thisFunction, "xPosition", {
              get: ExpressionPropertyInterface(transform2.px)
            });
            Object.defineProperty(_thisFunction, "yPosition", {
              get: ExpressionPropertyInterface(transform2.py)
            });
            Object.defineProperty(_thisFunction, "zPosition", {
              get: ExpressionPropertyInterface(transform2.pz)
            });
            Object.defineProperty(_thisFunction, "anchorPoint", {
              get: ExpressionPropertyInterface(transform2.a)
            });
            Object.defineProperty(_thisFunction, "opacity", {
              get: ExpressionPropertyInterface(transform2.o)
            });
            Object.defineProperty(_thisFunction, "skew", {
              get: ExpressionPropertyInterface(transform2.sk)
            });
            Object.defineProperty(_thisFunction, "skewAxis", {
              get: ExpressionPropertyInterface(transform2.sa)
            });
            Object.defineProperty(_thisFunction, "orientation", {
              get: ExpressionPropertyInterface(transform2.or)
            });
            return _thisFunction;
          };
        }();
        var LayerExpressionInterface = /* @__PURE__ */ function() {
          function getMatrix(time2) {
            var toWorldMat = new Matrix();
            if (time2 !== void 0) {
              var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time2);
              propMatrix.clone(toWorldMat);
            } else {
              var transformMat = this._elem.finalTransform.mProp;
              transformMat.applyToMatrix(toWorldMat);
            }
            return toWorldMat;
          }
          function toWorldVec(arr, time2) {
            var toWorldMat = this.getMatrix(time2);
            toWorldMat.props[12] = 0;
            toWorldMat.props[13] = 0;
            toWorldMat.props[14] = 0;
            return this.applyPoint(toWorldMat, arr);
          }
          function toWorld2(arr, time2) {
            var toWorldMat = this.getMatrix(time2);
            return this.applyPoint(toWorldMat, arr);
          }
          function fromWorldVec(arr, time2) {
            var toWorldMat = this.getMatrix(time2);
            toWorldMat.props[12] = 0;
            toWorldMat.props[13] = 0;
            toWorldMat.props[14] = 0;
            return this.invertPoint(toWorldMat, arr);
          }
          function fromWorld2(arr, time2) {
            var toWorldMat = this.getMatrix(time2);
            return this.invertPoint(toWorldMat, arr);
          }
          function applyPoint(matrix, arr) {
            if (this._elem.hierarchy && this._elem.hierarchy.length) {
              var i6;
              var len = this._elem.hierarchy.length;
              for (i6 = 0; i6 < len; i6 += 1) {
                this._elem.hierarchy[i6].finalTransform.mProp.applyToMatrix(matrix);
              }
            }
            return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0);
          }
          function invertPoint(matrix, arr) {
            if (this._elem.hierarchy && this._elem.hierarchy.length) {
              var i6;
              var len = this._elem.hierarchy.length;
              for (i6 = 0; i6 < len; i6 += 1) {
                this._elem.hierarchy[i6].finalTransform.mProp.applyToMatrix(matrix);
              }
            }
            return matrix.inversePoint(arr);
          }
          function fromComp2(arr) {
            var toWorldMat = new Matrix();
            toWorldMat.reset();
            this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);
            if (this._elem.hierarchy && this._elem.hierarchy.length) {
              var i6;
              var len = this._elem.hierarchy.length;
              for (i6 = 0; i6 < len; i6 += 1) {
                this._elem.hierarchy[i6].finalTransform.mProp.applyToMatrix(toWorldMat);
              }
              return toWorldMat.inversePoint(arr);
            }
            return toWorldMat.inversePoint(arr);
          }
          function sampleImage() {
            return [1, 1, 1, 1];
          }
          return function(elem2) {
            var transformInterface;
            function _registerMaskInterface(maskManager) {
              _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem2);
            }
            function _registerEffectsInterface(effects) {
              _thisLayerFunction.effect = effects;
            }
            function _thisLayerFunction(name2) {
              switch (name2) {
                case "ADBE Root Vectors Group":
                case "Contents":
                case 2:
                  return _thisLayerFunction.shapeInterface;
                case 1:
                case 6:
                case "Transform":
                case "transform":
                case "ADBE Transform Group":
                  return transformInterface;
                case 4:
                case "ADBE Effect Parade":
                case "effects":
                case "Effects":
                  return _thisLayerFunction.effect;
                case "ADBE Text Properties":
                  return _thisLayerFunction.textInterface;
                default:
                  return null;
              }
            }
            _thisLayerFunction.getMatrix = getMatrix;
            _thisLayerFunction.invertPoint = invertPoint;
            _thisLayerFunction.applyPoint = applyPoint;
            _thisLayerFunction.toWorld = toWorld2;
            _thisLayerFunction.toWorldVec = toWorldVec;
            _thisLayerFunction.fromWorld = fromWorld2;
            _thisLayerFunction.fromWorldVec = fromWorldVec;
            _thisLayerFunction.toComp = toWorld2;
            _thisLayerFunction.fromComp = fromComp2;
            _thisLayerFunction.sampleImage = sampleImage;
            _thisLayerFunction.sourceRectAtTime = elem2.sourceRectAtTime.bind(elem2);
            _thisLayerFunction._elem = elem2;
            transformInterface = TransformExpressionInterface(elem2.finalTransform.mProp);
            var anchorPointDescriptor = getDescriptor(transformInterface, "anchorPoint");
            Object.defineProperties(_thisLayerFunction, {
              hasParent: {
                get: function get() {
                  return elem2.hierarchy.length;
                }
              },
              parent: {
                get: function get() {
                  return elem2.hierarchy[0].layerInterface;
                }
              },
              rotation: getDescriptor(transformInterface, "rotation"),
              scale: getDescriptor(transformInterface, "scale"),
              position: getDescriptor(transformInterface, "position"),
              opacity: getDescriptor(transformInterface, "opacity"),
              anchorPoint: anchorPointDescriptor,
              anchor_point: anchorPointDescriptor,
              transform: {
                get: function get() {
                  return transformInterface;
                }
              },
              active: {
                get: function get() {
                  return elem2.isInRange;
                }
              }
            });
            _thisLayerFunction.startTime = elem2.data.st;
            _thisLayerFunction.index = elem2.data.ind;
            _thisLayerFunction.source = elem2.data.refId;
            _thisLayerFunction.height = elem2.data.ty === 0 ? elem2.data.h : 100;
            _thisLayerFunction.width = elem2.data.ty === 0 ? elem2.data.w : 100;
            _thisLayerFunction.inPoint = elem2.data.ip / elem2.comp.globalData.frameRate;
            _thisLayerFunction.outPoint = elem2.data.op / elem2.comp.globalData.frameRate;
            _thisLayerFunction._name = elem2.data.nm;
            _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
            _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;
            return _thisLayerFunction;
          };
        }();
        var propertyGroupFactory = /* @__PURE__ */ function() {
          return function(interfaceFunction, parentPropertyGroup) {
            return function(val2) {
              val2 = val2 === void 0 ? 1 : val2;
              if (val2 <= 0) {
                return interfaceFunction;
              }
              return parentPropertyGroup(val2 - 1);
            };
          };
        }();
        var PropertyInterface = /* @__PURE__ */ function() {
          return function(propertyName, propertyGroup) {
            var interfaceFunction = {
              _name: propertyName
            };
            function _propertyGroup(val2) {
              val2 = val2 === void 0 ? 1 : val2;
              if (val2 <= 0) {
                return interfaceFunction;
              }
              return propertyGroup(val2 - 1);
            }
            return _propertyGroup;
          };
        }();
        var EffectsExpressionInterface = /* @__PURE__ */ function() {
          var ob2 = {
            createEffectsInterface
          };
          function createEffectsInterface(elem2, propertyGroup) {
            if (elem2.effectsManager) {
              var effectElements = [];
              var effectsData = elem2.data.ef;
              var i6;
              var len = elem2.effectsManager.effectElements.length;
              for (i6 = 0; i6 < len; i6 += 1) {
                effectElements.push(createGroupInterface(effectsData[i6], elem2.effectsManager.effectElements[i6], propertyGroup, elem2));
              }
              var effects = elem2.data.ef || [];
              var groupInterface = function groupInterface2(name2) {
                i6 = 0;
                len = effects.length;
                while (i6 < len) {
                  if (name2 === effects[i6].nm || name2 === effects[i6].mn || name2 === effects[i6].ix) {
                    return effectElements[i6];
                  }
                  i6 += 1;
                }
                return null;
              };
              Object.defineProperty(groupInterface, "numProperties", {
                get: function get() {
                  return effects.length;
                }
              });
              return groupInterface;
            }
            return null;
          }
          function createGroupInterface(data2, elements, propertyGroup, elem2) {
            function groupInterface(name2) {
              var effects = data2.ef;
              var i7 = 0;
              var len2 = effects.length;
              while (i7 < len2) {
                if (name2 === effects[i7].nm || name2 === effects[i7].mn || name2 === effects[i7].ix) {
                  if (effects[i7].ty === 5) {
                    return effectElements[i7];
                  }
                  return effectElements[i7]();
                }
                i7 += 1;
              }
              throw new Error();
            }
            var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);
            var effectElements = [];
            var i6;
            var len = data2.ef.length;
            for (i6 = 0; i6 < len; i6 += 1) {
              if (data2.ef[i6].ty === 5) {
                effectElements.push(createGroupInterface(data2.ef[i6], elements.effectElements[i6], elements.effectElements[i6].propertyGroup, elem2));
              } else {
                effectElements.push(createValueInterface(elements.effectElements[i6], data2.ef[i6].ty, elem2, _propertyGroup));
              }
            }
            if (data2.mn === "ADBE Color Control") {
              Object.defineProperty(groupInterface, "color", {
                get: function get() {
                  return effectElements[0]();
                }
              });
            }
            Object.defineProperties(groupInterface, {
              numProperties: {
                get: function get() {
                  return data2.np;
                }
              },
              _name: {
                value: data2.nm
              },
              propertyGroup: {
                value: _propertyGroup
              }
            });
            groupInterface.enabled = data2.en !== 0;
            groupInterface.active = groupInterface.enabled;
            return groupInterface;
          }
          function createValueInterface(element, type, elem2, propertyGroup) {
            var expressionProperty = ExpressionPropertyInterface(element.p);
            function interfaceFunction() {
              if (type === 10) {
                return elem2.comp.compInterface(element.p.v);
              }
              return expressionProperty();
            }
            if (element.p.setGroupProperty) {
              element.p.setGroupProperty(PropertyInterface("", propertyGroup));
            }
            return interfaceFunction;
          }
          return ob2;
        }();
        var ShapePathInterface = /* @__PURE__ */ function() {
          return function pathInterfaceFactory(shape, view, propertyGroup) {
            var prop = view.sh;
            function interfaceFunction(val2) {
              if (val2 === "Shape" || val2 === "shape" || val2 === "Path" || val2 === "path" || val2 === "ADBE Vector Shape" || val2 === 2) {
                return interfaceFunction.path;
              }
              return null;
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            prop.setGroupProperty(PropertyInterface("Path", _propertyGroup));
            Object.defineProperties(interfaceFunction, {
              path: {
                get: function get() {
                  if (prop.k) {
                    prop.getValue();
                  }
                  return prop;
                }
              },
              shape: {
                get: function get() {
                  if (prop.k) {
                    prop.getValue();
                  }
                  return prop;
                }
              },
              _name: {
                value: shape.nm
              },
              ix: {
                value: shape.ix
              },
              propertyIndex: {
                value: shape.ix
              },
              mn: {
                value: shape.mn
              },
              propertyGroup: {
                value: propertyGroup
              }
            });
            return interfaceFunction;
          };
        }();
        var ShapeExpressionInterface = /* @__PURE__ */ function() {
          function iterateElements(shapes, view, propertyGroup) {
            var arr = [];
            var i6;
            var len = shapes ? shapes.length : 0;
            for (i6 = 0; i6 < len; i6 += 1) {
              if (shapes[i6].ty === "gr") {
                arr.push(groupInterfaceFactory(shapes[i6], view[i6], propertyGroup));
              } else if (shapes[i6].ty === "fl") {
                arr.push(fillInterfaceFactory(shapes[i6], view[i6], propertyGroup));
              } else if (shapes[i6].ty === "st") {
                arr.push(strokeInterfaceFactory(shapes[i6], view[i6], propertyGroup));
              } else if (shapes[i6].ty === "tm") {
                arr.push(trimInterfaceFactory(shapes[i6], view[i6], propertyGroup));
              } else if (shapes[i6].ty === "tr") {
              } else if (shapes[i6].ty === "el") {
                arr.push(ellipseInterfaceFactory(shapes[i6], view[i6], propertyGroup));
              } else if (shapes[i6].ty === "sr") {
                arr.push(starInterfaceFactory(shapes[i6], view[i6], propertyGroup));
              } else if (shapes[i6].ty === "sh") {
                arr.push(ShapePathInterface(shapes[i6], view[i6], propertyGroup));
              } else if (shapes[i6].ty === "rc") {
                arr.push(rectInterfaceFactory(shapes[i6], view[i6], propertyGroup));
              } else if (shapes[i6].ty === "rd") {
                arr.push(roundedInterfaceFactory(shapes[i6], view[i6], propertyGroup));
              } else if (shapes[i6].ty === "rp") {
                arr.push(repeaterInterfaceFactory(shapes[i6], view[i6], propertyGroup));
              } else if (shapes[i6].ty === "gf") {
                arr.push(gradientFillInterfaceFactory(shapes[i6], view[i6], propertyGroup));
              } else {
                arr.push(defaultInterfaceFactory(shapes[i6], view[i6], propertyGroup));
              }
            }
            return arr;
          }
          function contentsInterfaceFactory(shape, view, propertyGroup) {
            var interfaces2;
            var interfaceFunction = function _interfaceFunction(value2) {
              var i6 = 0;
              var len = interfaces2.length;
              while (i6 < len) {
                if (interfaces2[i6]._name === value2 || interfaces2[i6].mn === value2 || interfaces2[i6].propertyIndex === value2 || interfaces2[i6].ix === value2 || interfaces2[i6].ind === value2) {
                  return interfaces2[i6];
                }
                i6 += 1;
              }
              if (typeof value2 === "number") {
                return interfaces2[value2 - 1];
              }
              return null;
            };
            interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            interfaces2 = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);
            interfaceFunction.numProperties = interfaces2.length;
            var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
            interfaceFunction.transform = transformInterface;
            interfaceFunction.propertyIndex = shape.cix;
            interfaceFunction._name = shape.nm;
            return interfaceFunction;
          }
          function groupInterfaceFactory(shape, view, propertyGroup) {
            var interfaceFunction = function _interfaceFunction(value2) {
              switch (value2) {
                case "ADBE Vectors Group":
                case "Contents":
                case 2:
                  return interfaceFunction.content;
                // Not necessary for now. Keeping them here in case a new case appears
                // case 'ADBE Vector Transform Group':
                // case 3:
                default:
                  return interfaceFunction.transform;
              }
            };
            interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            var content2 = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);
            var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
            interfaceFunction.content = content2;
            interfaceFunction.transform = transformInterface;
            Object.defineProperty(interfaceFunction, "_name", {
              get: function get() {
                return shape.nm;
              }
            });
            interfaceFunction.numProperties = shape.np;
            interfaceFunction.propertyIndex = shape.ix;
            interfaceFunction.nm = shape.nm;
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
          }
          function fillInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(val2) {
              if (val2 === "Color" || val2 === "color") {
                return interfaceFunction.color;
              }
              if (val2 === "Opacity" || val2 === "opacity") {
                return interfaceFunction.opacity;
              }
              return null;
            }
            Object.defineProperties(interfaceFunction, {
              color: {
                get: ExpressionPropertyInterface(view.c)
              },
              opacity: {
                get: ExpressionPropertyInterface(view.o)
              },
              _name: {
                value: shape.nm
              },
              mn: {
                value: shape.mn
              }
            });
            view.c.setGroupProperty(PropertyInterface("Color", propertyGroup));
            view.o.setGroupProperty(PropertyInterface("Opacity", propertyGroup));
            return interfaceFunction;
          }
          function gradientFillInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(val2) {
              if (val2 === "Start Point" || val2 === "start point") {
                return interfaceFunction.startPoint;
              }
              if (val2 === "End Point" || val2 === "end point") {
                return interfaceFunction.endPoint;
              }
              if (val2 === "Opacity" || val2 === "opacity") {
                return interfaceFunction.opacity;
              }
              return null;
            }
            Object.defineProperties(interfaceFunction, {
              startPoint: {
                get: ExpressionPropertyInterface(view.s)
              },
              endPoint: {
                get: ExpressionPropertyInterface(view.e)
              },
              opacity: {
                get: ExpressionPropertyInterface(view.o)
              },
              type: {
                get: function get() {
                  return "a";
                }
              },
              _name: {
                value: shape.nm
              },
              mn: {
                value: shape.mn
              }
            });
            view.s.setGroupProperty(PropertyInterface("Start Point", propertyGroup));
            view.e.setGroupProperty(PropertyInterface("End Point", propertyGroup));
            view.o.setGroupProperty(PropertyInterface("Opacity", propertyGroup));
            return interfaceFunction;
          }
          function defaultInterfaceFactory() {
            function interfaceFunction() {
              return null;
            }
            return interfaceFunction;
          }
          function strokeInterfaceFactory(shape, view, propertyGroup) {
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);
            function addPropertyToDashOb(i7) {
              Object.defineProperty(dashOb, shape.d[i7].nm, {
                get: ExpressionPropertyInterface(view.d.dataProps[i7].p)
              });
            }
            var i6;
            var len = shape.d ? shape.d.length : 0;
            var dashOb = {};
            for (i6 = 0; i6 < len; i6 += 1) {
              addPropertyToDashOb(i6);
              view.d.dataProps[i6].p.setGroupProperty(_dashPropertyGroup);
            }
            function interfaceFunction(val2) {
              if (val2 === "Color" || val2 === "color") {
                return interfaceFunction.color;
              }
              if (val2 === "Opacity" || val2 === "opacity") {
                return interfaceFunction.opacity;
              }
              if (val2 === "Stroke Width" || val2 === "stroke width") {
                return interfaceFunction.strokeWidth;
              }
              return null;
            }
            Object.defineProperties(interfaceFunction, {
              color: {
                get: ExpressionPropertyInterface(view.c)
              },
              opacity: {
                get: ExpressionPropertyInterface(view.o)
              },
              strokeWidth: {
                get: ExpressionPropertyInterface(view.w)
              },
              dash: {
                get: function get() {
                  return dashOb;
                }
              },
              _name: {
                value: shape.nm
              },
              mn: {
                value: shape.mn
              }
            });
            view.c.setGroupProperty(PropertyInterface("Color", _propertyGroup));
            view.o.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
            view.w.setGroupProperty(PropertyInterface("Stroke Width", _propertyGroup));
            return interfaceFunction;
          }
          function trimInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(val2) {
              if (val2 === shape.e.ix || val2 === "End" || val2 === "end") {
                return interfaceFunction.end;
              }
              if (val2 === shape.s.ix) {
                return interfaceFunction.start;
              }
              if (val2 === shape.o.ix) {
                return interfaceFunction.offset;
              }
              return null;
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            interfaceFunction.propertyIndex = shape.ix;
            view.s.setGroupProperty(PropertyInterface("Start", _propertyGroup));
            view.e.setGroupProperty(PropertyInterface("End", _propertyGroup));
            view.o.setGroupProperty(PropertyInterface("Offset", _propertyGroup));
            interfaceFunction.propertyIndex = shape.ix;
            interfaceFunction.propertyGroup = propertyGroup;
            Object.defineProperties(interfaceFunction, {
              start: {
                get: ExpressionPropertyInterface(view.s)
              },
              end: {
                get: ExpressionPropertyInterface(view.e)
              },
              offset: {
                get: ExpressionPropertyInterface(view.o)
              },
              _name: {
                value: shape.nm
              }
            });
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
          }
          function transformInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(value2) {
              if (shape.a.ix === value2 || value2 === "Anchor Point") {
                return interfaceFunction.anchorPoint;
              }
              if (shape.o.ix === value2 || value2 === "Opacity") {
                return interfaceFunction.opacity;
              }
              if (shape.p.ix === value2 || value2 === "Position") {
                return interfaceFunction.position;
              }
              if (shape.r.ix === value2 || value2 === "Rotation" || value2 === "ADBE Vector Rotation") {
                return interfaceFunction.rotation;
              }
              if (shape.s.ix === value2 || value2 === "Scale") {
                return interfaceFunction.scale;
              }
              if (shape.sk && shape.sk.ix === value2 || value2 === "Skew") {
                return interfaceFunction.skew;
              }
              if (shape.sa && shape.sa.ix === value2 || value2 === "Skew Axis") {
                return interfaceFunction.skewAxis;
              }
              return null;
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            view.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
            view.transform.mProps.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
            view.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", _propertyGroup));
            view.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", _propertyGroup));
            view.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
            if (view.transform.mProps.sk) {
              view.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", _propertyGroup));
              view.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", _propertyGroup));
            }
            view.transform.op.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
            Object.defineProperties(interfaceFunction, {
              opacity: {
                get: ExpressionPropertyInterface(view.transform.mProps.o)
              },
              position: {
                get: ExpressionPropertyInterface(view.transform.mProps.p)
              },
              anchorPoint: {
                get: ExpressionPropertyInterface(view.transform.mProps.a)
              },
              scale: {
                get: ExpressionPropertyInterface(view.transform.mProps.s)
              },
              rotation: {
                get: ExpressionPropertyInterface(view.transform.mProps.r)
              },
              skew: {
                get: ExpressionPropertyInterface(view.transform.mProps.sk)
              },
              skewAxis: {
                get: ExpressionPropertyInterface(view.transform.mProps.sa)
              },
              _name: {
                value: shape.nm
              }
            });
            interfaceFunction.ty = "tr";
            interfaceFunction.mn = shape.mn;
            interfaceFunction.propertyGroup = propertyGroup;
            return interfaceFunction;
          }
          function ellipseInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(value2) {
              if (shape.p.ix === value2) {
                return interfaceFunction.position;
              }
              if (shape.s.ix === value2) {
                return interfaceFunction.size;
              }
              return null;
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            interfaceFunction.propertyIndex = shape.ix;
            var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
            prop.s.setGroupProperty(PropertyInterface("Size", _propertyGroup));
            prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
            Object.defineProperties(interfaceFunction, {
              size: {
                get: ExpressionPropertyInterface(prop.s)
              },
              position: {
                get: ExpressionPropertyInterface(prop.p)
              },
              _name: {
                value: shape.nm
              }
            });
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
          }
          function starInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(value2) {
              if (shape.p.ix === value2) {
                return interfaceFunction.position;
              }
              if (shape.r.ix === value2) {
                return interfaceFunction.rotation;
              }
              if (shape.pt.ix === value2) {
                return interfaceFunction.points;
              }
              if (shape.or.ix === value2 || value2 === "ADBE Vector Star Outer Radius") {
                return interfaceFunction.outerRadius;
              }
              if (shape.os.ix === value2) {
                return interfaceFunction.outerRoundness;
              }
              if (shape.ir && (shape.ir.ix === value2 || value2 === "ADBE Vector Star Inner Radius")) {
                return interfaceFunction.innerRadius;
              }
              if (shape.is && shape.is.ix === value2) {
                return interfaceFunction.innerRoundness;
              }
              return null;
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
            interfaceFunction.propertyIndex = shape.ix;
            prop.or.setGroupProperty(PropertyInterface("Outer Radius", _propertyGroup));
            prop.os.setGroupProperty(PropertyInterface("Outer Roundness", _propertyGroup));
            prop.pt.setGroupProperty(PropertyInterface("Points", _propertyGroup));
            prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
            prop.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
            if (shape.ir) {
              prop.ir.setGroupProperty(PropertyInterface("Inner Radius", _propertyGroup));
              prop.is.setGroupProperty(PropertyInterface("Inner Roundness", _propertyGroup));
            }
            Object.defineProperties(interfaceFunction, {
              position: {
                get: ExpressionPropertyInterface(prop.p)
              },
              rotation: {
                get: ExpressionPropertyInterface(prop.r)
              },
              points: {
                get: ExpressionPropertyInterface(prop.pt)
              },
              outerRadius: {
                get: ExpressionPropertyInterface(prop.or)
              },
              outerRoundness: {
                get: ExpressionPropertyInterface(prop.os)
              },
              innerRadius: {
                get: ExpressionPropertyInterface(prop.ir)
              },
              innerRoundness: {
                get: ExpressionPropertyInterface(prop.is)
              },
              _name: {
                value: shape.nm
              }
            });
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
          }
          function rectInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(value2) {
              if (shape.p.ix === value2) {
                return interfaceFunction.position;
              }
              if (shape.r.ix === value2) {
                return interfaceFunction.roundness;
              }
              if (shape.s.ix === value2 || value2 === "Size" || value2 === "ADBE Vector Rect Size") {
                return interfaceFunction.size;
              }
              return null;
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
            interfaceFunction.propertyIndex = shape.ix;
            prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
            prop.s.setGroupProperty(PropertyInterface("Size", _propertyGroup));
            prop.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
            Object.defineProperties(interfaceFunction, {
              position: {
                get: ExpressionPropertyInterface(prop.p)
              },
              roundness: {
                get: ExpressionPropertyInterface(prop.r)
              },
              size: {
                get: ExpressionPropertyInterface(prop.s)
              },
              _name: {
                value: shape.nm
              }
            });
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
          }
          function roundedInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(value2) {
              if (shape.r.ix === value2 || value2 === "Round Corners 1") {
                return interfaceFunction.radius;
              }
              return null;
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            var prop = view;
            interfaceFunction.propertyIndex = shape.ix;
            prop.rd.setGroupProperty(PropertyInterface("Radius", _propertyGroup));
            Object.defineProperties(interfaceFunction, {
              radius: {
                get: ExpressionPropertyInterface(prop.rd)
              },
              _name: {
                value: shape.nm
              }
            });
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
          }
          function repeaterInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(value2) {
              if (shape.c.ix === value2 || value2 === "Copies") {
                return interfaceFunction.copies;
              }
              if (shape.o.ix === value2 || value2 === "Offset") {
                return interfaceFunction.offset;
              }
              return null;
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            var prop = view;
            interfaceFunction.propertyIndex = shape.ix;
            prop.c.setGroupProperty(PropertyInterface("Copies", _propertyGroup));
            prop.o.setGroupProperty(PropertyInterface("Offset", _propertyGroup));
            Object.defineProperties(interfaceFunction, {
              copies: {
                get: ExpressionPropertyInterface(prop.c)
              },
              offset: {
                get: ExpressionPropertyInterface(prop.o)
              },
              _name: {
                value: shape.nm
              }
            });
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
          }
          return function(shapes, view, propertyGroup) {
            var interfaces2;
            function _interfaceFunction(value2) {
              if (typeof value2 === "number") {
                value2 = value2 === void 0 ? 1 : value2;
                if (value2 === 0) {
                  return propertyGroup;
                }
                return interfaces2[value2 - 1];
              }
              var i6 = 0;
              var len = interfaces2.length;
              while (i6 < len) {
                if (interfaces2[i6]._name === value2) {
                  return interfaces2[i6];
                }
                i6 += 1;
              }
              return null;
            }
            function parentGroupWrapper() {
              return propertyGroup;
            }
            _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper);
            interfaces2 = iterateElements(shapes, view, _interfaceFunction.propertyGroup);
            _interfaceFunction.numProperties = interfaces2.length;
            _interfaceFunction._name = "Contents";
            return _interfaceFunction;
          };
        }();
        var TextExpressionInterface = /* @__PURE__ */ function() {
          return function(elem2) {
            var _sourceText;
            function _thisLayerFunction(name2) {
              switch (name2) {
                case "ADBE Text Document":
                  return _thisLayerFunction.sourceText;
                default:
                  return null;
              }
            }
            Object.defineProperty(_thisLayerFunction, "sourceText", {
              get: function get() {
                elem2.textProperty.getValue();
                var stringValue = elem2.textProperty.currentData.t;
                if (!_sourceText || stringValue !== _sourceText.value) {
                  _sourceText = new String(stringValue);
                  _sourceText.value = stringValue || new String(stringValue);
                  Object.defineProperty(_sourceText, "style", {
                    get: function get2() {
                      return {
                        fillColor: elem2.textProperty.currentData.fc
                      };
                    }
                  });
                }
                return _sourceText;
              }
            });
            return _thisLayerFunction;
          };
        }();
        function _typeof(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function _typeof3(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof = function _typeof3(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof(obj);
        }
        var FootageInterface = /* @__PURE__ */ function() {
          var outlineInterfaceFactory = function outlineInterfaceFactory2(elem2) {
            var currentPropertyName = "";
            var currentProperty = elem2.getFootageData();
            function init5() {
              currentPropertyName = "";
              currentProperty = elem2.getFootageData();
              return searchProperty;
            }
            function searchProperty(value2) {
              if (currentProperty[value2]) {
                currentPropertyName = value2;
                currentProperty = currentProperty[value2];
                if (_typeof(currentProperty) === "object") {
                  return searchProperty;
                }
                return currentProperty;
              }
              var propertyNameIndex = value2.indexOf(currentPropertyName);
              if (propertyNameIndex !== -1) {
                var index2 = parseInt(value2.substr(propertyNameIndex + currentPropertyName.length), 10);
                currentProperty = currentProperty[index2];
                if (_typeof(currentProperty) === "object") {
                  return searchProperty;
                }
                return currentProperty;
              }
              return "";
            }
            return init5;
          };
          var dataInterfaceFactory = function dataInterfaceFactory2(elem2) {
            function interfaceFunction(value2) {
              if (value2 === "Outline") {
                return interfaceFunction.outlineInterface();
              }
              return null;
            }
            interfaceFunction._name = "Outline";
            interfaceFunction.outlineInterface = outlineInterfaceFactory(elem2);
            return interfaceFunction;
          };
          return function(elem2) {
            function _interfaceFunction(value2) {
              if (value2 === "Data") {
                return _interfaceFunction.dataInterface;
              }
              return null;
            }
            _interfaceFunction._name = "Data";
            _interfaceFunction.dataInterface = dataInterfaceFactory(elem2);
            return _interfaceFunction;
          };
        }();
        var interfaces = {
          layer: LayerExpressionInterface,
          effects: EffectsExpressionInterface,
          comp: CompExpressionInterface,
          shape: ShapeExpressionInterface,
          text: TextExpressionInterface,
          footage: FootageInterface
        };
        function getInterface(type) {
          return interfaces[type] || null;
        }
        var expressionHelpers = /* @__PURE__ */ function() {
          function searchExpressions(elem2, data2, prop) {
            if (data2.x) {
              prop.k = true;
              prop.x = true;
              prop.initiateExpression = ExpressionManager.initiateExpression;
              prop.effectsSequence.push(prop.initiateExpression(elem2, data2, prop).bind(prop));
            }
          }
          function getValueAtTime(frameNum) {
            frameNum *= this.elem.globalData.frameRate;
            frameNum -= this.offsetTime;
            if (frameNum !== this._cachingAtTime.lastFrame) {
              this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;
              this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);
              this._cachingAtTime.lastFrame = frameNum;
            }
            return this._cachingAtTime.value;
          }
          function getSpeedAtTime(frameNum) {
            var delta = -0.01;
            var v1 = this.getValueAtTime(frameNum);
            var v2 = this.getValueAtTime(frameNum + delta);
            var speed = 0;
            if (v1.length) {
              var i6;
              for (i6 = 0; i6 < v1.length; i6 += 1) {
                speed += Math.pow(v2[i6] - v1[i6], 2);
              }
              speed = Math.sqrt(speed) * 100;
            } else {
              speed = 0;
            }
            return speed;
          }
          function getVelocityAtTime(frameNum) {
            if (this.vel !== void 0) {
              return this.vel;
            }
            var delta = -1e-3;
            var v1 = this.getValueAtTime(frameNum);
            var v2 = this.getValueAtTime(frameNum + delta);
            var velocity2;
            if (v1.length) {
              velocity2 = createTypedArray("float32", v1.length);
              var i6;
              for (i6 = 0; i6 < v1.length; i6 += 1) {
                velocity2[i6] = (v2[i6] - v1[i6]) / delta;
              }
            } else {
              velocity2 = (v2 - v1) / delta;
            }
            return velocity2;
          }
          function getStaticValueAtTime() {
            return this.pv;
          }
          function setGroupProperty(propertyGroup) {
            this.propertyGroup = propertyGroup;
          }
          return {
            searchExpressions,
            getSpeedAtTime,
            getVelocityAtTime,
            getValueAtTime,
            getStaticValueAtTime,
            setGroupProperty
          };
        }();
        function addPropertyDecorator() {
          function loopOut2(type, duration, durationFlag) {
            if (!this.k || !this.keyframes) {
              return this.pv;
            }
            type = type ? type.toLowerCase() : "";
            var currentFrame = this.comp.renderedFrame;
            var keyframes = this.keyframes;
            var lastKeyFrame = keyframes[keyframes.length - 1].t;
            if (currentFrame <= lastKeyFrame) {
              return this.pv;
            }
            var cycleDuration;
            var firstKeyFrame;
            if (!durationFlag) {
              if (!duration || duration > keyframes.length - 1) {
                duration = keyframes.length - 1;
              }
              firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
              cycleDuration = lastKeyFrame - firstKeyFrame;
            } else {
              if (!duration) {
                cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);
              } else {
                cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration);
              }
              firstKeyFrame = lastKeyFrame - cycleDuration;
            }
            var i6;
            var len;
            var ret;
            if (type === "pingpong") {
              var iterations = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
              if (iterations % 2 !== 0) {
                return this.getValueAtTime((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
              }
            } else if (type === "offset") {
              var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
              var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
              var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
              var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
              if (this.pv.length) {
                ret = new Array(initV.length);
                len = ret.length;
                for (i6 = 0; i6 < len; i6 += 1) {
                  ret[i6] = (endV[i6] - initV[i6]) * repeats + current[i6];
                }
                return ret;
              }
              return (endV - initV) * repeats + current;
            } else if (type === "continue") {
              var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
              var nextLastValue = this.getValueAtTime((lastKeyFrame - 1e-3) / this.comp.globalData.frameRate, 0);
              if (this.pv.length) {
                ret = new Array(lastValue.length);
                len = ret.length;
                for (i6 = 0; i6 < len; i6 += 1) {
                  ret[i6] = lastValue[i6] + (lastValue[i6] - nextLastValue[i6]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 5e-4;
                }
                return ret;
              }
              return lastValue + (lastValue - nextLastValue) * ((currentFrame - lastKeyFrame) / 1e-3);
            }
            return this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
          }
          function loopIn2(type, duration, durationFlag) {
            if (!this.k) {
              return this.pv;
            }
            type = type ? type.toLowerCase() : "";
            var currentFrame = this.comp.renderedFrame;
            var keyframes = this.keyframes;
            var firstKeyFrame = keyframes[0].t;
            if (currentFrame >= firstKeyFrame) {
              return this.pv;
            }
            var cycleDuration;
            var lastKeyFrame;
            if (!durationFlag) {
              if (!duration || duration > keyframes.length - 1) {
                duration = keyframes.length - 1;
              }
              lastKeyFrame = keyframes[duration].t;
              cycleDuration = lastKeyFrame - firstKeyFrame;
            } else {
              if (!duration) {
                cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame);
              } else {
                cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration);
              }
              lastKeyFrame = firstKeyFrame + cycleDuration;
            }
            var i6;
            var len;
            var ret;
            if (type === "pingpong") {
              var iterations = Math.floor((firstKeyFrame - currentFrame) / cycleDuration);
              if (iterations % 2 === 0) {
                return this.getValueAtTime(((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
              }
            } else if (type === "offset") {
              var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
              var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
              var current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
              var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;
              if (this.pv.length) {
                ret = new Array(initV.length);
                len = ret.length;
                for (i6 = 0; i6 < len; i6 += 1) {
                  ret[i6] = current[i6] - (endV[i6] - initV[i6]) * repeats;
                }
                return ret;
              }
              return current - (endV - initV) * repeats;
            } else if (type === "continue") {
              var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
              var nextFirstValue = this.getValueAtTime((firstKeyFrame + 1e-3) / this.comp.globalData.frameRate, 0);
              if (this.pv.length) {
                ret = new Array(firstValue.length);
                len = ret.length;
                for (i6 = 0; i6 < len; i6 += 1) {
                  ret[i6] = firstValue[i6] + (firstValue[i6] - nextFirstValue[i6]) * (firstKeyFrame - currentFrame) / 1e-3;
                }
                return ret;
              }
              return firstValue + (firstValue - nextFirstValue) * (firstKeyFrame - currentFrame) / 1e-3;
            }
            return this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0);
          }
          function smooth2(width2, samples) {
            if (!this.k) {
              return this.pv;
            }
            width2 = (width2 || 0.4) * 0.5;
            samples = Math.floor(samples || 5);
            if (samples <= 1) {
              return this.pv;
            }
            var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;
            var initFrame2 = currentTime - width2;
            var endFrame = currentTime + width2;
            var sampleFrequency = samples > 1 ? (endFrame - initFrame2) / (samples - 1) : 1;
            var i6 = 0;
            var j3 = 0;
            var value2;
            if (this.pv.length) {
              value2 = createTypedArray("float32", this.pv.length);
            } else {
              value2 = 0;
            }
            var sampleValue;
            while (i6 < samples) {
              sampleValue = this.getValueAtTime(initFrame2 + i6 * sampleFrequency);
              if (this.pv.length) {
                for (j3 = 0; j3 < this.pv.length; j3 += 1) {
                  value2[j3] += sampleValue[j3];
                }
              } else {
                value2 += sampleValue;
              }
              i6 += 1;
            }
            if (this.pv.length) {
              for (j3 = 0; j3 < this.pv.length; j3 += 1) {
                value2[j3] /= samples;
              }
            } else {
              value2 /= samples;
            }
            return value2;
          }
          function getTransformValueAtTime(time2) {
            if (!this._transformCachingAtTime) {
              this._transformCachingAtTime = {
                v: new Matrix()
              };
            }
            var matrix = this._transformCachingAtTime.v;
            matrix.cloneFromProps(this.pre.props);
            if (this.appliedTransformations < 1) {
              var anchor = this.a.getValueAtTime(time2);
              matrix.translate(-anchor[0] * this.a.mult, -anchor[1] * this.a.mult, anchor[2] * this.a.mult);
            }
            if (this.appliedTransformations < 2) {
              var scale2 = this.s.getValueAtTime(time2);
              matrix.scale(scale2[0] * this.s.mult, scale2[1] * this.s.mult, scale2[2] * this.s.mult);
            }
            if (this.sk && this.appliedTransformations < 3) {
              var skew = this.sk.getValueAtTime(time2);
              var skewAxis = this.sa.getValueAtTime(time2);
              matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult);
            }
            if (this.r && this.appliedTransformations < 4) {
              var rotation2 = this.r.getValueAtTime(time2);
              matrix.rotate(-rotation2 * this.r.mult);
            } else if (!this.r && this.appliedTransformations < 4) {
              var rotationZ = this.rz.getValueAtTime(time2);
              var rotationY = this.ry.getValueAtTime(time2);
              var rotationX = this.rx.getValueAtTime(time2);
              var orientation = this.or.getValueAtTime(time2);
              matrix.rotateZ(-rotationZ * this.rz.mult).rotateY(rotationY * this.ry.mult).rotateX(rotationX * this.rx.mult).rotateZ(-orientation[2] * this.or.mult).rotateY(orientation[1] * this.or.mult).rotateX(orientation[0] * this.or.mult);
            }
            if (this.data.p && this.data.p.s) {
              var positionX = this.px.getValueAtTime(time2);
              var positionY = this.py.getValueAtTime(time2);
              if (this.data.p.z) {
                var positionZ = this.pz.getValueAtTime(time2);
                matrix.translate(positionX * this.px.mult, positionY * this.py.mult, -positionZ * this.pz.mult);
              } else {
                matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0);
              }
            } else {
              var position2 = this.p.getValueAtTime(time2);
              matrix.translate(position2[0] * this.p.mult, position2[1] * this.p.mult, -position2[2] * this.p.mult);
            }
            return matrix;
          }
          function getTransformStaticValueAtTime() {
            return this.v.clone(new Matrix());
          }
          var getTransformProperty = TransformPropertyFactory.getTransformProperty;
          TransformPropertyFactory.getTransformProperty = function(elem2, data2, container) {
            var prop = getTransformProperty(elem2, data2, container);
            if (prop.dynamicProperties.length) {
              prop.getValueAtTime = getTransformValueAtTime.bind(prop);
            } else {
              prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);
            }
            prop.setGroupProperty = expressionHelpers.setGroupProperty;
            return prop;
          };
          var propertyGetProp = PropertyFactory.getProp;
          PropertyFactory.getProp = function(elem2, data2, type, mult, container) {
            var prop = propertyGetProp(elem2, data2, type, mult, container);
            if (prop.kf) {
              prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);
            } else {
              prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);
            }
            prop.setGroupProperty = expressionHelpers.setGroupProperty;
            prop.loopOut = loopOut2;
            prop.loopIn = loopIn2;
            prop.smooth = smooth2;
            prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);
            prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);
            prop.numKeys = data2.a === 1 ? data2.k.length : 0;
            prop.propertyIndex = data2.ix;
            var value2 = 0;
            if (type !== 0) {
              value2 = createTypedArray("float32", data2.a === 1 ? data2.k[0].s.length : data2.k.length);
            }
            prop._cachingAtTime = {
              lastFrame: initialDefaultFrame,
              lastIndex: 0,
              value: value2
            };
            expressionHelpers.searchExpressions(elem2, data2, prop);
            if (prop.k) {
              container.addDynamicProperty(prop);
            }
            return prop;
          };
          function getShapeValueAtTime(frameNum) {
            if (!this._cachingAtTime) {
              this._cachingAtTime = {
                shapeValue: shapePool.clone(this.pv),
                lastIndex: 0,
                lastTime: initialDefaultFrame
              };
            }
            frameNum *= this.elem.globalData.frameRate;
            frameNum -= this.offsetTime;
            if (frameNum !== this._cachingAtTime.lastTime) {
              this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;
              this._cachingAtTime.lastTime = frameNum;
              this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);
            }
            return this._cachingAtTime.shapeValue;
          }
          var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();
          var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();
          function ShapeExpressions() {
          }
          ShapeExpressions.prototype = {
            vertices: function vertices(prop, time2) {
              if (this.k) {
                this.getValue();
              }
              var shapePath = this.v;
              if (time2 !== void 0) {
                shapePath = this.getValueAtTime(time2, 0);
              }
              var i6;
              var len = shapePath._length;
              var vertices2 = shapePath[prop];
              var points = shapePath.v;
              var arr = createSizedArray(len);
              for (i6 = 0; i6 < len; i6 += 1) {
                if (prop === "i" || prop === "o") {
                  arr[i6] = [vertices2[i6][0] - points[i6][0], vertices2[i6][1] - points[i6][1]];
                } else {
                  arr[i6] = [vertices2[i6][0], vertices2[i6][1]];
                }
              }
              return arr;
            },
            points: function points(time2) {
              return this.vertices("v", time2);
            },
            inTangents: function inTangents(time2) {
              return this.vertices("i", time2);
            },
            outTangents: function outTangents(time2) {
              return this.vertices("o", time2);
            },
            isClosed: function isClosed() {
              return this.v.c;
            },
            pointOnPath: function pointOnPath(perc, time2) {
              var shapePath = this.v;
              if (time2 !== void 0) {
                shapePath = this.getValueAtTime(time2, 0);
              }
              if (!this._segmentsLength) {
                this._segmentsLength = bez.getSegmentsLength(shapePath);
              }
              var segmentsLength = this._segmentsLength;
              var lengths = segmentsLength.lengths;
              var lengthPos = segmentsLength.totalLength * perc;
              var i6 = 0;
              var len = lengths.length;
              var accumulatedLength = 0;
              var pt;
              while (i6 < len) {
                if (accumulatedLength + lengths[i6].addedLength > lengthPos) {
                  var initIndex = i6;
                  var endIndex = shapePath.c && i6 === len - 1 ? 0 : i6 + 1;
                  var segmentPerc = (lengthPos - accumulatedLength) / lengths[i6].addedLength;
                  pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i6]);
                  break;
                } else {
                  accumulatedLength += lengths[i6].addedLength;
                }
                i6 += 1;
              }
              if (!pt) {
                pt = shapePath.c ? [shapePath.v[0][0], shapePath.v[0][1]] : [shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1]];
              }
              return pt;
            },
            vectorOnPath: function vectorOnPath(perc, time2, vectorType) {
              if (perc == 1) {
                perc = this.v.c;
              } else if (perc == 0) {
                perc = 0.999;
              }
              var pt1 = this.pointOnPath(perc, time2);
              var pt2 = this.pointOnPath(perc + 1e-3, time2);
              var xLength = pt2[0] - pt1[0];
              var yLength = pt2[1] - pt1[1];
              var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));
              if (magnitude === 0) {
                return [0, 0];
              }
              var unitVector = vectorType === "tangent" ? [xLength / magnitude, yLength / magnitude] : [-yLength / magnitude, xLength / magnitude];
              return unitVector;
            },
            tangentOnPath: function tangentOnPath(perc, time2) {
              return this.vectorOnPath(perc, time2, "tangent");
            },
            normalOnPath: function normalOnPath(perc, time2) {
              return this.vectorOnPath(perc, time2, "normal");
            },
            setGroupProperty: expressionHelpers.setGroupProperty,
            getValueAtTime: expressionHelpers.getStaticValueAtTime
          };
          extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction);
          extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction);
          KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;
          KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;
          var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;
          ShapePropertyFactory.getShapeProp = function(elem2, data2, type, arr, trims) {
            var prop = propertyGetShapeProp(elem2, data2, type, arr, trims);
            prop.propertyIndex = data2.ix;
            prop.lock = false;
            if (type === 3) {
              expressionHelpers.searchExpressions(elem2, data2.pt, prop);
            } else if (type === 4) {
              expressionHelpers.searchExpressions(elem2, data2.ks, prop);
            }
            if (prop.k) {
              elem2.addDynamicProperty(prop);
            }
            return prop;
          };
        }
        function initialize$1() {
          addPropertyDecorator();
        }
        function addDecorator() {
          function searchExpressions() {
            if (this.data.d.x) {
              this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);
              this.addEffect(this.getExpressionValue.bind(this));
              return true;
            }
            return null;
          }
          TextProperty.prototype.getExpressionValue = function(currentValue, text2) {
            var newValue = this.calculateExpression(text2);
            if (currentValue.t !== newValue) {
              var newData = {};
              this.copyData(newData, currentValue);
              newData.t = newValue.toString();
              newData.__complete = false;
              return newData;
            }
            return currentValue;
          };
          TextProperty.prototype.searchProperty = function() {
            var isKeyframed = this.searchKeyframes();
            var hasExpressions = this.searchExpressions();
            this.kf = isKeyframed || hasExpressions;
            return this.kf;
          };
          TextProperty.prototype.searchExpressions = searchExpressions;
        }
        function initialize() {
          addDecorator();
        }
        function SVGComposableEffect() {
        }
        SVGComposableEffect.prototype = {
          createMergeNode: function createMergeNode(resultId, ins) {
            var feMerge = createNS("feMerge");
            feMerge.setAttribute("result", resultId);
            var feMergeNode;
            var i6;
            for (i6 = 0; i6 < ins.length; i6 += 1) {
              feMergeNode = createNS("feMergeNode");
              feMergeNode.setAttribute("in", ins[i6]);
              feMerge.appendChild(feMergeNode);
              feMerge.appendChild(feMergeNode);
            }
            return feMerge;
          }
        };
        var linearFilterValue = "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0";
        function SVGTintFilter(filter, filterManager, elem2, id, source) {
          this.filterManager = filterManager;
          var feColorMatrix = createNS("feColorMatrix");
          feColorMatrix.setAttribute("type", "matrix");
          feColorMatrix.setAttribute("color-interpolation-filters", "linearRGB");
          feColorMatrix.setAttribute("values", linearFilterValue + " 1 0");
          this.linearFilter = feColorMatrix;
          feColorMatrix.setAttribute("result", id + "_tint_1");
          filter.appendChild(feColorMatrix);
          feColorMatrix = createNS("feColorMatrix");
          feColorMatrix.setAttribute("type", "matrix");
          feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
          feColorMatrix.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0");
          feColorMatrix.setAttribute("result", id + "_tint_2");
          filter.appendChild(feColorMatrix);
          this.matrixFilter = feColorMatrix;
          var feMerge = this.createMergeNode(id, [source, id + "_tint_1", id + "_tint_2"]);
          filter.appendChild(feMerge);
        }
        extendPrototype([SVGComposableEffect], SVGTintFilter);
        SVGTintFilter.prototype.renderFrame = function(forceRender) {
          if (forceRender || this.filterManager._mdf) {
            var colorBlack = this.filterManager.effectElements[0].p.v;
            var colorWhite = this.filterManager.effectElements[1].p.v;
            var opacity = this.filterManager.effectElements[2].p.v / 100;
            this.linearFilter.setAttribute("values", linearFilterValue + " " + opacity + " 0");
            this.matrixFilter.setAttribute("values", colorWhite[0] - colorBlack[0] + " 0 0 0 " + colorBlack[0] + " " + (colorWhite[1] - colorBlack[1]) + " 0 0 0 " + colorBlack[1] + " " + (colorWhite[2] - colorBlack[2]) + " 0 0 0 " + colorBlack[2] + " 0 0 0 1 0");
          }
        };
        function SVGFillFilter(filter, filterManager, elem2, id) {
          this.filterManager = filterManager;
          var feColorMatrix = createNS("feColorMatrix");
          feColorMatrix.setAttribute("type", "matrix");
          feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
          feColorMatrix.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0");
          feColorMatrix.setAttribute("result", id);
          filter.appendChild(feColorMatrix);
          this.matrixFilter = feColorMatrix;
        }
        SVGFillFilter.prototype.renderFrame = function(forceRender) {
          if (forceRender || this.filterManager._mdf) {
            var color = this.filterManager.effectElements[2].p.v;
            var opacity = this.filterManager.effectElements[6].p.v;
            this.matrixFilter.setAttribute("values", "0 0 0 0 " + color[0] + " 0 0 0 0 " + color[1] + " 0 0 0 0 " + color[2] + " 0 0 0 " + opacity + " 0");
          }
        };
        function SVGStrokeEffect(fil, filterManager, elem2) {
          this.initialized = false;
          this.filterManager = filterManager;
          this.elem = elem2;
          this.paths = [];
        }
        SVGStrokeEffect.prototype.initialize = function() {
          var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
          var path;
          var groupPath;
          var i6;
          var len;
          if (this.filterManager.effectElements[1].p.v === 1) {
            len = this.elem.maskManager.masksProperties.length;
            i6 = 0;
          } else {
            i6 = this.filterManager.effectElements[0].p.v - 1;
            len = i6 + 1;
          }
          groupPath = createNS("g");
          groupPath.setAttribute("fill", "none");
          groupPath.setAttribute("stroke-linecap", "round");
          groupPath.setAttribute("stroke-dashoffset", 1);
          for (i6; i6 < len; i6 += 1) {
            path = createNS("path");
            groupPath.appendChild(path);
            this.paths.push({
              p: path,
              m: i6
            });
          }
          if (this.filterManager.effectElements[10].p.v === 3) {
            var mask2 = createNS("mask");
            var id = createElementID();
            mask2.setAttribute("id", id);
            mask2.setAttribute("mask-type", "alpha");
            mask2.appendChild(groupPath);
            this.elem.globalData.defs.appendChild(mask2);
            var g3 = createNS("g");
            g3.setAttribute("mask", "url(" + getLocationHref() + "#" + id + ")");
            while (elemChildren[0]) {
              g3.appendChild(elemChildren[0]);
            }
            this.elem.layerElement.appendChild(g3);
            this.masker = mask2;
            groupPath.setAttribute("stroke", "#fff");
          } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
            if (this.filterManager.effectElements[10].p.v === 2) {
              elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
              while (elemChildren.length) {
                this.elem.layerElement.removeChild(elemChildren[0]);
              }
            }
            this.elem.layerElement.appendChild(groupPath);
            this.elem.layerElement.removeAttribute("mask");
            groupPath.setAttribute("stroke", "#fff");
          }
          this.initialized = true;
          this.pathMasker = groupPath;
        };
        SVGStrokeEffect.prototype.renderFrame = function(forceRender) {
          if (!this.initialized) {
            this.initialize();
          }
          var i6;
          var len = this.paths.length;
          var mask2;
          var path;
          for (i6 = 0; i6 < len; i6 += 1) {
            if (this.paths[i6].m !== -1) {
              mask2 = this.elem.maskManager.viewData[this.paths[i6].m];
              path = this.paths[i6].p;
              if (forceRender || this.filterManager._mdf || mask2.prop._mdf) {
                path.setAttribute("d", mask2.lastPath);
              }
              if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask2.prop._mdf) {
                var dasharrayValue;
                if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
                  var s4 = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
                  var e5 = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
                  var l6 = path.getTotalLength();
                  dasharrayValue = "0 0 0 " + l6 * s4 + " ";
                  var lineLength = l6 * (e5 - s4);
                  var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
                  var units = Math.floor(lineLength / segment);
                  var j3;
                  for (j3 = 0; j3 < units; j3 += 1) {
                    dasharrayValue += "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + " ";
                  }
                  dasharrayValue += "0 " + l6 * 10 + " 0 0";
                } else {
                  dasharrayValue = "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
                }
                path.setAttribute("stroke-dasharray", dasharrayValue);
              }
            }
          }
          if (forceRender || this.filterManager.effectElements[4].p._mdf) {
            this.pathMasker.setAttribute("stroke-width", this.filterManager.effectElements[4].p.v * 2);
          }
          if (forceRender || this.filterManager.effectElements[6].p._mdf) {
            this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v);
          }
          if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
            if (forceRender || this.filterManager.effectElements[3].p._mdf) {
              var color = this.filterManager.effectElements[3].p.v;
              this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(color[0] * 255) + "," + bmFloor(color[1] * 255) + "," + bmFloor(color[2] * 255) + ")");
            }
          }
        };
        function SVGTritoneFilter(filter, filterManager, elem2, id) {
          this.filterManager = filterManager;
          var feColorMatrix = createNS("feColorMatrix");
          feColorMatrix.setAttribute("type", "matrix");
          feColorMatrix.setAttribute("color-interpolation-filters", "linearRGB");
          feColorMatrix.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0");
          filter.appendChild(feColorMatrix);
          var feComponentTransfer = createNS("feComponentTransfer");
          feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
          feComponentTransfer.setAttribute("result", id);
          this.matrixFilter = feComponentTransfer;
          var feFuncR = createNS("feFuncR");
          feFuncR.setAttribute("type", "table");
          feComponentTransfer.appendChild(feFuncR);
          this.feFuncR = feFuncR;
          var feFuncG = createNS("feFuncG");
          feFuncG.setAttribute("type", "table");
          feComponentTransfer.appendChild(feFuncG);
          this.feFuncG = feFuncG;
          var feFuncB = createNS("feFuncB");
          feFuncB.setAttribute("type", "table");
          feComponentTransfer.appendChild(feFuncB);
          this.feFuncB = feFuncB;
          filter.appendChild(feComponentTransfer);
        }
        SVGTritoneFilter.prototype.renderFrame = function(forceRender) {
          if (forceRender || this.filterManager._mdf) {
            var color1 = this.filterManager.effectElements[0].p.v;
            var color2 = this.filterManager.effectElements[1].p.v;
            var color3 = this.filterManager.effectElements[2].p.v;
            var tableR = color3[0] + " " + color2[0] + " " + color1[0];
            var tableG = color3[1] + " " + color2[1] + " " + color1[1];
            var tableB = color3[2] + " " + color2[2] + " " + color1[2];
            this.feFuncR.setAttribute("tableValues", tableR);
            this.feFuncG.setAttribute("tableValues", tableG);
            this.feFuncB.setAttribute("tableValues", tableB);
          }
        };
        function SVGProLevelsFilter(filter, filterManager, elem2, id) {
          this.filterManager = filterManager;
          var effectElements = this.filterManager.effectElements;
          var feComponentTransfer = createNS("feComponentTransfer");
          if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {
            this.feFuncR = this.createFeFunc("feFuncR", feComponentTransfer);
          }
          if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {
            this.feFuncG = this.createFeFunc("feFuncG", feComponentTransfer);
          }
          if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {
            this.feFuncB = this.createFeFunc("feFuncB", feComponentTransfer);
          }
          if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {
            this.feFuncA = this.createFeFunc("feFuncA", feComponentTransfer);
          }
          if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {
            feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
            filter.appendChild(feComponentTransfer);
          }
          if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {
            feComponentTransfer = createNS("feComponentTransfer");
            feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
            feComponentTransfer.setAttribute("result", id);
            filter.appendChild(feComponentTransfer);
            this.feFuncRComposed = this.createFeFunc("feFuncR", feComponentTransfer);
            this.feFuncGComposed = this.createFeFunc("feFuncG", feComponentTransfer);
            this.feFuncBComposed = this.createFeFunc("feFuncB", feComponentTransfer);
          }
        }
        SVGProLevelsFilter.prototype.createFeFunc = function(type, feComponentTransfer) {
          var feFunc = createNS(type);
          feFunc.setAttribute("type", "table");
          feComponentTransfer.appendChild(feFunc);
          return feFunc;
        };
        SVGProLevelsFilter.prototype.getTableValue = function(inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
          var cnt = 0;
          var segments = 256;
          var perc;
          var min = Math.min(inputBlack, inputWhite);
          var max = Math.max(inputBlack, inputWhite);
          var table = Array.call(null, {
            length: segments
          });
          var colorValue;
          var pos = 0;
          var outputDelta = outputWhite - outputBlack;
          var inputDelta = inputWhite - inputBlack;
          while (cnt <= 256) {
            perc = cnt / 256;
            if (perc <= min) {
              colorValue = inputDelta < 0 ? outputWhite : outputBlack;
            } else if (perc >= max) {
              colorValue = inputDelta < 0 ? outputBlack : outputWhite;
            } else {
              colorValue = outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma);
            }
            table[pos] = colorValue;
            pos += 1;
            cnt += 256 / (segments - 1);
          }
          return table.join(" ");
        };
        SVGProLevelsFilter.prototype.renderFrame = function(forceRender) {
          if (forceRender || this.filterManager._mdf) {
            var val2;
            var effectElements = this.filterManager.effectElements;
            if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {
              val2 = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);
              this.feFuncRComposed.setAttribute("tableValues", val2);
              this.feFuncGComposed.setAttribute("tableValues", val2);
              this.feFuncBComposed.setAttribute("tableValues", val2);
            }
            if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {
              val2 = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);
              this.feFuncR.setAttribute("tableValues", val2);
            }
            if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {
              val2 = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);
              this.feFuncG.setAttribute("tableValues", val2);
            }
            if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {
              val2 = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);
              this.feFuncB.setAttribute("tableValues", val2);
            }
            if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {
              val2 = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);
              this.feFuncA.setAttribute("tableValues", val2);
            }
          }
        };
        function SVGDropShadowEffect(filter, filterManager, elem2, id, source) {
          var globalFilterSize = filterManager.container.globalData.renderConfig.filterSize;
          var filterSize = filterManager.data.fs || globalFilterSize;
          filter.setAttribute("x", filterSize.x || globalFilterSize.x);
          filter.setAttribute("y", filterSize.y || globalFilterSize.y);
          filter.setAttribute("width", filterSize.width || globalFilterSize.width);
          filter.setAttribute("height", filterSize.height || globalFilterSize.height);
          this.filterManager = filterManager;
          var feGaussianBlur = createNS("feGaussianBlur");
          feGaussianBlur.setAttribute("in", "SourceAlpha");
          feGaussianBlur.setAttribute("result", id + "_drop_shadow_1");
          feGaussianBlur.setAttribute("stdDeviation", "0");
          this.feGaussianBlur = feGaussianBlur;
          filter.appendChild(feGaussianBlur);
          var feOffset = createNS("feOffset");
          feOffset.setAttribute("dx", "25");
          feOffset.setAttribute("dy", "0");
          feOffset.setAttribute("in", id + "_drop_shadow_1");
          feOffset.setAttribute("result", id + "_drop_shadow_2");
          this.feOffset = feOffset;
          filter.appendChild(feOffset);
          var feFlood = createNS("feFlood");
          feFlood.setAttribute("flood-color", "#00ff00");
          feFlood.setAttribute("flood-opacity", "1");
          feFlood.setAttribute("result", id + "_drop_shadow_3");
          this.feFlood = feFlood;
          filter.appendChild(feFlood);
          var feComposite = createNS("feComposite");
          feComposite.setAttribute("in", id + "_drop_shadow_3");
          feComposite.setAttribute("in2", id + "_drop_shadow_2");
          feComposite.setAttribute("operator", "in");
          feComposite.setAttribute("result", id + "_drop_shadow_4");
          filter.appendChild(feComposite);
          var feMerge = this.createMergeNode(id, [id + "_drop_shadow_4", source]);
          filter.appendChild(feMerge);
        }
        extendPrototype([SVGComposableEffect], SVGDropShadowEffect);
        SVGDropShadowEffect.prototype.renderFrame = function(forceRender) {
          if (forceRender || this.filterManager._mdf) {
            if (forceRender || this.filterManager.effectElements[4].p._mdf) {
              this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4);
            }
            if (forceRender || this.filterManager.effectElements[0].p._mdf) {
              var col = this.filterManager.effectElements[0].p.v;
              this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));
            }
            if (forceRender || this.filterManager.effectElements[1].p._mdf) {
              this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255);
            }
            if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
              var distance = this.filterManager.effectElements[3].p.v;
              var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;
              var x3 = distance * Math.cos(angle);
              var y3 = distance * Math.sin(angle);
              this.feOffset.setAttribute("dx", x3);
              this.feOffset.setAttribute("dy", y3);
            }
          }
        };
        var _svgMatteSymbols = [];
        function SVGMatte3Effect(filterElem, filterManager, elem2) {
          this.initialized = false;
          this.filterManager = filterManager;
          this.filterElem = filterElem;
          this.elem = elem2;
          elem2.matteElement = createNS("g");
          elem2.matteElement.appendChild(elem2.layerElement);
          elem2.matteElement.appendChild(elem2.transformedElement);
          elem2.baseElement = elem2.matteElement;
        }
        SVGMatte3Effect.prototype.findSymbol = function(mask2) {
          var i6 = 0;
          var len = _svgMatteSymbols.length;
          while (i6 < len) {
            if (_svgMatteSymbols[i6] === mask2) {
              return _svgMatteSymbols[i6];
            }
            i6 += 1;
          }
          return null;
        };
        SVGMatte3Effect.prototype.replaceInParent = function(mask2, symbolId) {
          var parentNode = mask2.layerElement.parentNode;
          if (!parentNode) {
            return;
          }
          var children = parentNode.children;
          var i6 = 0;
          var len = children.length;
          while (i6 < len) {
            if (children[i6] === mask2.layerElement) {
              break;
            }
            i6 += 1;
          }
          var nextChild;
          if (i6 <= len - 2) {
            nextChild = children[i6 + 1];
          }
          var useElem = createNS("use");
          useElem.setAttribute("href", "#" + symbolId);
          if (nextChild) {
            parentNode.insertBefore(useElem, nextChild);
          } else {
            parentNode.appendChild(useElem);
          }
        };
        SVGMatte3Effect.prototype.setElementAsMask = function(elem2, mask2) {
          if (!this.findSymbol(mask2)) {
            var symbolId = createElementID();
            var masker = createNS("mask");
            masker.setAttribute("id", mask2.layerId);
            masker.setAttribute("mask-type", "alpha");
            _svgMatteSymbols.push(mask2);
            var defs = elem2.globalData.defs;
            defs.appendChild(masker);
            var symbol = createNS("symbol");
            symbol.setAttribute("id", symbolId);
            this.replaceInParent(mask2, symbolId);
            symbol.appendChild(mask2.layerElement);
            defs.appendChild(symbol);
            var useElem = createNS("use");
            useElem.setAttribute("href", "#" + symbolId);
            masker.appendChild(useElem);
            mask2.data.hd = false;
            mask2.show();
          }
          elem2.setMatte(mask2.layerId);
        };
        SVGMatte3Effect.prototype.initialize = function() {
          var ind = this.filterManager.effectElements[0].p.v;
          var elements = this.elem.comp.elements;
          var i6 = 0;
          var len = elements.length;
          while (i6 < len) {
            if (elements[i6] && elements[i6].data.ind === ind) {
              this.setElementAsMask(this.elem, elements[i6]);
            }
            i6 += 1;
          }
          this.initialized = true;
        };
        SVGMatte3Effect.prototype.renderFrame = function() {
          if (!this.initialized) {
            this.initialize();
          }
        };
        function SVGGaussianBlurEffect(filter, filterManager, elem2, id) {
          filter.setAttribute("x", "-100%");
          filter.setAttribute("y", "-100%");
          filter.setAttribute("width", "300%");
          filter.setAttribute("height", "300%");
          this.filterManager = filterManager;
          var feGaussianBlur = createNS("feGaussianBlur");
          feGaussianBlur.setAttribute("result", id);
          filter.appendChild(feGaussianBlur);
          this.feGaussianBlur = feGaussianBlur;
        }
        SVGGaussianBlurEffect.prototype.renderFrame = function(forceRender) {
          if (forceRender || this.filterManager._mdf) {
            var kBlurrinessToSigma = 0.3;
            var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma;
            var dimensions = this.filterManager.effectElements[1].p.v;
            var sigmaX = dimensions == 3 ? 0 : sigma;
            var sigmaY = dimensions == 2 ? 0 : sigma;
            this.feGaussianBlur.setAttribute("stdDeviation", sigmaX + " " + sigmaY);
            var edgeMode = this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate";
            this.feGaussianBlur.setAttribute("edgeMode", edgeMode);
          }
        };
        function TransformEffect() {
        }
        TransformEffect.prototype.init = function(effectsManager) {
          this.effectsManager = effectsManager;
          this.type = effectTypes.TRANSFORM_EFFECT;
          this.matrix = new Matrix();
          this.opacity = -1;
          this._mdf = false;
          this._opMdf = false;
        };
        TransformEffect.prototype.renderFrame = function(forceFrame) {
          this._opMdf = false;
          this._mdf = false;
          if (forceFrame || this.effectsManager._mdf) {
            var effectElements = this.effectsManager.effectElements;
            var anchor = effectElements[0].p.v;
            var position2 = effectElements[1].p.v;
            var isUniformScale = effectElements[2].p.v === 1;
            var scaleHeight = effectElements[3].p.v;
            var scaleWidth = isUniformScale ? scaleHeight : effectElements[4].p.v;
            var skew = effectElements[5].p.v;
            var skewAxis = effectElements[6].p.v;
            var rotation2 = effectElements[7].p.v;
            this.matrix.reset();
            this.matrix.translate(-anchor[0], -anchor[1], anchor[2]);
            this.matrix.scale(scaleWidth * 0.01, scaleHeight * 0.01, 1);
            this.matrix.rotate(-rotation2 * degToRads);
            this.matrix.skewFromAxis(-skew * degToRads, (skewAxis + 90) * degToRads);
            this.matrix.translate(position2[0], position2[1], 0);
            this._mdf = true;
            if (this.opacity !== effectElements[8].p.v) {
              this.opacity = effectElements[8].p.v;
              this._opMdf = true;
            }
          }
        };
        function SVGTransformEffect(_3, filterManager) {
          this.init(filterManager);
        }
        extendPrototype([TransformEffect], SVGTransformEffect);
        function CVTransformEffect(effectsManager) {
          this.init(effectsManager);
        }
        extendPrototype([TransformEffect], CVTransformEffect);
        registerRenderer("canvas", CanvasRenderer);
        registerRenderer("html", HybridRenderer);
        registerRenderer("svg", SVGRenderer);
        ShapeModifiers.registerModifier("tm", TrimModifier);
        ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier);
        ShapeModifiers.registerModifier("rp", RepeaterModifier);
        ShapeModifiers.registerModifier("rd", RoundCornersModifier);
        ShapeModifiers.registerModifier("zz", ZigZagModifier);
        ShapeModifiers.registerModifier("op", OffsetPathModifier);
        setExpressionsPlugin(Expressions);
        setExpressionInterfaces(getInterface);
        initialize$1();
        initialize();
        registerEffect$1(20, SVGTintFilter, true);
        registerEffect$1(21, SVGFillFilter, true);
        registerEffect$1(22, SVGStrokeEffect, false);
        registerEffect$1(23, SVGTritoneFilter, true);
        registerEffect$1(24, SVGProLevelsFilter, true);
        registerEffect$1(25, SVGDropShadowEffect, true);
        registerEffect$1(28, SVGMatte3Effect, false);
        registerEffect$1(29, SVGGaussianBlurEffect, true);
        registerEffect$1(35, SVGTransformEffect, false);
        registerEffect(35, CVTransformEffect);
        return lottie;
      });
    }
  });

  // node_modules/svg4everybody/dist/svg4everybody.js
  var require_svg4everybody = __commonJS({
    "node_modules/svg4everybody/dist/svg4everybody.js"(exports2, module2) {
      !function(root, factory) {
        "function" == typeof define && define.amd ? (
          // AMD. Register as an anonymous module unless amdModuleId is set
          define([], function() {
            return root.svg4everybody = factory();
          })
        ) : "object" == typeof module2 && module2.exports ? (
          // Node. Does not work with strict CommonJS, but
          // only CommonJS-like environments that support module.exports,
          // like Node.
          module2.exports = factory()
        ) : root.svg4everybody = factory();
      }(exports2, function() {
        function embed(parent2, svg, target) {
          if (target) {
            var fragment = document.createDocumentFragment(), viewBox = !svg.hasAttribute("viewBox") && target.getAttribute("viewBox");
            viewBox && svg.setAttribute("viewBox", viewBox);
            for (var clone = target.cloneNode(true); clone.childNodes.length; ) {
              fragment.appendChild(clone.firstChild);
            }
            parent2.appendChild(fragment);
          }
        }
        function loadreadystatechange(xhr) {
          xhr.onreadystatechange = function() {
            if (4 === xhr.readyState) {
              var cachedDocument = xhr._cachedDocument;
              cachedDocument || (cachedDocument = xhr._cachedDocument = document.implementation.createHTMLDocument(""), cachedDocument.body.innerHTML = xhr.responseText, xhr._cachedTarget = {}), // clear the xhr embeds list and embed each item
              xhr._embeds.splice(0).map(function(item) {
                var target = xhr._cachedTarget[item.id];
                target || (target = xhr._cachedTarget[item.id] = cachedDocument.getElementById(item.id)), // embed the target into the svg
                embed(item.parent, item.svg, target);
              });
            }
          }, // test the ready state change immediately
          xhr.onreadystatechange();
        }
        function svg4everybody2(rawopts) {
          function oninterval() {
            for (var index2 = 0; index2 < uses.length; ) {
              var use = uses[index2], parent2 = use.parentNode, svg = getSVGAncestor(parent2), src = use.getAttribute("xlink:href") || use.getAttribute("href");
              if (!src && opts.attributeName && (src = use.getAttribute(opts.attributeName)), svg && src) {
                if (polyfill) {
                  if (!opts.validate || opts.validate(src, svg, use)) {
                    parent2.removeChild(use);
                    var srcSplit = src.split("#"), url = srcSplit.shift(), id = srcSplit.join("#");
                    if (url.length) {
                      var xhr = requests[url];
                      xhr || (xhr = requests[url] = new XMLHttpRequest(), xhr.open("GET", url), xhr.send(), xhr._embeds = []), // add the svg and id as an item to the xhr embeds list
                      xhr._embeds.push({
                        parent: parent2,
                        svg,
                        id
                      }), // prepare the xhr ready state change event
                      loadreadystatechange(xhr);
                    } else {
                      embed(parent2, svg, document.getElementById(id));
                    }
                  } else {
                    ++index2, ++numberOfSvgUseElementsToBypass;
                  }
                }
              } else {
                ++index2;
              }
            }
            (!uses.length || uses.length - numberOfSvgUseElementsToBypass > 0) && requestAnimationFrame2(oninterval, 67);
          }
          var polyfill, opts = Object(rawopts), newerIEUA = /\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/, webkitUA = /\bAppleWebKit\/(\d+)\b/, olderEdgeUA = /\bEdge\/12\.(\d+)\b/, edgeUA = /\bEdge\/.(\d+)\b/, inIframe = window.top !== window.self;
          polyfill = "polyfill" in opts ? opts.polyfill : newerIEUA.test(navigator.userAgent) || (navigator.userAgent.match(olderEdgeUA) || [])[1] < 10547 || (navigator.userAgent.match(webkitUA) || [])[1] < 537 || edgeUA.test(navigator.userAgent) && inIframe;
          var requests = {}, requestAnimationFrame2 = window.requestAnimationFrame || setTimeout, uses = document.getElementsByTagName("use"), numberOfSvgUseElementsToBypass = 0;
          polyfill && oninterval();
        }
        function getSVGAncestor(node) {
          for (var svg = node; "svg" !== svg.nodeName.toLowerCase() && (svg = svg.parentNode); ) {
          }
          return svg;
        }
        return svg4everybody2;
      });
    }
  });

  // assets/scripts/utils/grid-helper.js
  var grid_helper_exports = {};
  __export(grid_helper_exports, {
    gridHelper: () => gridHelper
  });
  function gridHelper({
    gutterCssVar = GRID_HELPER_GUTTER_CSS_VAR,
    marginCssVar = GRID_HELPER_MARGIN_CSS_VAR,
    rgbaColor = GRID_HELPER_RGBA_COLOR
  } = {}) {
    const $gridContainer = document.createElement("div");
    document.body.append($gridContainer);
    setGridHelperColumns($gridContainer, rgbaColor);
    setGridHelperStyles($gridContainer, gutterCssVar, marginCssVar);
    setGridEvents($gridContainer, rgbaColor);
  }
  function setGridHelperStyles($container, gutterCssVar, marginCssVar) {
    const elStyles = $container.style;
    elStyles.zIndex = "10000";
    elStyles.position = "fixed";
    elStyles.top = "0";
    elStyles.left = "0";
    elStyles.display = "flex";
    elStyles.width = "100%";
    elStyles.height = "100%";
    elStyles.columnGap = `var(${gutterCssVar}, 0)`;
    elStyles.paddingLeft = `var(${marginCssVar}, 0)`;
    elStyles.paddingRight = `var(${marginCssVar}, 0)`;
    elStyles.pointerEvents = "none";
    elStyles.visibility = "hidden";
  }
  function setGridHelperColumns($container, rgbaColor) {
    $container.innerHTML = "";
    const columns = Number(window.getComputedStyle($container).getPropertyValue("--grid-columns"));
    let $col;
    for (var i6 = 0; i6 < columns; i6++) {
      $col = document.createElement("div");
      $col.style.flex = "1 1 0";
      $col.style.backgroundColor = rgbaColor;
      $container.appendChild($col);
    }
  }
  function setGridEvents($container, rgbaColor) {
    window.addEventListener("resize", setGridHelperColumns($container, rgbaColor));
    let ctrlDown = false;
    let isActive = false;
    document.addEventListener("keydown", (e5) => {
      if (e5.key == "Control") {
        ctrlDown = true;
      } else {
        if (ctrlDown && e5.key == "g") {
          if (isActive) {
            $container.style.visibility = "hidden";
          } else {
            $container.style.visibility = "visible";
          }
          isActive = !isActive;
        }
      }
    });
    document.addEventListener("keyup", (e5) => {
      if (e5.key == "Control") {
        ctrlDown = false;
      }
    });
  }
  var GRID_HELPER_GUTTER_CSS_VAR, GRID_HELPER_MARGIN_CSS_VAR, GRID_HELPER_RGBA_COLOR;
  var init_grid_helper = __esm({
    "assets/scripts/utils/grid-helper.js"() {
      GRID_HELPER_GUTTER_CSS_VAR = "--grid-gutter";
      GRID_HELPER_MARGIN_CSS_VAR = "--grid-margin";
      GRID_HELPER_RGBA_COLOR = "rgba(255, 0, 0, .1)";
    }
  });

  // node_modules/modujs/dist/main.esm.js
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof2 = function(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof2 = function(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof2(obj);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i6 = 0; i6 < props.length; i6++) {
      var descriptor = props[i6];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  function _defineProperty(obj, key2, value2) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key2] = value2;
    }
    return obj;
  }
  function _slicedToArray(arr, i6) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i6) || _unsupportedIterableToArray(arr, i6) || _nonIterableRest();
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }
  function _iterableToArrayLimit(arr, i6) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e2 = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i6 && _arr.length === i6) break;
      }
    } catch (err) {
      _d = true;
      _e2 = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e2;
      }
    }
    return _arr;
  }
  function _unsupportedIterableToArray(o5, minLen) {
    if (!o5) return;
    if (typeof o5 === "string") return _arrayLikeToArray(o5, minLen);
    var n6 = Object.prototype.toString.call(o5).slice(8, -1);
    if (n6 === "Object" && o5.constructor) n6 = o5.constructor.name;
    if (n6 === "Map" || n6 === "Set") return Array.from(o5);
    if (n6 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n6)) return _arrayLikeToArray(o5, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i6 = 0, arr2 = new Array(len); i6 < len; i6++) arr2[i6] = arr[i6];
    return arr2;
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var _default = /* @__PURE__ */ function() {
    function _default2(options) {
      _classCallCheck(this, _default2);
      this.mAttr = "data-" + options.dataName;
      this.mCaptureEvents = ["mouseenter", "mouseleave"];
      this.el = options.el;
    }
    _createClass(_default2, [{
      key: "mInit",
      value: function mInit(modules) {
        var _this = this;
        this.modules = modules;
        this.mCheckEventTarget = this.mCheckEventTarget.bind(this);
        if (this.events) {
          Object.keys(this.events).forEach(function(event2) {
            return _this.mAddEvent(event2);
          });
        }
      }
    }, {
      key: "mUpdate",
      value: function mUpdate(modules) {
        this.modules = modules;
      }
    }, {
      key: "mDestroy",
      value: function mDestroy() {
        var _this2 = this;
        if (this.events) {
          Object.keys(this.events).forEach(function(event2) {
            return _this2.mRemoveEvent(event2);
          });
        }
      }
    }, {
      key: "mAddEvent",
      value: function mAddEvent(event2) {
        var capture = this.mCaptureEvents.includes(event2) ? true : false;
        this.el.addEventListener(event2, this.mCheckEventTarget, capture);
      }
    }, {
      key: "mRemoveEvent",
      value: function mRemoveEvent(event2) {
        var capture = this.mCaptureEvents.includes(event2) ? true : false;
        this.el.removeEventListener(event2, this.mCheckEventTarget, capture);
      }
    }, {
      key: "mCheckEventTarget",
      value: function mCheckEventTarget(e5) {
        var event2 = this.events[e5.type];
        if (typeof event2 === "string") {
          this[event2](e5);
        } else {
          var data2 = "[" + this.mAttr + "]";
          var target = e5.target;
          if (this.mCaptureEvents.includes(e5.type)) {
            if (target.matches(data2)) {
              this.mCallEventMethod(e5, event2, target);
            }
          } else {
            while (target && target !== document) {
              if (target.matches(data2)) {
                if (this.mCallEventMethod(e5, event2, target) != "undefined") {
                  break;
                }
              }
              target = target.parentNode;
            }
          }
        }
      }
    }, {
      key: "mCallEventMethod",
      value: function mCallEventMethod(e5, event2, target) {
        var name2 = target.getAttribute(this.mAttr);
        if (event2.hasOwnProperty(name2)) {
          var method = event2[name2];
          if (!e5.hasOwnProperty("currentTarget")) {
            Object.defineProperty(e5, "currentTarget", {
              value: target
            });
          }
          if (!e5.hasOwnProperty("curTarget")) {
            Object.defineProperty(e5, "curTarget", {
              value: target
            });
          }
          this[method](e5);
        }
      }
    }, {
      key: "$",
      value: function $3(query, context3) {
        var classIndex = query.indexOf(".");
        var idIndex = query.indexOf("#");
        var attrIndex = query.indexOf("[");
        var indexes = [classIndex, idIndex, attrIndex].filter(function(index3) {
          return index3 != -1;
        });
        var index2 = false;
        var name2 = query;
        var more = "";
        var parent2 = this.el;
        if (indexes.length) {
          index2 = Math.min.apply(Math, _toConsumableArray(indexes));
          name2 = query.slice(0, index2);
          more = query.slice(index2);
        }
        if (_typeof2(context3) == "object") {
          parent2 = context3;
        }
        return parent2.querySelectorAll("[" + this.mAttr + "=" + name2 + "]" + more);
      }
    }, {
      key: "parent",
      value: function parent2(query, context3) {
        var data2 = "[" + this.mAttr + "=" + query + "]";
        var parent3 = context3.parentNode;
        while (parent3 && parent3 !== document) {
          if (parent3.matches(data2)) {
            return parent3;
          }
          parent3 = parent3.parentNode;
        }
      }
    }, {
      key: "getData",
      value: function getData(name2, context3) {
        var target = context3 || this.el;
        return target.getAttribute(this.mAttr + "-" + name2);
      }
    }, {
      key: "setData",
      value: function setData(name2, value2, context3) {
        var target = context3 || this.el;
        return target.setAttribute(this.mAttr + "-" + name2, value2);
      }
    }, {
      key: "call",
      value: function call(func, args, mod2, id) {
        var _this3 = this;
        if (args && !mod2) {
          mod2 = args;
          args = false;
        }
        if (this.modules[mod2]) {
          if (id) {
            if (this.modules[mod2][id]) {
              this.modules[mod2][id][func](args);
            }
          } else {
            Object.keys(this.modules[mod2]).forEach(function(id2) {
              _this3.modules[mod2][id2][func](args);
            });
          }
        }
      }
    }, {
      key: "on",
      value: function on(e5, mod2, func, id) {
        var _this4 = this;
        if (this.modules[mod2]) {
          if (id) {
            this.modules[mod2][id].el.addEventListener(e5, function(o5) {
              return func(o5);
            });
          } else {
            Object.keys(this.modules[mod2]).forEach(function(i6) {
              _this4.modules[mod2][i6].el.addEventListener(e5, function(o5) {
                return func(o5);
              });
            });
          }
        }
      }
    }, {
      key: "init",
      value: function init5() {
      }
    }, {
      key: "destroy",
      value: function destroy() {
      }
    }]);
    return _default2;
  }();
  var _default$1 = /* @__PURE__ */ function() {
    function _default2(options) {
      _classCallCheck(this, _default2);
      this.app;
      this.modules = options.modules;
      this.currentModules = {};
      this.activeModules = {};
      this.newModules = {};
      this.moduleId = 0;
    }
    _createClass(_default2, [{
      key: "init",
      value: function init5(app2, scope) {
        var _this = this;
        var container = scope || document;
        var elements = container.querySelectorAll("*");
        if (app2 && !this.app) {
          this.app = app2;
        }
        this.activeModules["app"] = {
          "app": this.app
        };
        elements.forEach(function(el) {
          Array.from(el.attributes).forEach(function(i6) {
            if (i6.name.startsWith("data-module")) {
              var moduleExists = false;
              var dataName = i6.name.split("-").splice(2);
              var moduleName = _this.toCamel(dataName);
              if (_this.modules[moduleName]) {
                moduleExists = true;
              } else if (_this.modules[_this.toUpper(moduleName)]) {
                moduleName = _this.toUpper(moduleName);
                moduleExists = true;
              }
              if (moduleExists) {
                var options = {
                  el,
                  name: moduleName,
                  dataName: dataName.join("-")
                };
                var module2 = new _this.modules[moduleName](options);
                var id = i6.value;
                if (!id) {
                  _this.moduleId++;
                  id = "m" + _this.moduleId;
                  el.setAttribute(i6.name, id);
                }
                _this.addActiveModule(moduleName, id, module2);
                var moduleId = moduleName + "-" + id;
                if (scope) {
                  _this.newModules[moduleId] = module2;
                } else {
                  _this.currentModules[moduleId] = module2;
                }
              }
            }
          });
        });
        Object.entries(this.currentModules).forEach(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 2), id = _ref2[0], module2 = _ref2[1];
          if (scope) {
            var split = id.split("-");
            var moduleName = split.shift();
            var moduleId = split.pop();
            _this.addActiveModule(moduleName, moduleId, module2);
          } else {
            _this.initModule(module2);
          }
        });
      }
    }, {
      key: "initModule",
      value: function initModule(module2) {
        module2.mInit(this.activeModules);
        module2.init();
      }
    }, {
      key: "addActiveModule",
      value: function addActiveModule(name2, id, module2) {
        if (this.activeModules[name2]) {
          Object.assign(this.activeModules[name2], _defineProperty({}, id, module2));
        } else {
          this.activeModules[name2] = _defineProperty({}, id, module2);
        }
      }
    }, {
      key: "update",
      value: function update2(scope) {
        var _this2 = this;
        this.init(this.app, scope);
        Object.entries(this.currentModules).forEach(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), id = _ref4[0], module2 = _ref4[1];
          module2.mUpdate(_this2.activeModules);
        });
        Object.entries(this.newModules).forEach(function(_ref5) {
          var _ref6 = _slicedToArray(_ref5, 2), id = _ref6[0], module2 = _ref6[1];
          _this2.initModule(module2);
        });
        Object.assign(this.currentModules, this.newModules);
      }
    }, {
      key: "destroy",
      value: function destroy(scope) {
        if (scope) {
          this.destroyScope(scope);
        } else {
          this.destroyModules();
        }
      }
    }, {
      key: "destroyScope",
      value: function destroyScope(scope) {
        var _this3 = this;
        var elements = scope.querySelectorAll("*");
        elements.forEach(function(el) {
          Array.from(el.attributes).forEach(function(i6) {
            if (i6.name.startsWith("data-module")) {
              var id = i6.value;
              var dataName = i6.name.split("-").splice(2);
              var moduleName = _this3.toCamel(dataName) + "-" + id;
              var moduleExists = false;
              if (_this3.currentModules[moduleName]) {
                moduleExists = true;
              } else if (_this3.currentModules[_this3.toUpper(moduleName)]) {
                moduleName = _this3.toUpper(moduleName);
                moduleExists = true;
              }
              if (moduleExists) {
                _this3.destroyModule(_this3.currentModules[moduleName]);
                delete _this3.currentModules[moduleName];
              }
            }
          });
        });
        this.activeModules = {};
        this.newModules = {};
      }
    }, {
      key: "destroyModules",
      value: function destroyModules() {
        var _this4 = this;
        Object.entries(this.currentModules).forEach(function(_ref7) {
          var _ref8 = _slicedToArray(_ref7, 2), id = _ref8[0], module2 = _ref8[1];
          _this4.destroyModule(module2);
        });
        this.currentModules = [];
      }
    }, {
      key: "destroyModule",
      value: function destroyModule(module2) {
        module2.mDestroy();
        module2.destroy();
      }
    }, {
      key: "toCamel",
      value: function toCamel(arr) {
        var _this5 = this;
        return arr.reduce(function(a5, b3) {
          return a5 + _this5.toUpper(b3);
        });
      }
    }, {
      key: "toUpper",
      value: function toUpper(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      }
    }]);
    return _default2;
  }();
  var main_esm_default = _default$1;

  // assets/scripts/modules.js
  var modules_exports = {};
  __export(modules_exports, {
    Accordion: () => Accordion,
    Blockquote: () => Blockquote,
    Carousel: () => Carousel,
    CookieConsent: () => CookieConsent_default,
    CopyLink: () => CopyLink,
    DarkHeader: () => DarkHeader,
    Explore: () => Explore,
    Filter: () => Filter,
    Gallery: () => Gallery,
    HeroWords: () => HeroWords,
    Load: () => Load_default,
    Loadmore: () => Loadmore,
    Map: () => GMap,
    Menu: () => Menu,
    NavSelect: () => NavSelect,
    Player: () => Player,
    PlayerCta: () => PlayerCta_default,
    Process: () => Process,
    ProjectAnchors: () => ProjectAnchors,
    Scroll: () => Scroll_default,
    SectorAnchors: () => SectorAnchors,
    Timeline: () => Timeline2,
    VideoInline: () => VideoInline
  });

  // assets/scripts/modules/Accordion.js
  var _Accordion = class _Accordion extends _default {
    constructor(m3) {
      super(m3);
      this.onClickBind = this.onClick.bind(this);
      this.$summary = this.$("summary")[0];
      this.$content = this.$("content")[0];
      this.$parent = this.el.closest("[data-accordion-parent]") || null;
      this.hasAbsoluteSummary = this.el.dataset.accordionAbsoluteSummary != void 0;
      this.animation = null;
      this.isClosing = false;
      this.isExpanding = false;
    }
    init() {
      this.bindEvents();
    }
    destroy() {
      super.destroy();
      this.unbindEvents();
    }
    bindEvents() {
      this.$summary.addEventListener("click", this.onClickBind);
    }
    unbindEvents() {
      this.$summary.removeEventListener("click", this.onClickBind);
    }
    onClick(e5) {
      e5.preventDefault();
      if (this.isClosing || !this.el.open) {
        this.open();
      } else if (this.isExpanding || this.el.open) {
        this.shrink();
      }
    }
    shrink() {
      var _a;
      this.isClosing = true;
      this.el.classList.remove(_Accordion.CLASS_ACTIVE);
      this.el.style.overflow = "hidden";
      if (this.$parent) this.$parent.classList.remove(_Accordion.CLASS_ACTIVE);
      const startHeight = `${this.el.offsetHeight}px`;
      const endHeight = `${this.hasAbsoluteSummary ? 0 : this.$summary.offsetHeight}px`;
      if (this.animation) {
        this.animation.cancel();
      }
      this.animation = this.el.animate(
        {
          height: [startHeight, endHeight]
        },
        {
          duration: _Accordion.DURATION,
          easing: _Accordion.EASING
        }
      );
      this.animation.onfinish = () => this.onAnimationFinish(false);
      this.animation.oncancel = () => {
        this.isClosing = false;
        this.el.classList.add(_Accordion.CLASS_ACTIVE);
      };
      (_a = this.onShrink) == null ? void 0 : _a.call(this, this.el);
    }
    open() {
      var _a;
      this.el.style.height = `${this.el.offsetHeight}px`;
      this.el.open = true;
      this.el.style.overflow = "hidden";
      window.requestAnimationFrame(() => this.expand());
      (_a = this.onOpen) == null ? void 0 : _a.call(this, this.el);
    }
    expand() {
      this.isExpanding = true;
      this.el.classList.add(_Accordion.CLASS_ACTIVE);
      if (this.$parent) this.$parent.classList.add(_Accordion.CLASS_ACTIVE);
      const startHeight = `${this.el.offsetHeight}px`;
      const endHeight = `${(this.hasAbsoluteSummary ? 0 : this.$summary.offsetHeight) + this.$content.offsetHeight}px`;
      if (this.animation) {
        this.animation.cancel();
      }
      this.animation = this.el.animate(
        {
          height: [startHeight, endHeight]
        },
        {
          duration: _Accordion.DURATION,
          easing: _Accordion.EASING
        }
      );
      this.animation.onfinish = () => this.onAnimationFinish(true);
      this.animation.oncancel = () => {
        this.isExpanding = false;
        this.el.classList.remove(_Accordion.CLASS_ACTIVE);
      };
    }
    onAnimationFinish(open) {
      this.el.open = open;
      this.animation = null;
      this.isClosing = false;
      this.isExpanding = false;
      this.el.style.height = this.el.style.overflow = "";
    }
  };
  __publicField(_Accordion, "CLASS_ACTIVE", "is-active");
  __publicField(_Accordion, "EASING", "cubic-bezier(0.33, 1, 0.68, 1)");
  __publicField(_Accordion, "DURATION", 300);
  var Accordion = _Accordion;

  // node_modules/gsap/gsap-core.js
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var _config = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
      lineHeight: ""
    }
  };
  var _defaults = {
    duration: 0.5,
    overwrite: false,
    delay: 0
  };
  var _suppressOverwrites;
  var _reverting;
  var _context;
  var _bigNum = 1e8;
  var _tinyNum = 1 / _bigNum;
  var _2PI = Math.PI * 2;
  var _HALF_PI = _2PI / 4;
  var _gsID = 0;
  var _sqrt = Math.sqrt;
  var _cos = Math.cos;
  var _sin = Math.sin;
  var _isString = function _isString2(value2) {
    return typeof value2 === "string";
  };
  var _isFunction = function _isFunction2(value2) {
    return typeof value2 === "function";
  };
  var _isNumber = function _isNumber2(value2) {
    return typeof value2 === "number";
  };
  var _isUndefined = function _isUndefined2(value2) {
    return typeof value2 === "undefined";
  };
  var _isObject = function _isObject2(value2) {
    return typeof value2 === "object";
  };
  var _isNotFalse = function _isNotFalse2(value2) {
    return value2 !== false;
  };
  var _windowExists = function _windowExists2() {
    return typeof window !== "undefined";
  };
  var _isFuncOrString = function _isFuncOrString2(value2) {
    return _isFunction(value2) || _isString(value2);
  };
  var _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function() {
  };
  var _isArray = Array.isArray;
  var _strictNumExp = /(?:-?\.?\d|\.)+/gi;
  var _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g;
  var _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g;
  var _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi;
  var _relExp = /[+-]=-?[.\d]+/;
  var _delimitedValueExp = /[^,'"\[\]\s]+/gi;
  var _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i;
  var _globalTimeline;
  var _win;
  var _coreInitted;
  var _doc;
  var _globals = {};
  var _installScope = {};
  var _coreReady;
  var _install = function _install2(scope) {
    return (_installScope = _merge(scope, _globals)) && gsap;
  };
  var _missingPlugin = function _missingPlugin2(property2, value2) {
    return console.warn("Invalid property", property2, "set to", value2, "Missing plugin? gsap.registerPlugin()");
  };
  var _warn = function _warn2(message, suppress) {
    return !suppress && console.warn(message);
  };
  var _addGlobal = function _addGlobal2(name2, obj) {
    return name2 && (_globals[name2] = obj) && _installScope && (_installScope[name2] = obj) || _globals;
  };
  var _emptyFunc = function _emptyFunc2() {
    return 0;
  };
  var _startAtRevertConfig = {
    suppressEvents: true,
    isStart: true,
    kill: false
  };
  var _revertConfigNoKill = {
    suppressEvents: true,
    kill: false
  };
  var _revertConfig = {
    suppressEvents: true
  };
  var _reservedProps = {};
  var _lazyTweens = [];
  var _lazyLookup = {};
  var _lastRenderedFrame;
  var _plugins = {};
  var _effects = {};
  var _nextGCFrame = 30;
  var _harnessPlugins = [];
  var _callbackNames = "";
  var _harness = function _harness2(targets) {
    var target = targets[0], harnessPlugin, i6;
    _isObject(target) || _isFunction(target) || (targets = [targets]);
    if (!(harnessPlugin = (target._gsap || {}).harness)) {
      i6 = _harnessPlugins.length;
      while (i6-- && !_harnessPlugins[i6].targetTest(target)) {
      }
      harnessPlugin = _harnessPlugins[i6];
    }
    i6 = targets.length;
    while (i6--) {
      targets[i6] && (targets[i6]._gsap || (targets[i6]._gsap = new GSCache(targets[i6], harnessPlugin))) || targets.splice(i6, 1);
    }
    return targets;
  };
  var _getCache = function _getCache2(target) {
    return target._gsap || _harness(toArray(target))[0]._gsap;
  };
  var _getProperty = function _getProperty2(target, property2, v2) {
    return (v2 = target[property2]) && _isFunction(v2) ? target[property2]() : _isUndefined(v2) && target.getAttribute && target.getAttribute(property2) || v2;
  };
  var _forEachName = function _forEachName2(names, func) {
    return (names = names.split(",")).forEach(func) || names;
  };
  var _round = function _round2(value2) {
    return Math.round(value2 * 1e5) / 1e5 || 0;
  };
  var _roundPrecise = function _roundPrecise2(value2) {
    return Math.round(value2 * 1e7) / 1e7 || 0;
  };
  var _parseRelative = function _parseRelative2(start, value2) {
    var operator = value2.charAt(0), end = parseFloat(value2.substr(2));
    start = parseFloat(start);
    return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
  };
  var _arrayContainsAny = function _arrayContainsAny2(toSearch, toFind) {
    var l6 = toFind.length, i6 = 0;
    for (; toSearch.indexOf(toFind[i6]) < 0 && ++i6 < l6; ) {
    }
    return i6 < l6;
  };
  var _lazyRender = function _lazyRender2() {
    var l6 = _lazyTweens.length, a5 = _lazyTweens.slice(0), i6, tween;
    _lazyLookup = {};
    _lazyTweens.length = 0;
    for (i6 = 0; i6 < l6; i6++) {
      tween = a5[i6];
      tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
    }
  };
  var _lazySafeRender = function _lazySafeRender2(animation, time2, suppressEvents, force) {
    _lazyTweens.length && !_reverting && _lazyRender();
    animation.render(time2, suppressEvents, force || _reverting && time2 < 0 && (animation._initted || animation._startAt));
    _lazyTweens.length && !_reverting && _lazyRender();
  };
  var _numericIfPossible = function _numericIfPossible2(value2) {
    var n6 = parseFloat(value2);
    return (n6 || n6 === 0) && (value2 + "").match(_delimitedValueExp).length < 2 ? n6 : _isString(value2) ? value2.trim() : value2;
  };
  var _passThrough = function _passThrough2(p3) {
    return p3;
  };
  var _setDefaults = function _setDefaults2(obj, defaults3) {
    for (var p3 in defaults3) {
      p3 in obj || (obj[p3] = defaults3[p3]);
    }
    return obj;
  };
  var _setKeyframeDefaults = function _setKeyframeDefaults2(excludeDuration) {
    return function(obj, defaults3) {
      for (var p3 in defaults3) {
        p3 in obj || p3 === "duration" && excludeDuration || p3 === "ease" || (obj[p3] = defaults3[p3]);
      }
    };
  };
  var _merge = function _merge2(base, toMerge) {
    for (var p3 in toMerge) {
      base[p3] = toMerge[p3];
    }
    return base;
  };
  var _mergeDeep = function _mergeDeep2(base, toMerge) {
    for (var p3 in toMerge) {
      p3 !== "__proto__" && p3 !== "constructor" && p3 !== "prototype" && (base[p3] = _isObject(toMerge[p3]) ? _mergeDeep2(base[p3] || (base[p3] = {}), toMerge[p3]) : toMerge[p3]);
    }
    return base;
  };
  var _copyExcluding = function _copyExcluding2(obj, excluding) {
    var copy = {}, p3;
    for (p3 in obj) {
      p3 in excluding || (copy[p3] = obj[p3]);
    }
    return copy;
  };
  var _inheritDefaults = function _inheritDefaults2(vars) {
    var parent2 = vars.parent || _globalTimeline, func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;
    if (_isNotFalse(vars.inherit)) {
      while (parent2) {
        func(vars, parent2.vars.defaults);
        parent2 = parent2.parent || parent2._dp;
      }
    }
    return vars;
  };
  var _arraysMatch = function _arraysMatch2(a1, a22) {
    var i6 = a1.length, match = i6 === a22.length;
    while (match && i6-- && a1[i6] === a22[i6]) {
    }
    return i6 < 0;
  };
  var _addLinkedListItem = function _addLinkedListItem2(parent2, child, firstProp, lastProp, sortBy) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }
    if (lastProp === void 0) {
      lastProp = "_last";
    }
    var prev = parent2[lastProp], t4;
    if (sortBy) {
      t4 = child[sortBy];
      while (prev && prev[sortBy] > t4) {
        prev = prev._prev;
      }
    }
    if (prev) {
      child._next = prev._next;
      prev._next = child;
    } else {
      child._next = parent2[firstProp];
      parent2[firstProp] = child;
    }
    if (child._next) {
      child._next._prev = child;
    } else {
      parent2[lastProp] = child;
    }
    child._prev = prev;
    child.parent = child._dp = parent2;
    return child;
  };
  var _removeLinkedListItem = function _removeLinkedListItem2(parent2, child, firstProp, lastProp) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }
    if (lastProp === void 0) {
      lastProp = "_last";
    }
    var prev = child._prev, next = child._next;
    if (prev) {
      prev._next = next;
    } else if (parent2[firstProp] === child) {
      parent2[firstProp] = next;
    }
    if (next) {
      next._prev = prev;
    } else if (parent2[lastProp] === child) {
      parent2[lastProp] = prev;
    }
    child._next = child._prev = child.parent = null;
  };
  var _removeFromParent = function _removeFromParent2(child, onlyIfParentHasAutoRemove) {
    child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);
    child._act = 0;
  };
  var _uncache = function _uncache2(animation, child) {
    if (animation && (!child || child._end > animation._dur || child._start < 0)) {
      var a5 = animation;
      while (a5) {
        a5._dirty = 1;
        a5 = a5.parent;
      }
    }
    return animation;
  };
  var _recacheAncestors = function _recacheAncestors2(animation) {
    var parent2 = animation.parent;
    while (parent2 && parent2.parent) {
      parent2._dirty = 1;
      parent2.totalDuration();
      parent2 = parent2.parent;
    }
    return animation;
  };
  var _rewindStartAt = function _rewindStartAt2(tween, totalTime, suppressEvents, force) {
    return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
  };
  var _hasNoPausedAncestors = function _hasNoPausedAncestors2(animation) {
    return !animation || animation._ts && _hasNoPausedAncestors2(animation.parent);
  };
  var _elapsedCycleDuration = function _elapsedCycleDuration2(animation) {
    return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
  };
  var _animationCycle = function _animationCycle2(tTime, cycleDuration) {
    var whole = Math.floor(tTime /= cycleDuration);
    return tTime && whole === tTime ? whole - 1 : whole;
  };
  var _parentToChildTotalTime = function _parentToChildTotalTime2(parentTime, child) {
    return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
  };
  var _setEnd = function _setEnd2(animation) {
    return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
  };
  var _alignPlayhead = function _alignPlayhead2(animation, totalTime) {
    var parent2 = animation._dp;
    if (parent2 && parent2.smoothChildTiming && animation._ts) {
      animation._start = _roundPrecise(parent2._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
      _setEnd(animation);
      parent2._dirty || _uncache(parent2, animation);
    }
    return animation;
  };
  var _postAddChecks = function _postAddChecks2(timeline2, child) {
    var t4;
    if (child._time || !child._dur && child._initted || child._start < timeline2._time && (child._dur || !child.add)) {
      t4 = _parentToChildTotalTime(timeline2.rawTime(), child);
      if (!child._dur || _clamp(0, child.totalDuration(), t4) - child._tTime > _tinyNum) {
        child.render(t4, true);
      }
    }
    if (_uncache(timeline2, child)._dp && timeline2._initted && timeline2._time >= timeline2._dur && timeline2._ts) {
      if (timeline2._dur < timeline2.duration()) {
        t4 = timeline2;
        while (t4._dp) {
          t4.rawTime() >= 0 && t4.totalTime(t4._tTime);
          t4 = t4._dp;
        }
      }
      timeline2._zTime = -_tinyNum;
    }
  };
  var _addToTimeline = function _addToTimeline2(timeline2, child, position2, skipChecks) {
    child.parent && _removeFromParent(child);
    child._start = _roundPrecise((_isNumber(position2) ? position2 : position2 || timeline2 !== _globalTimeline ? _parsePosition(timeline2, position2, child) : timeline2._time) + child._delay);
    child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
    _addLinkedListItem(timeline2, child, "_first", "_last", timeline2._sort ? "_start" : 0);
    _isFromOrFromStart(child) || (timeline2._recent = child);
    skipChecks || _postAddChecks(timeline2, child);
    timeline2._ts < 0 && _alignPlayhead(timeline2, timeline2._tTime);
    return timeline2;
  };
  var _scrollTrigger = function _scrollTrigger2(animation, trigger) {
    return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
  };
  var _attemptInitTween = function _attemptInitTween2(tween, time2, force, suppressEvents, tTime) {
    _initTween(tween, time2, tTime);
    if (!tween._initted) {
      return 1;
    }
    if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
      _lazyTweens.push(tween);
      tween._lazy = [tTime, suppressEvents];
      return 1;
    }
  };
  var _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart2(_ref) {
    var parent2 = _ref.parent;
    return parent2 && parent2._ts && parent2._initted && !parent2._lock && (parent2.rawTime() < 0 || _parentPlayheadIsBeforeStart2(parent2));
  };
  var _isFromOrFromStart = function _isFromOrFromStart2(_ref2) {
    var data2 = _ref2.data;
    return data2 === "isFromStart" || data2 === "isStart";
  };
  var _renderZeroDurationTween = function _renderZeroDurationTween2(tween, totalTime, suppressEvents, force) {
    var prevRatio = tween.ratio, ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1, repeatDelay = tween._rDelay, tTime = 0, pt, iteration, prevIteration;
    if (repeatDelay && tween._repeat) {
      tTime = _clamp(0, tween._tDur, totalTime);
      iteration = _animationCycle(tTime, repeatDelay);
      tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
      if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
        prevRatio = 1 - ratio;
        tween.vars.repeatRefresh && tween._initted && tween.invalidate();
      }
    }
    if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
      if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {
        return;
      }
      prevIteration = tween._zTime;
      tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
      suppressEvents || (suppressEvents = totalTime && !prevIteration);
      tween.ratio = ratio;
      tween._from && (ratio = 1 - ratio);
      tween._time = 0;
      tween._tTime = tTime;
      pt = tween._pt;
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
      totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
      tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
      tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
      if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
        ratio && _removeFromParent(tween, 1);
        if (!suppressEvents && !_reverting) {
          _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
          tween._prom && tween._prom();
        }
      }
    } else if (!tween._zTime) {
      tween._zTime = totalTime;
    }
  };
  var _findNextPauseTween = function _findNextPauseTween2(animation, prevTime, time2) {
    var child;
    if (time2 > prevTime) {
      child = animation._first;
      while (child && child._start <= time2) {
        if (child.data === "isPause" && child._start > prevTime) {
          return child;
        }
        child = child._next;
      }
    } else {
      child = animation._last;
      while (child && child._start >= time2) {
        if (child.data === "isPause" && child._start < prevTime) {
          return child;
        }
        child = child._prev;
      }
    }
  };
  var _setDuration = function _setDuration2(animation, duration, skipUncache, leavePlayhead) {
    var repeat = animation._repeat, dur = _roundPrecise(duration) || 0, totalProgress = animation._tTime / animation._tDur;
    totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
    animation._dur = dur;
    animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
    totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
    animation.parent && _setEnd(animation);
    skipUncache || _uncache(animation.parent, animation);
    return animation;
  };
  var _onUpdateTotalDuration = function _onUpdateTotalDuration2(animation) {
    return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
  };
  var _zeroPosition = {
    _start: 0,
    endTime: _emptyFunc,
    totalDuration: _emptyFunc
  };
  var _parsePosition = function _parsePosition2(animation, position2, percentAnimation) {
    var labels = animation.labels, recent = animation._recent || _zeroPosition, clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur, i6, offset, isPercent;
    if (_isString(position2) && (isNaN(position2) || position2 in labels)) {
      offset = position2.charAt(0);
      isPercent = position2.substr(-1) === "%";
      i6 = position2.indexOf("=");
      if (offset === "<" || offset === ">") {
        i6 >= 0 && (position2 = position2.replace(/=/, ""));
        return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position2.substr(1)) || 0) * (isPercent ? (i6 < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
      }
      if (i6 < 0) {
        position2 in labels || (labels[position2] = clippedDuration);
        return labels[position2];
      }
      offset = parseFloat(position2.charAt(i6 - 1) + position2.substr(i6 + 1));
      if (isPercent && percentAnimation) {
        offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
      }
      return i6 > 1 ? _parsePosition2(animation, position2.substr(0, i6 - 1), percentAnimation) + offset : clippedDuration + offset;
    }
    return position2 == null ? clippedDuration : +position2;
  };
  var _createTweenType = function _createTweenType2(type, params, timeline2) {
    var isLegacy = _isNumber(params[1]), varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1), vars = params[varsIndex], irVars, parent2;
    isLegacy && (vars.duration = params[1]);
    vars.parent = timeline2;
    if (type) {
      irVars = vars;
      parent2 = timeline2;
      while (parent2 && !("immediateRender" in irVars)) {
        irVars = parent2.vars.defaults || {};
        parent2 = _isNotFalse(parent2.vars.inherit) && parent2.parent;
      }
      vars.immediateRender = _isNotFalse(irVars.immediateRender);
      type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];
    }
    return new Tween(params[0], vars, params[varsIndex + 1]);
  };
  var _conditionalReturn = function _conditionalReturn2(value2, func) {
    return value2 || value2 === 0 ? func(value2) : func;
  };
  var _clamp = function _clamp2(min, max, value2) {
    return value2 < min ? min : value2 > max ? max : value2;
  };
  var getUnit = function getUnit2(value2, v2) {
    return !_isString(value2) || !(v2 = _unitExp.exec(value2)) ? "" : v2[1];
  };
  var clamp2 = function clamp3(min, max, value2) {
    return _conditionalReturn(value2, function(v2) {
      return _clamp(min, max, v2);
    });
  };
  var _slice = [].slice;
  var _isArrayLike = function _isArrayLike2(value2, nonEmpty) {
    return value2 && _isObject(value2) && "length" in value2 && (!nonEmpty && !value2.length || value2.length - 1 in value2 && _isObject(value2[0])) && !value2.nodeType && value2 !== _win;
  };
  var _flatten = function _flatten2(ar, leaveStrings, accumulator) {
    if (accumulator === void 0) {
      accumulator = [];
    }
    return ar.forEach(function(value2) {
      var _accumulator;
      return _isString(value2) && !leaveStrings || _isArrayLike(value2, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value2)) : accumulator.push(value2);
    }) || accumulator;
  };
  var toArray = function toArray2(value2, scope, leaveStrings) {
    return _context && !scope && _context.selector ? _context.selector(value2) : _isString(value2) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value2), 0) : _isArray(value2) ? _flatten(value2, leaveStrings) : _isArrayLike(value2) ? _slice.call(value2, 0) : value2 ? [value2] : [];
  };
  var selector = function selector2(value2) {
    value2 = toArray(value2)[0] || _warn("Invalid scope") || {};
    return function(v2) {
      var el = value2.current || value2.nativeElement || value2;
      return toArray(v2, el.querySelectorAll ? el : el === value2 ? _warn("Invalid scope") || _doc.createElement("div") : value2);
    };
  };
  var shuffle = function shuffle2(a5) {
    return a5.sort(function() {
      return 0.5 - Math.random();
    });
  };
  var distribute = function distribute2(v2) {
    if (_isFunction(v2)) {
      return v2;
    }
    var vars = _isObject(v2) ? v2 : {
      each: v2
    }, ease2 = _parseEase(vars.ease), from = vars.from || 0, base = parseFloat(vars.base) || 0, cache = {}, isDecimal = from > 0 && from < 1, ratios = isNaN(from) || isDecimal, axis = vars.axis, ratioX = from, ratioY = from;
    if (_isString(from)) {
      ratioX = ratioY = {
        center: 0.5,
        edges: 0.5,
        end: 1
      }[from] || 0;
    } else if (!isDecimal && ratios) {
      ratioX = from[0];
      ratioY = from[1];
    }
    return function(i6, target, a5) {
      var l6 = (a5 || vars).length, distances = cache[l6], originX, originY, x3, y3, d3, j3, max, min, wrapAt;
      if (!distances) {
        wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];
        if (!wrapAt) {
          max = -_bigNum;
          while (max < (max = a5[wrapAt++].getBoundingClientRect().left) && wrapAt < l6) {
          }
          wrapAt < l6 && wrapAt--;
        }
        distances = cache[l6] = [];
        originX = ratios ? Math.min(wrapAt, l6) * ratioX - 0.5 : from % wrapAt;
        originY = wrapAt === _bigNum ? 0 : ratios ? l6 * ratioY / wrapAt - 0.5 : from / wrapAt | 0;
        max = 0;
        min = _bigNum;
        for (j3 = 0; j3 < l6; j3++) {
          x3 = j3 % wrapAt - originX;
          y3 = originY - (j3 / wrapAt | 0);
          distances[j3] = d3 = !axis ? _sqrt(x3 * x3 + y3 * y3) : Math.abs(axis === "y" ? y3 : x3);
          d3 > max && (max = d3);
          d3 < min && (min = d3);
        }
        from === "random" && shuffle(distances);
        distances.max = max - min;
        distances.min = min;
        distances.v = l6 = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l6 ? l6 - 1 : !axis ? Math.max(wrapAt, l6 / wrapAt) : axis === "y" ? l6 / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
        distances.b = l6 < 0 ? base - l6 : base;
        distances.u = getUnit(vars.amount || vars.each) || 0;
        ease2 = ease2 && l6 < 0 ? _invertEase(ease2) : ease2;
      }
      l6 = (distances[i6] - distances.min) / distances.max || 0;
      return _roundPrecise(distances.b + (ease2 ? ease2(l6) : l6) * distances.v) + distances.u;
    };
  };
  var _roundModifier = function _roundModifier2(v2) {
    var p3 = Math.pow(10, ((v2 + "").split(".")[1] || "").length);
    return function(raw) {
      var n6 = _roundPrecise(Math.round(parseFloat(raw) / v2) * v2 * p3);
      return (n6 - n6 % 1) / p3 + (_isNumber(raw) ? 0 : getUnit(raw));
    };
  };
  var snap = function snap2(snapTo, value2) {
    var isArray = _isArray(snapTo), radius, is2D;
    if (!isArray && _isObject(snapTo)) {
      radius = isArray = snapTo.radius || _bigNum;
      if (snapTo.values) {
        snapTo = toArray(snapTo.values);
        if (is2D = !_isNumber(snapTo[0])) {
          radius *= radius;
        }
      } else {
        snapTo = _roundModifier(snapTo.increment);
      }
    }
    return _conditionalReturn(value2, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {
      is2D = snapTo(raw);
      return Math.abs(is2D - raw) <= radius ? is2D : raw;
    } : function(raw) {
      var x3 = parseFloat(is2D ? raw.x : raw), y3 = parseFloat(is2D ? raw.y : 0), min = _bigNum, closest = 0, i6 = snapTo.length, dx, dy;
      while (i6--) {
        if (is2D) {
          dx = snapTo[i6].x - x3;
          dy = snapTo[i6].y - y3;
          dx = dx * dx + dy * dy;
        } else {
          dx = Math.abs(snapTo[i6] - x3);
        }
        if (dx < min) {
          min = dx;
          closest = i6;
        }
      }
      closest = !radius || min <= radius ? snapTo[closest] : raw;
      return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
    });
  };
  var random2 = function random3(min, max, roundingIncrement, returnFunction) {
    return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {
      return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * 0.99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
    });
  };
  var pipe = function pipe2() {
    for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
      functions[_key] = arguments[_key];
    }
    return function(value2) {
      return functions.reduce(function(v2, f3) {
        return f3(v2);
      }, value2);
    };
  };
  var unitize = function unitize2(func, unit) {
    return function(value2) {
      return func(parseFloat(value2)) + (unit || getUnit(value2));
    };
  };
  var normalize2 = function normalize3(min, max, value2) {
    return mapRange(min, max, 0, 1, value2);
  };
  var _wrapArray = function _wrapArray2(a5, wrapper, value2) {
    return _conditionalReturn(value2, function(index2) {
      return a5[~~wrapper(index2)];
    });
  };
  var wrap = function wrap2(min, max, value2) {
    var range = max - min;
    return _isArray(min) ? _wrapArray(min, wrap2(0, min.length), max) : _conditionalReturn(value2, function(value3) {
      return (range + (value3 - min) % range) % range + min;
    });
  };
  var wrapYoyo = function wrapYoyo2(min, max, value2) {
    var range = max - min, total = range * 2;
    return _isArray(min) ? _wrapArray(min, wrapYoyo2(0, min.length - 1), max) : _conditionalReturn(value2, function(value3) {
      value3 = (total + (value3 - min) % total) % total || 0;
      return min + (value3 > range ? total - value3 : value3);
    });
  };
  var _replaceRandom = function _replaceRandom2(value2) {
    var prev = 0, s4 = "", i6, nums, end, isArray;
    while (~(i6 = value2.indexOf("random(", prev))) {
      end = value2.indexOf(")", i6);
      isArray = value2.charAt(i6 + 7) === "[";
      nums = value2.substr(i6 + 7, end - i6 - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
      s4 += value2.substr(prev, i6 - prev) + random2(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
      prev = end + 1;
    }
    return s4 + value2.substr(prev, value2.length - prev);
  };
  var mapRange = function mapRange2(inMin, inMax, outMin, outMax, value2) {
    var inRange = inMax - inMin, outRange = outMax - outMin;
    return _conditionalReturn(value2, function(value3) {
      return outMin + ((value3 - inMin) / inRange * outRange || 0);
    });
  };
  var interpolate = function interpolate2(start, end, progress, mutate) {
    var func = isNaN(start + end) ? 0 : function(p4) {
      return (1 - p4) * start + p4 * end;
    };
    if (!func) {
      var isString = _isString(start), master = {}, p3, i6, interpolators, l6, il;
      progress === true && (mutate = 1) && (progress = null);
      if (isString) {
        start = {
          p: start
        };
        end = {
          p: end
        };
      } else if (_isArray(start) && !_isArray(end)) {
        interpolators = [];
        l6 = start.length;
        il = l6 - 2;
        for (i6 = 1; i6 < l6; i6++) {
          interpolators.push(interpolate2(start[i6 - 1], start[i6]));
        }
        l6--;
        func = function func2(p4) {
          p4 *= l6;
          var i7 = Math.min(il, ~~p4);
          return interpolators[i7](p4 - i7);
        };
        progress = end;
      } else if (!mutate) {
        start = _merge(_isArray(start) ? [] : {}, start);
      }
      if (!interpolators) {
        for (p3 in end) {
          _addPropTween.call(master, start, p3, "get", end[p3]);
        }
        func = function func2(p4) {
          return _renderPropTweens(p4, master) || (isString ? start.p : start);
        };
      }
    }
    return _conditionalReturn(progress, func);
  };
  var _getLabelInDirection = function _getLabelInDirection2(timeline2, fromTime, backward) {
    var labels = timeline2.labels, min = _bigNum, p3, distance, label;
    for (p3 in labels) {
      distance = labels[p3] - fromTime;
      if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
        label = p3;
        min = distance;
      }
    }
    return label;
  };
  var _callback = function _callback2(animation, type, executeLazyFirst) {
    var v2 = animation.vars, callback = v2[type], prevContext = _context, context3 = animation._ctx, params, scope, result;
    if (!callback) {
      return;
    }
    params = v2[type + "Params"];
    scope = v2.callbackScope || animation;
    executeLazyFirst && _lazyTweens.length && _lazyRender();
    context3 && (_context = context3);
    result = params ? callback.apply(scope, params) : callback.call(scope);
    _context = prevContext;
    return result;
  };
  var _interrupt = function _interrupt2(animation) {
    _removeFromParent(animation);
    animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);
    animation.progress() < 1 && _callback(animation, "onInterrupt");
    return animation;
  };
  var _quickTween;
  var _registerPluginQueue = [];
  var _createPlugin = function _createPlugin2(config3) {
    if (!config3) return;
    config3 = !config3.name && config3["default"] || config3;
    if (_windowExists() || config3.headless) {
      var name2 = config3.name, isFunc = _isFunction(config3), Plugin = name2 && !isFunc && config3.init ? function() {
        this._props = [];
      } : config3, instanceDefaults = {
        init: _emptyFunc,
        render: _renderPropTweens,
        add: _addPropTween,
        kill: _killPropTweensOf,
        modifier: _addPluginModifier,
        rawVars: 0
      }, statics = {
        targetTest: 0,
        get: 0,
        getSetter: _getSetter,
        aliases: {},
        register: 0
      };
      _wake();
      if (config3 !== Plugin) {
        if (_plugins[name2]) {
          return;
        }
        _setDefaults(Plugin, _setDefaults(_copyExcluding(config3, instanceDefaults), statics));
        _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config3, statics)));
        _plugins[Plugin.prop = name2] = Plugin;
        if (config3.targetTest) {
          _harnessPlugins.push(Plugin);
          _reservedProps[name2] = 1;
        }
        name2 = (name2 === "css" ? "CSS" : name2.charAt(0).toUpperCase() + name2.substr(1)) + "Plugin";
      }
      _addGlobal(name2, Plugin);
      config3.register && config3.register(gsap, Plugin, PropTween);
    } else {
      _registerPluginQueue.push(config3);
    }
  };
  var _255 = 255;
  var _colorLookup = {
    aqua: [0, _255, _255],
    lime: [0, _255, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, _255],
    navy: [0, 0, 128],
    white: [_255, _255, _255],
    olive: [128, 128, 0],
    yellow: [_255, _255, 0],
    orange: [_255, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [_255, 0, 0],
    pink: [_255, 192, 203],
    cyan: [0, _255, _255],
    transparent: [_255, _255, _255, 0]
  };
  var _hue = function _hue2(h2, m1, m22) {
    h2 += h2 < 0 ? 1 : h2 > 1 ? -1 : 0;
    return (h2 * 6 < 1 ? m1 + (m22 - m1) * h2 * 6 : h2 < 0.5 ? m22 : h2 * 3 < 2 ? m1 + (m22 - m1) * (2 / 3 - h2) * 6 : m1) * _255 + 0.5 | 0;
  };
  var splitColor = function splitColor2(v2, toHSL, forceAlpha) {
    var a5 = !v2 ? _colorLookup.black : _isNumber(v2) ? [v2 >> 16, v2 >> 8 & _255, v2 & _255] : 0, r6, g3, b3, h2, s4, l6, max, min, d3, wasHSL;
    if (!a5) {
      if (v2.substr(-1) === ",") {
        v2 = v2.substr(0, v2.length - 1);
      }
      if (_colorLookup[v2]) {
        a5 = _colorLookup[v2];
      } else if (v2.charAt(0) === "#") {
        if (v2.length < 6) {
          r6 = v2.charAt(1);
          g3 = v2.charAt(2);
          b3 = v2.charAt(3);
          v2 = "#" + r6 + r6 + g3 + g3 + b3 + b3 + (v2.length === 5 ? v2.charAt(4) + v2.charAt(4) : "");
        }
        if (v2.length === 9) {
          a5 = parseInt(v2.substr(1, 6), 16);
          return [a5 >> 16, a5 >> 8 & _255, a5 & _255, parseInt(v2.substr(7), 16) / 255];
        }
        v2 = parseInt(v2.substr(1), 16);
        a5 = [v2 >> 16, v2 >> 8 & _255, v2 & _255];
      } else if (v2.substr(0, 3) === "hsl") {
        a5 = wasHSL = v2.match(_strictNumExp);
        if (!toHSL) {
          h2 = +a5[0] % 360 / 360;
          s4 = +a5[1] / 100;
          l6 = +a5[2] / 100;
          g3 = l6 <= 0.5 ? l6 * (s4 + 1) : l6 + s4 - l6 * s4;
          r6 = l6 * 2 - g3;
          a5.length > 3 && (a5[3] *= 1);
          a5[0] = _hue(h2 + 1 / 3, r6, g3);
          a5[1] = _hue(h2, r6, g3);
          a5[2] = _hue(h2 - 1 / 3, r6, g3);
        } else if (~v2.indexOf("=")) {
          a5 = v2.match(_numExp);
          forceAlpha && a5.length < 4 && (a5[3] = 1);
          return a5;
        }
      } else {
        a5 = v2.match(_strictNumExp) || _colorLookup.transparent;
      }
      a5 = a5.map(Number);
    }
    if (toHSL && !wasHSL) {
      r6 = a5[0] / _255;
      g3 = a5[1] / _255;
      b3 = a5[2] / _255;
      max = Math.max(r6, g3, b3);
      min = Math.min(r6, g3, b3);
      l6 = (max + min) / 2;
      if (max === min) {
        h2 = s4 = 0;
      } else {
        d3 = max - min;
        s4 = l6 > 0.5 ? d3 / (2 - max - min) : d3 / (max + min);
        h2 = max === r6 ? (g3 - b3) / d3 + (g3 < b3 ? 6 : 0) : max === g3 ? (b3 - r6) / d3 + 2 : (r6 - g3) / d3 + 4;
        h2 *= 60;
      }
      a5[0] = ~~(h2 + 0.5);
      a5[1] = ~~(s4 * 100 + 0.5);
      a5[2] = ~~(l6 * 100 + 0.5);
    }
    forceAlpha && a5.length < 4 && (a5[3] = 1);
    return a5;
  };
  var _colorOrderData = function _colorOrderData2(v2) {
    var values = [], c4 = [], i6 = -1;
    v2.split(_colorExp).forEach(function(v3) {
      var a5 = v3.match(_numWithUnitExp) || [];
      values.push.apply(values, a5);
      c4.push(i6 += a5.length + 1);
    });
    values.c = c4;
    return values;
  };
  var _formatColors = function _formatColors2(s4, toHSL, orderMatchData) {
    var result = "", colors = (s4 + result).match(_colorExp), type = toHSL ? "hsla(" : "rgba(", i6 = 0, c4, shell, d3, l6;
    if (!colors) {
      return s4;
    }
    colors = colors.map(function(color) {
      return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
    });
    if (orderMatchData) {
      d3 = _colorOrderData(s4);
      c4 = orderMatchData.c;
      if (c4.join(result) !== d3.c.join(result)) {
        shell = s4.replace(_colorExp, "1").split(_numWithUnitExp);
        l6 = shell.length - 1;
        for (; i6 < l6; i6++) {
          result += shell[i6] + (~c4.indexOf(i6) ? colors.shift() || type + "0,0,0,0)" : (d3.length ? d3 : colors.length ? colors : orderMatchData).shift());
        }
      }
    }
    if (!shell) {
      shell = s4.split(_colorExp);
      l6 = shell.length - 1;
      for (; i6 < l6; i6++) {
        result += shell[i6] + colors[i6];
      }
    }
    return result + shell[l6];
  };
  var _colorExp = function() {
    var s4 = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", p3;
    for (p3 in _colorLookup) {
      s4 += "|" + p3 + "\\b";
    }
    return new RegExp(s4 + ")", "gi");
  }();
  var _hslExp = /hsl[a]?\(/;
  var _colorStringFilter = function _colorStringFilter2(a5) {
    var combined = a5.join(" "), toHSL;
    _colorExp.lastIndex = 0;
    if (_colorExp.test(combined)) {
      toHSL = _hslExp.test(combined);
      a5[1] = _formatColors(a5[1], toHSL);
      a5[0] = _formatColors(a5[0], toHSL, _colorOrderData(a5[1]));
      return true;
    }
  };
  var _tickerActive;
  var _ticker = function() {
    var _getTime = Date.now, _lagThreshold = 500, _adjustedLag = 33, _startTime = _getTime(), _lastUpdate = _startTime, _gap = 1e3 / 240, _nextTime = _gap, _listeners2 = [], _id, _req, _raf, _self, _delta, _i, _tick = function _tick2(v2) {
      var elapsed = _getTime() - _lastUpdate, manual = v2 === true, overlap, dispatch, time2, frame;
      (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);
      _lastUpdate += elapsed;
      time2 = _lastUpdate - _startTime;
      overlap = time2 - _nextTime;
      if (overlap > 0 || manual) {
        frame = ++_self.frame;
        _delta = time2 - _self.time * 1e3;
        _self.time = time2 = time2 / 1e3;
        _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
        dispatch = 1;
      }
      manual || (_id = _req(_tick2));
      if (dispatch) {
        for (_i = 0; _i < _listeners2.length; _i++) {
          _listeners2[_i](time2, _delta, frame, v2);
        }
      }
    };
    _self = {
      time: 0,
      frame: 0,
      tick: function tick() {
        _tick(true);
      },
      deltaRatio: function deltaRatio(fps) {
        return _delta / (1e3 / (fps || 60));
      },
      wake: function wake() {
        if (_coreReady) {
          if (!_coreInitted && _windowExists()) {
            _win = _coreInitted = window;
            _doc = _win.document || {};
            _globals.gsap = gsap;
            (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);
            _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});
            _registerPluginQueue.forEach(_createPlugin);
          }
          _raf = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame;
          _id && _self.sleep();
          _req = _raf || function(f3) {
            return setTimeout(f3, _nextTime - _self.time * 1e3 + 1 | 0);
          };
          _tickerActive = 1;
          _tick(2);
        }
      },
      sleep: function sleep() {
        (_raf ? cancelAnimationFrame : clearTimeout)(_id);
        _tickerActive = 0;
        _req = _emptyFunc;
      },
      lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
        _lagThreshold = threshold || Infinity;
        _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);
      },
      fps: function fps(_fps) {
        _gap = 1e3 / (_fps || 240);
        _nextTime = _self.time * 1e3 + _gap;
      },
      add: function add2(callback, once, prioritize) {
        var func = once ? function(t4, d3, f3, v2) {
          callback(t4, d3, f3, v2);
          _self.remove(func);
        } : callback;
        _self.remove(callback);
        _listeners2[prioritize ? "unshift" : "push"](func);
        _wake();
        return func;
      },
      remove: function remove(callback, i6) {
        ~(i6 = _listeners2.indexOf(callback)) && _listeners2.splice(i6, 1) && _i >= i6 && _i--;
      },
      _listeners: _listeners2
    };
    return _self;
  }();
  var _wake = function _wake2() {
    return !_tickerActive && _ticker.wake();
  };
  var _easeMap = {};
  var _customEaseExp = /^[\d.\-M][\d.\-,\s]/;
  var _quotesExp = /["']/g;
  var _parseObjectInString = function _parseObjectInString2(value2) {
    var obj = {}, split = value2.substr(1, value2.length - 3).split(":"), key2 = split[0], i6 = 1, l6 = split.length, index2, val2, parsedVal;
    for (; i6 < l6; i6++) {
      val2 = split[i6];
      index2 = i6 !== l6 - 1 ? val2.lastIndexOf(",") : val2.length;
      parsedVal = val2.substr(0, index2);
      obj[key2] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
      key2 = val2.substr(index2 + 1).trim();
    }
    return obj;
  };
  var _valueInParentheses = function _valueInParentheses2(value2) {
    var open = value2.indexOf("(") + 1, close = value2.indexOf(")"), nested = value2.indexOf("(", open);
    return value2.substring(open, ~nested && nested < close ? value2.indexOf(")", close + 1) : close);
  };
  var _configEaseFromString = function _configEaseFromString2(name2) {
    var split = (name2 + "").split("("), ease2 = _easeMap[split[0]];
    return ease2 && split.length > 1 && ease2.config ? ease2.config.apply(null, ~name2.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name2).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name2) ? _easeMap._CE("", name2) : ease2;
  };
  var _invertEase = function _invertEase2(ease2) {
    return function(p3) {
      return 1 - ease2(1 - p3);
    };
  };
  var _propagateYoyoEase = function _propagateYoyoEase2(timeline2, isYoyo) {
    var child = timeline2._first, ease2;
    while (child) {
      if (child instanceof Timeline) {
        _propagateYoyoEase2(child, isYoyo);
      } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
        if (child.timeline) {
          _propagateYoyoEase2(child.timeline, isYoyo);
        } else {
          ease2 = child._ease;
          child._ease = child._yEase;
          child._yEase = ease2;
          child._yoyo = isYoyo;
        }
      }
      child = child._next;
    }
  };
  var _parseEase = function _parseEase2(ease2, defaultEase) {
    return !ease2 ? defaultEase : (_isFunction(ease2) ? ease2 : _easeMap[ease2] || _configEaseFromString(ease2)) || defaultEase;
  };
  var _insertEase = function _insertEase2(names, easeIn2, easeOut2, easeInOut) {
    if (easeOut2 === void 0) {
      easeOut2 = function easeOut3(p3) {
        return 1 - easeIn2(1 - p3);
      };
    }
    if (easeInOut === void 0) {
      easeInOut = function easeInOut2(p3) {
        return p3 < 0.5 ? easeIn2(p3 * 2) / 2 : 1 - easeIn2((1 - p3) * 2) / 2;
      };
    }
    var ease2 = {
      easeIn: easeIn2,
      easeOut: easeOut2,
      easeInOut
    }, lowercaseName;
    _forEachName(names, function(name2) {
      _easeMap[name2] = _globals[name2] = ease2;
      _easeMap[lowercaseName = name2.toLowerCase()] = easeOut2;
      for (var p3 in ease2) {
        _easeMap[lowercaseName + (p3 === "easeIn" ? ".in" : p3 === "easeOut" ? ".out" : ".inOut")] = _easeMap[name2 + "." + p3] = ease2[p3];
      }
    });
    return ease2;
  };
  var _easeInOutFromOut = function _easeInOutFromOut2(easeOut2) {
    return function(p3) {
      return p3 < 0.5 ? (1 - easeOut2(1 - p3 * 2)) / 2 : 0.5 + easeOut2((p3 - 0.5) * 2) / 2;
    };
  };
  var _configElastic = function _configElastic2(type, amplitude, period) {
    var p1 = amplitude >= 1 ? amplitude : 1, p22 = (period || (type ? 0.3 : 0.45)) / (amplitude < 1 ? amplitude : 1), p3 = p22 / _2PI * (Math.asin(1 / p1) || 0), easeOut2 = function easeOut3(p4) {
      return p4 === 1 ? 1 : p1 * Math.pow(2, -10 * p4) * _sin((p4 - p3) * p22) + 1;
    }, ease2 = type === "out" ? easeOut2 : type === "in" ? function(p4) {
      return 1 - easeOut2(1 - p4);
    } : _easeInOutFromOut(easeOut2);
    p22 = _2PI / p22;
    ease2.config = function(amplitude2, period2) {
      return _configElastic2(type, amplitude2, period2);
    };
    return ease2;
  };
  var _configBack = function _configBack2(type, overshoot) {
    if (overshoot === void 0) {
      overshoot = 1.70158;
    }
    var easeOut2 = function easeOut3(p3) {
      return p3 ? --p3 * p3 * ((overshoot + 1) * p3 + overshoot) + 1 : 0;
    }, ease2 = type === "out" ? easeOut2 : type === "in" ? function(p3) {
      return 1 - easeOut2(1 - p3);
    } : _easeInOutFromOut(easeOut2);
    ease2.config = function(overshoot2) {
      return _configBack2(type, overshoot2);
    };
    return ease2;
  };
  _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(name2, i6) {
    var power = i6 < 5 ? i6 + 1 : i6;
    _insertEase(name2 + ",Power" + (power - 1), i6 ? function(p3) {
      return Math.pow(p3, power);
    } : function(p3) {
      return p3;
    }, function(p3) {
      return 1 - Math.pow(1 - p3, power);
    }, function(p3) {
      return p3 < 0.5 ? Math.pow(p3 * 2, power) / 2 : 1 - Math.pow((1 - p3) * 2, power) / 2;
    });
  });
  _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
  _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
  (function(n6, c4) {
    var n1 = 1 / c4, n22 = 2 * n1, n32 = 2.5 * n1, easeOut2 = function easeOut3(p3) {
      return p3 < n1 ? n6 * p3 * p3 : p3 < n22 ? n6 * Math.pow(p3 - 1.5 / c4, 2) + 0.75 : p3 < n32 ? n6 * (p3 -= 2.25 / c4) * p3 + 0.9375 : n6 * Math.pow(p3 - 2.625 / c4, 2) + 0.984375;
    };
    _insertEase("Bounce", function(p3) {
      return 1 - easeOut2(1 - p3);
    }, easeOut2);
  })(7.5625, 2.75);
  _insertEase("Expo", function(p3) {
    return p3 ? Math.pow(2, 10 * (p3 - 1)) : 0;
  });
  _insertEase("Circ", function(p3) {
    return -(_sqrt(1 - p3 * p3) - 1);
  });
  _insertEase("Sine", function(p3) {
    return p3 === 1 ? 1 : -_cos(p3 * _HALF_PI) + 1;
  });
  _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
  _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
    config: function config(steps, immediateStart) {
      if (steps === void 0) {
        steps = 1;
      }
      var p1 = 1 / steps, p22 = steps + (immediateStart ? 0 : 1), p3 = immediateStart ? 1 : 0, max = 1 - _tinyNum;
      return function(p4) {
        return ((p22 * _clamp(0, max, p4) | 0) + p3) * p1;
      };
    }
  };
  _defaults.ease = _easeMap["quad.out"];
  _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(name2) {
    return _callbackNames += name2 + "," + name2 + "Params,";
  });
  var GSCache = function GSCache2(target, harness) {
    this.id = _gsID++;
    target._gsap = this;
    this.target = target;
    this.harness = harness;
    this.get = harness ? harness.get : _getProperty;
    this.set = harness ? harness.getSetter : _getSetter;
  };
  var Animation = /* @__PURE__ */ function() {
    function Animation2(vars) {
      this.vars = vars;
      this._delay = +vars.delay || 0;
      if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
        this._rDelay = vars.repeatDelay || 0;
        this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
      }
      this._ts = 1;
      _setDuration(this, +vars.duration, 1, 1);
      this.data = vars.data;
      if (_context) {
        this._ctx = _context;
        _context.data.push(this);
      }
      _tickerActive || _ticker.wake();
    }
    var _proto = Animation2.prototype;
    _proto.delay = function delay3(value2) {
      if (value2 || value2 === 0) {
        this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value2 - this._delay);
        this._delay = value2;
        return this;
      }
      return this._delay;
    };
    _proto.duration = function duration(value2) {
      return arguments.length ? this.totalDuration(this._repeat > 0 ? value2 + (value2 + this._rDelay) * this._repeat : value2) : this.totalDuration() && this._dur;
    };
    _proto.totalDuration = function totalDuration(value2) {
      if (!arguments.length) {
        return this._tDur;
      }
      this._dirty = 0;
      return _setDuration(this, this._repeat < 0 ? value2 : (value2 - this._repeat * this._rDelay) / (this._repeat + 1));
    };
    _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
      _wake();
      if (!arguments.length) {
        return this._tTime;
      }
      var parent2 = this._dp;
      if (parent2 && parent2.smoothChildTiming && this._ts) {
        _alignPlayhead(this, _totalTime);
        !parent2._dp || parent2.parent || _postAddChecks(parent2, this);
        while (parent2 && parent2.parent) {
          if (parent2.parent._time !== parent2._start + (parent2._ts >= 0 ? parent2._tTime / parent2._ts : (parent2.totalDuration() - parent2._tTime) / -parent2._ts)) {
            parent2.totalTime(parent2._tTime, true);
          }
          parent2 = parent2.parent;
        }
        if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
          _addToTimeline(this._dp, this, this._start - this._delay);
        }
      }
      if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
        this._ts || (this._pTime = _totalTime);
        _lazySafeRender(this, _totalTime, suppressEvents);
      }
      return this;
    };
    _proto.time = function time2(value2, suppressEvents) {
      return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value2 + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value2 ? this._dur : 0), suppressEvents) : this._time;
    };
    _proto.totalProgress = function totalProgress(value2, suppressEvents) {
      return arguments.length ? this.totalTime(this.totalDuration() * value2, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0;
    };
    _proto.progress = function progress(value2, suppressEvents) {
      return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value2 : value2) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
    };
    _proto.iteration = function iteration(value2, suppressEvents) {
      var cycleDuration = this.duration() + this._rDelay;
      return arguments.length ? this.totalTime(this._time + (value2 - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
    };
    _proto.timeScale = function timeScale(value2, suppressEvents) {
      if (!arguments.length) {
        return this._rts === -_tinyNum ? 0 : this._rts;
      }
      if (this._rts === value2) {
        return this;
      }
      var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
      this._rts = +value2 || 0;
      this._ts = this._ps || value2 === -_tinyNum ? 0 : this._rts;
      this.totalTime(_clamp(-Math.abs(this._delay), this._tDur, tTime), suppressEvents !== false);
      _setEnd(this);
      return _recacheAncestors(this);
    };
    _proto.paused = function paused(value2) {
      if (!arguments.length) {
        return this._ps;
      }
      if (this._ps !== value2) {
        this._ps = value2;
        if (value2) {
          this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());
          this._ts = this._act = 0;
        } else {
          _wake();
          this._ts = this._rts;
          this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));
        }
      }
      return this;
    };
    _proto.startTime = function startTime(value2) {
      if (arguments.length) {
        this._start = value2;
        var parent2 = this.parent || this._dp;
        parent2 && (parent2._sort || !this.parent) && _addToTimeline(parent2, this, value2 - this._delay);
        return this;
      }
      return this._start;
    };
    _proto.endTime = function endTime(includeRepeats) {
      return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
    };
    _proto.rawTime = function rawTime(wrapRepeats) {
      var parent2 = this.parent || this._dp;
      return !parent2 ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent2.rawTime(wrapRepeats), this);
    };
    _proto.revert = function revert(config3) {
      if (config3 === void 0) {
        config3 = _revertConfig;
      }
      var prevIsReverting = _reverting;
      _reverting = config3;
      if (this._initted || this._startAt) {
        this.timeline && this.timeline.revert(config3);
        this.totalTime(-0.01, config3.suppressEvents);
      }
      this.data !== "nested" && config3.kill !== false && this.kill();
      _reverting = prevIsReverting;
      return this;
    };
    _proto.globalTime = function globalTime(rawTime) {
      var animation = this, time2 = arguments.length ? rawTime : animation.rawTime();
      while (animation) {
        time2 = animation._start + time2 / (Math.abs(animation._ts) || 1);
        animation = animation._dp;
      }
      return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time2;
    };
    _proto.repeat = function repeat(value2) {
      if (arguments.length) {
        this._repeat = value2 === Infinity ? -2 : value2;
        return _onUpdateTotalDuration(this);
      }
      return this._repeat === -2 ? Infinity : this._repeat;
    };
    _proto.repeatDelay = function repeatDelay(value2) {
      if (arguments.length) {
        var time2 = this._time;
        this._rDelay = value2;
        _onUpdateTotalDuration(this);
        return time2 ? this.time(time2) : this;
      }
      return this._rDelay;
    };
    _proto.yoyo = function yoyo(value2) {
      if (arguments.length) {
        this._yoyo = value2;
        return this;
      }
      return this._yoyo;
    };
    _proto.seek = function seek(position2, suppressEvents) {
      return this.totalTime(_parsePosition(this, position2), _isNotFalse(suppressEvents));
    };
    _proto.restart = function restart(includeDelay, suppressEvents) {
      return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
    };
    _proto.play = function play(from, suppressEvents) {
      from != null && this.seek(from, suppressEvents);
      return this.reversed(false).paused(false);
    };
    _proto.reverse = function reverse(from, suppressEvents) {
      from != null && this.seek(from || this.totalDuration(), suppressEvents);
      return this.reversed(true).paused(false);
    };
    _proto.pause = function pause(atTime, suppressEvents) {
      atTime != null && this.seek(atTime, suppressEvents);
      return this.paused(true);
    };
    _proto.resume = function resume() {
      return this.paused(false);
    };
    _proto.reversed = function reversed(value2) {
      if (arguments.length) {
        !!value2 !== this.reversed() && this.timeScale(-this._rts || (value2 ? -_tinyNum : 0));
        return this;
      }
      return this._rts < 0;
    };
    _proto.invalidate = function invalidate() {
      this._initted = this._act = 0;
      this._zTime = -_tinyNum;
      return this;
    };
    _proto.isActive = function isActive() {
      var parent2 = this.parent || this._dp, start = this._start, rawTime;
      return !!(!parent2 || this._ts && this._initted && parent2.isActive() && (rawTime = parent2.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
    };
    _proto.eventCallback = function eventCallback(type, callback, params) {
      var vars = this.vars;
      if (arguments.length > 1) {
        if (!callback) {
          delete vars[type];
        } else {
          vars[type] = callback;
          params && (vars[type + "Params"] = params);
          type === "onUpdate" && (this._onUpdate = callback);
        }
        return this;
      }
      return vars[type];
    };
    _proto.then = function then(onFulfilled) {
      var self2 = this;
      return new Promise(function(resolve) {
        var f3 = _isFunction(onFulfilled) ? onFulfilled : _passThrough, _resolve = function _resolve2() {
          var _then = self2.then;
          self2.then = null;
          _isFunction(f3) && (f3 = f3(self2)) && (f3.then || f3 === self2) && (self2.then = _then);
          resolve(f3);
          self2.then = _then;
        };
        if (self2._initted && self2.totalProgress() === 1 && self2._ts >= 0 || !self2._tTime && self2._ts < 0) {
          _resolve();
        } else {
          self2._prom = _resolve;
        }
      });
    };
    _proto.kill = function kill() {
      _interrupt(this);
    };
    return Animation2;
  }();
  _setDefaults(Animation.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: false,
    parent: null,
    _initted: false,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -_tinyNum,
    _prom: 0,
    _ps: false,
    _rts: 1
  });
  var Timeline = /* @__PURE__ */ function(_Animation) {
    _inheritsLoose(Timeline3, _Animation);
    function Timeline3(vars, position2) {
      var _this;
      if (vars === void 0) {
        vars = {};
      }
      _this = _Animation.call(this, vars) || this;
      _this.labels = {};
      _this.smoothChildTiming = !!vars.smoothChildTiming;
      _this.autoRemoveChildren = !!vars.autoRemoveChildren;
      _this._sort = _isNotFalse(vars.sortChildren);
      _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position2);
      vars.reversed && _this.reverse();
      vars.paused && _this.paused(true);
      vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
      return _this;
    }
    var _proto2 = Timeline3.prototype;
    _proto2.to = function to(targets, vars, position2) {
      _createTweenType(0, arguments, this);
      return this;
    };
    _proto2.from = function from(targets, vars, position2) {
      _createTweenType(1, arguments, this);
      return this;
    };
    _proto2.fromTo = function fromTo(targets, fromVars, toVars, position2) {
      _createTweenType(2, arguments, this);
      return this;
    };
    _proto2.set = function set(targets, vars, position2) {
      vars.duration = 0;
      vars.parent = this;
      _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
      vars.immediateRender = !!vars.immediateRender;
      new Tween(targets, vars, _parsePosition(this, position2), 1);
      return this;
    };
    _proto2.call = function call(callback, params, position2) {
      return _addToTimeline(this, Tween.delayedCall(0, callback, params), position2);
    };
    _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position2, onCompleteAll, onCompleteAllParams) {
      vars.duration = duration;
      vars.stagger = vars.stagger || stagger;
      vars.onComplete = onCompleteAll;
      vars.onCompleteParams = onCompleteAllParams;
      vars.parent = this;
      new Tween(targets, vars, _parsePosition(this, position2));
      return this;
    };
    _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position2, onCompleteAll, onCompleteAllParams) {
      vars.runBackwards = 1;
      _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
      return this.staggerTo(targets, duration, vars, stagger, position2, onCompleteAll, onCompleteAllParams);
    };
    _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position2, onCompleteAll, onCompleteAllParams) {
      toVars.startAt = fromVars;
      _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
      return this.staggerTo(targets, duration, toVars, stagger, position2, onCompleteAll, onCompleteAllParams);
    };
    _proto2.render = function render3(totalTime, suppressEvents, force) {
      var prevTime = this._time, tDur = this._dirty ? this.totalDuration() : this._tDur, dur = this._dur, tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime), crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur), time2, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;
      this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
      if (tTime !== this._tTime || force || crossingStart) {
        if (prevTime !== this._time && dur) {
          tTime += this._time - prevTime;
          totalTime += this._time - prevTime;
        }
        time2 = tTime;
        prevStart = this._start;
        timeScale = this._ts;
        prevPaused = !timeScale;
        if (crossingStart) {
          dur || (prevTime = this._zTime);
          (totalTime || !suppressEvents) && (this._zTime = totalTime);
        }
        if (this._repeat) {
          yoyo = this._yoyo;
          cycleDuration = dur + this._rDelay;
          if (this._repeat < -1 && totalTime < 0) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }
          time2 = _roundPrecise(tTime % cycleDuration);
          if (tTime === tDur) {
            iteration = this._repeat;
            time2 = dur;
          } else {
            iteration = ~~(tTime / cycleDuration);
            if (iteration && iteration === tTime / cycleDuration) {
              time2 = dur;
              iteration--;
            }
            time2 > dur && (time2 = dur);
          }
          prevIteration = _animationCycle(this._tTime, cycleDuration);
          !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration);
          if (yoyo && iteration & 1) {
            time2 = dur - time2;
            isYoyo = 1;
          }
          if (iteration !== prevIteration && !this._lock) {
            var rewinding = yoyo && prevIteration & 1, doesWrap = rewinding === (yoyo && iteration & 1);
            iteration < prevIteration && (rewinding = !rewinding);
            prevTime = rewinding ? 0 : tTime % dur ? dur : tTime;
            this._lock = 1;
            this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
            this._tTime = tTime;
            !suppressEvents && this.parent && _callback(this, "onRepeat");
            this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
            if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
              return this;
            }
            dur = this._dur;
            tDur = this._tDur;
            if (doesWrap) {
              this._lock = 2;
              prevTime = rewinding ? dur : -1e-4;
              this.render(prevTime, true);
              this.vars.repeatRefresh && !isYoyo && this.invalidate();
            }
            this._lock = 0;
            if (!this._ts && !prevPaused) {
              return this;
            }
            _propagateYoyoEase(this, isYoyo);
          }
        }
        if (this._hasPause && !this._forcing && this._lock < 2) {
          pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time2));
          if (pauseTween) {
            tTime -= time2 - (time2 = pauseTween._start);
          }
        }
        this._tTime = tTime;
        this._time = time2;
        this._act = !timeScale;
        if (!this._initted) {
          this._onUpdate = this.vars.onUpdate;
          this._initted = 1;
          this._zTime = totalTime;
          prevTime = 0;
        }
        if (!prevTime && time2 && !suppressEvents && !iteration) {
          _callback(this, "onStart");
          if (this._tTime !== tTime) {
            return this;
          }
        }
        if (time2 >= prevTime && totalTime >= 0) {
          child = this._first;
          while (child) {
            next = child._next;
            if ((child._act || time2 >= child._start) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                return this.render(totalTime, suppressEvents, force);
              }
              child.render(child._ts > 0 ? (time2 - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time2 - child._start) * child._ts, suppressEvents, force);
              if (time2 !== this._time || !this._ts && !prevPaused) {
                pauseTween = 0;
                next && (tTime += this._zTime = -_tinyNum);
                break;
              }
            }
            child = next;
          }
        } else {
          child = this._last;
          var adjustedTime = totalTime < 0 ? totalTime : time2;
          while (child) {
            next = child._prev;
            if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                return this.render(totalTime, suppressEvents, force);
              }
              child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && (child._initted || child._startAt));
              if (time2 !== this._time || !this._ts && !prevPaused) {
                pauseTween = 0;
                next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);
                break;
              }
            }
            child = next;
          }
        }
        if (pauseTween && !suppressEvents) {
          this.pause();
          pauseTween.render(time2 >= prevTime ? 0 : -_tinyNum)._zTime = time2 >= prevTime ? 1 : -1;
          if (this._ts) {
            this._start = prevStart;
            _setEnd(this);
            return this.render(totalTime, suppressEvents, force);
          }
        }
        this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
        if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) {
          if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) {
            if (!this._lock) {
              (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
              if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
                _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
                this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
              }
            }
          }
        }
      }
      return this;
    };
    _proto2.add = function add2(child, position2) {
      var _this2 = this;
      _isNumber(position2) || (position2 = _parsePosition(this, position2, child));
      if (!(child instanceof Animation)) {
        if (_isArray(child)) {
          child.forEach(function(obj) {
            return _this2.add(obj, position2);
          });
          return this;
        }
        if (_isString(child)) {
          return this.addLabel(child, position2);
        }
        if (_isFunction(child)) {
          child = Tween.delayedCall(0, child);
        } else {
          return this;
        }
      }
      return this !== child ? _addToTimeline(this, child, position2) : this;
    };
    _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
      if (nested === void 0) {
        nested = true;
      }
      if (tweens === void 0) {
        tweens = true;
      }
      if (timelines === void 0) {
        timelines = true;
      }
      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = -_bigNum;
      }
      var a5 = [], child = this._first;
      while (child) {
        if (child._start >= ignoreBeforeTime) {
          if (child instanceof Tween) {
            tweens && a5.push(child);
          } else {
            timelines && a5.push(child);
            nested && a5.push.apply(a5, child.getChildren(true, tweens, timelines));
          }
        }
        child = child._next;
      }
      return a5;
    };
    _proto2.getById = function getById2(id) {
      var animations = this.getChildren(1, 1, 1), i6 = animations.length;
      while (i6--) {
        if (animations[i6].vars.id === id) {
          return animations[i6];
        }
      }
    };
    _proto2.remove = function remove(child) {
      if (_isString(child)) {
        return this.removeLabel(child);
      }
      if (_isFunction(child)) {
        return this.killTweensOf(child);
      }
      _removeLinkedListItem(this, child);
      if (child === this._recent) {
        this._recent = this._last;
      }
      return _uncache(this);
    };
    _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
      if (!arguments.length) {
        return this._tTime;
      }
      this._forcing = 1;
      if (!this._dp && this._ts) {
        this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
      }
      _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
      this._forcing = 0;
      return this;
    };
    _proto2.addLabel = function addLabel(label, position2) {
      this.labels[label] = _parsePosition(this, position2);
      return this;
    };
    _proto2.removeLabel = function removeLabel(label) {
      delete this.labels[label];
      return this;
    };
    _proto2.addPause = function addPause(position2, callback, params) {
      var t4 = Tween.delayedCall(0, callback || _emptyFunc, params);
      t4.data = "isPause";
      this._hasPause = 1;
      return _addToTimeline(this, t4, _parsePosition(this, position2));
    };
    _proto2.removePause = function removePause(position2) {
      var child = this._first;
      position2 = _parsePosition(this, position2);
      while (child) {
        if (child._start === position2 && child.data === "isPause") {
          _removeFromParent(child);
        }
        child = child._next;
      }
    };
    _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      var tweens = this.getTweensOf(targets, onlyActive), i6 = tweens.length;
      while (i6--) {
        _overwritingTween !== tweens[i6] && tweens[i6].kill(targets, props);
      }
      return this;
    };
    _proto2.getTweensOf = function getTweensOf2(targets, onlyActive) {
      var a5 = [], parsedTargets = toArray(targets), child = this._first, isGlobalTime = _isNumber(onlyActive), children;
      while (child) {
        if (child instanceof Tween) {
          if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
            a5.push(child);
          }
        } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
          a5.push.apply(a5, children);
        }
        child = child._next;
      }
      return a5;
    };
    _proto2.tweenTo = function tweenTo(position2, vars) {
      vars = vars || {};
      var tl = this, endTime = _parsePosition(tl, position2), _vars = vars, startAt = _vars.startAt, _onStart = _vars.onStart, onStartParams = _vars.onStartParams, immediateRender = _vars.immediateRender, initted, tween = Tween.to(tl, _setDefaults({
        ease: vars.ease || "none",
        lazy: false,
        immediateRender: false,
        time: endTime,
        overwrite: "auto",
        duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
        onStart: function onStart() {
          tl.pause();
          if (!initted) {
            var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
            tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
            initted = 1;
          }
          _onStart && _onStart.apply(tween, onStartParams || []);
        }
      }, vars));
      return immediateRender ? tween.render(0) : tween;
    };
    _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
      return this.tweenTo(toPosition, _setDefaults({
        startAt: {
          time: _parsePosition(this, fromPosition)
        }
      }, vars));
    };
    _proto2.recent = function recent() {
      return this._recent;
    };
    _proto2.nextLabel = function nextLabel(afterTime) {
      if (afterTime === void 0) {
        afterTime = this._time;
      }
      return _getLabelInDirection(this, _parsePosition(this, afterTime));
    };
    _proto2.previousLabel = function previousLabel(beforeTime) {
      if (beforeTime === void 0) {
        beforeTime = this._time;
      }
      return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
    };
    _proto2.currentLabel = function currentLabel(value2) {
      return arguments.length ? this.seek(value2, true) : this.previousLabel(this._time + _tinyNum);
    };
    _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = 0;
      }
      var child = this._first, labels = this.labels, p3;
      while (child) {
        if (child._start >= ignoreBeforeTime) {
          child._start += amount;
          child._end += amount;
        }
        child = child._next;
      }
      if (adjustLabels) {
        for (p3 in labels) {
          if (labels[p3] >= ignoreBeforeTime) {
            labels[p3] += amount;
          }
        }
      }
      return _uncache(this);
    };
    _proto2.invalidate = function invalidate(soft) {
      var child = this._first;
      this._lock = 0;
      while (child) {
        child.invalidate(soft);
        child = child._next;
      }
      return _Animation.prototype.invalidate.call(this, soft);
    };
    _proto2.clear = function clear(includeLabels) {
      if (includeLabels === void 0) {
        includeLabels = true;
      }
      var child = this._first, next;
      while (child) {
        next = child._next;
        this.remove(child);
        child = next;
      }
      this._dp && (this._time = this._tTime = this._pTime = 0);
      includeLabels && (this.labels = {});
      return _uncache(this);
    };
    _proto2.totalDuration = function totalDuration(value2) {
      var max = 0, self2 = this, child = self2._last, prevStart = _bigNum, prev, start, parent2;
      if (arguments.length) {
        return self2.timeScale((self2._repeat < 0 ? self2.duration() : self2.totalDuration()) / (self2.reversed() ? -value2 : value2));
      }
      if (self2._dirty) {
        parent2 = self2.parent;
        while (child) {
          prev = child._prev;
          child._dirty && child.totalDuration();
          start = child._start;
          if (start > prevStart && self2._sort && child._ts && !self2._lock) {
            self2._lock = 1;
            _addToTimeline(self2, child, start - child._delay, 1)._lock = 0;
          } else {
            prevStart = start;
          }
          if (start < 0 && child._ts) {
            max -= start;
            if (!parent2 && !self2._dp || parent2 && parent2.smoothChildTiming) {
              self2._start += start / self2._ts;
              self2._time -= start;
              self2._tTime -= start;
            }
            self2.shiftChildren(-start, false, -Infinity);
            prevStart = 0;
          }
          child._end > max && child._ts && (max = child._end);
          child = prev;
        }
        _setDuration(self2, self2 === _globalTimeline && self2._time > max ? self2._time : max, 1, 1);
        self2._dirty = 0;
      }
      return self2._tDur;
    };
    Timeline3.updateRoot = function updateRoot(time2) {
      if (_globalTimeline._ts) {
        _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time2, _globalTimeline));
        _lastRenderedFrame = _ticker.frame;
      }
      if (_ticker.frame >= _nextGCFrame) {
        _nextGCFrame += _config.autoSleep || 120;
        var child = _globalTimeline._first;
        if (!child || !child._ts) {
          if (_config.autoSleep && _ticker._listeners.length < 2) {
            while (child && !child._ts) {
              child = child._next;
            }
            child || _ticker.sleep();
          }
        }
      }
    };
    return Timeline3;
  }(Animation);
  _setDefaults(Timeline.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
  });
  var _addComplexStringPropTween = function _addComplexStringPropTween2(target, prop, start, end, setter, stringFilter, funcParam) {
    var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter), index2 = 0, matchIndex = 0, result, startNums, color, endNum, chunk, startNum, hasRandom, a5;
    pt.b = start;
    pt.e = end;
    start += "";
    end += "";
    if (hasRandom = ~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }
    if (stringFilter) {
      a5 = [start, end];
      stringFilter(a5, target, prop);
      start = a5[0];
      end = a5[1];
    }
    startNums = start.match(_complexStringNumExp) || [];
    while (result = _complexStringNumExp.exec(end)) {
      endNum = result[0];
      chunk = end.substring(index2, result.index);
      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(") {
        color = 1;
      }
      if (endNum !== startNums[matchIndex++]) {
        startNum = parseFloat(startNums[matchIndex - 1]) || 0;
        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
          m: color && color < 4 ? Math.round : 0
        };
        index2 = _complexStringNumExp.lastIndex;
      }
    }
    pt.c = index2 < end.length ? end.substring(index2, end.length) : "";
    pt.fp = funcParam;
    if (_relExp.test(end) || hasRandom) {
      pt.e = 0;
    }
    this._pt = pt;
    return pt;
  };
  var _addPropTween = function _addPropTween2(target, prop, start, end, index2, targets, modifier, stringFilter, funcParam, optional) {
    _isFunction(end) && (end = end(index2 || 0, target, targets));
    var currentValue = target[prop], parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](), setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc, pt;
    if (_isString(end)) {
      if (~end.indexOf("random(")) {
        end = _replaceRandom(end);
      }
      if (end.charAt(1) === "=") {
        pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);
        if (pt || pt === 0) {
          end = pt;
        }
      }
    }
    if (!optional || parsedStart !== end || _forceAllPropTweens) {
      if (!isNaN(parsedStart * end) && end !== "") {
        pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
        funcParam && (pt.fp = funcParam);
        modifier && pt.modifier(modifier, this, target);
        return this._pt = pt;
      }
      !currentValue && !(prop in target) && _missingPlugin(prop, end);
      return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
    }
  };
  var _processVars = function _processVars2(vars, index2, target, targets, tween) {
    _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index2, target, targets));
    if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
      return _isString(vars) ? _parseFuncOrString(vars, tween, index2, target, targets) : vars;
    }
    var copy = {}, p3;
    for (p3 in vars) {
      copy[p3] = _parseFuncOrString(vars[p3], tween, index2, target, targets);
    }
    return copy;
  };
  var _checkPlugin = function _checkPlugin2(property2, vars, tween, index2, target, targets) {
    var plugin, pt, ptLookup, i6;
    if (_plugins[property2] && (plugin = new _plugins[property2]()).init(target, plugin.rawVars ? vars[property2] : _processVars(vars[property2], index2, target, targets, tween), tween, index2, targets) !== false) {
      tween._pt = pt = new PropTween(tween._pt, target, property2, 0, 1, plugin.render, plugin, 0, plugin.priority);
      if (tween !== _quickTween) {
        ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
        i6 = plugin._props.length;
        while (i6--) {
          ptLookup[plugin._props[i6]] = pt;
        }
      }
    }
    return plugin;
  };
  var _overwritingTween;
  var _forceAllPropTweens;
  var _initTween = function _initTween2(tween, time2, tTime) {
    var vars = tween.vars, ease2 = vars.ease, startAt = vars.startAt, immediateRender = vars.immediateRender, lazy = vars.lazy, onUpdate = vars.onUpdate, runBackwards = vars.runBackwards, yoyoEase = vars.yoyoEase, keyframes = vars.keyframes, autoRevert = vars.autoRevert, dur = tween._dur, prevStartAt = tween._startAt, targets = tween._targets, parent2 = tween.parent, fullTargets = parent2 && parent2.data === "nested" ? parent2.vars.targets : targets, autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites, tl = tween.timeline, cleanVars, i6, p3, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index2, harnessVars, overwritten;
    tl && (!keyframes || !ease2) && (ease2 = "none");
    tween._ease = _parseEase(ease2, _defaults.ease);
    tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease2 : yoyoEase, _defaults.ease)) : 0;
    if (yoyoEase && tween._yoyo && !tween._repeat) {
      yoyoEase = tween._yEase;
      tween._yEase = tween._ease;
      tween._ease = yoyoEase;
    }
    tween._from = !tl && !!vars.runBackwards;
    if (!tl || keyframes && !vars.stagger) {
      harness = targets[0] ? _getCache(targets[0]).harness : 0;
      harnessVars = harness && vars[harness.prop];
      cleanVars = _copyExcluding(vars, _reservedProps);
      if (prevStartAt) {
        prevStartAt._zTime < 0 && prevStartAt.progress(1);
        time2 < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig);
        prevStartAt._lazy = 0;
      }
      if (startAt) {
        _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
          data: "isStart",
          overwrite: false,
          parent: parent2,
          immediateRender: true,
          lazy: !prevStartAt && _isNotFalse(lazy),
          startAt: null,
          delay: 0,
          onUpdate: onUpdate && function() {
            return _callback(tween, "onUpdate");
          },
          stagger: 0
        }, startAt)));
        tween._startAt._dp = 0;
        tween._startAt._sat = tween;
        time2 < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill);
        if (immediateRender) {
          if (dur && time2 <= 0 && tTime <= 0) {
            time2 && (tween._zTime = time2);
            return;
          }
        }
      } else if (runBackwards && dur) {
        if (!prevStartAt) {
          time2 && (immediateRender = false);
          p3 = _setDefaults({
            overwrite: false,
            data: "isFromStart",
            //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
            lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
            immediateRender,
            //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
            stagger: 0,
            parent: parent2
            //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})
          }, cleanVars);
          harnessVars && (p3[harness.prop] = harnessVars);
          _removeFromParent(tween._startAt = Tween.set(targets, p3));
          tween._startAt._dp = 0;
          tween._startAt._sat = tween;
          time2 < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
          tween._zTime = time2;
          if (!immediateRender) {
            _initTween2(tween._startAt, _tinyNum, _tinyNum);
          } else if (!time2) {
            return;
          }
        }
      }
      tween._pt = tween._ptCache = 0;
      lazy = dur && _isNotFalse(lazy) || lazy && !dur;
      for (i6 = 0; i6 < targets.length; i6++) {
        target = targets[i6];
        gsData = target._gsap || _harness(targets)[i6]._gsap;
        tween._ptLookup[i6] = ptLookup = {};
        _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
        index2 = fullTargets === targets ? i6 : fullTargets.indexOf(target);
        if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index2, fullTargets) !== false) {
          tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
          plugin._props.forEach(function(name2) {
            ptLookup[name2] = pt;
          });
          plugin.priority && (hasPriority = 1);
        }
        if (!harness || harnessVars) {
          for (p3 in cleanVars) {
            if (_plugins[p3] && (plugin = _checkPlugin(p3, cleanVars, tween, index2, target, fullTargets))) {
              plugin.priority && (hasPriority = 1);
            } else {
              ptLookup[p3] = pt = _addPropTween.call(tween, target, p3, "get", cleanVars[p3], index2, fullTargets, 0, vars.stringFilter);
            }
          }
        }
        tween._op && tween._op[i6] && tween.kill(target, tween._op[i6]);
        if (autoOverwrite && tween._pt) {
          _overwritingTween = tween;
          _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time2));
          overwritten = !tween.parent;
          _overwritingTween = 0;
        }
        tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
      }
      hasPriority && _sortPropTweensByPriority(tween);
      tween._onInit && tween._onInit(tween);
    }
    tween._onUpdate = onUpdate;
    tween._initted = (!tween._op || tween._pt) && !overwritten;
    keyframes && time2 <= 0 && tl.render(_bigNum, true, true);
  };
  var _updatePropTweens = function _updatePropTweens2(tween, property2, value2, start, startIsRelative, ratio, time2, skipRecursion) {
    var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property2], pt, rootPT, lookup, i6;
    if (!ptCache) {
      ptCache = tween._ptCache[property2] = [];
      lookup = tween._ptLookup;
      i6 = tween._targets.length;
      while (i6--) {
        pt = lookup[i6][property2];
        if (pt && pt.d && pt.d._pt) {
          pt = pt.d._pt;
          while (pt && pt.p !== property2 && pt.fp !== property2) {
            pt = pt._next;
          }
        }
        if (!pt) {
          _forceAllPropTweens = 1;
          tween.vars[property2] = "+=0";
          _initTween(tween, time2);
          _forceAllPropTweens = 0;
          return skipRecursion ? _warn(property2 + " not eligible for reset") : 1;
        }
        ptCache.push(pt);
      }
    }
    i6 = ptCache.length;
    while (i6--) {
      rootPT = ptCache[i6];
      pt = rootPT._pt || rootPT;
      pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
      pt.c = value2 - pt.s;
      rootPT.e && (rootPT.e = _round(value2) + getUnit(rootPT.e));
      rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b));
    }
  };
  var _addAliasesToVars = function _addAliasesToVars2(targets, vars) {
    var harness = targets[0] ? _getCache(targets[0]).harness : 0, propertyAliases = harness && harness.aliases, copy, p3, i6, aliases;
    if (!propertyAliases) {
      return vars;
    }
    copy = _merge({}, vars);
    for (p3 in propertyAliases) {
      if (p3 in copy) {
        aliases = propertyAliases[p3].split(",");
        i6 = aliases.length;
        while (i6--) {
          copy[aliases[i6]] = copy[p3];
        }
      }
    }
    return copy;
  };
  var _parseKeyframe = function _parseKeyframe2(prop, obj, allProps, easeEach) {
    var ease2 = obj.ease || easeEach || "power1.inOut", p3, a5;
    if (_isArray(obj)) {
      a5 = allProps[prop] || (allProps[prop] = []);
      obj.forEach(function(value2, i6) {
        return a5.push({
          t: i6 / (obj.length - 1) * 100,
          v: value2,
          e: ease2
        });
      });
    } else {
      for (p3 in obj) {
        a5 = allProps[p3] || (allProps[p3] = []);
        p3 === "ease" || a5.push({
          t: parseFloat(prop),
          v: obj[p3],
          e: ease2
        });
      }
    }
  };
  var _parseFuncOrString = function _parseFuncOrString2(value2, tween, i6, target, targets) {
    return _isFunction(value2) ? value2.call(tween, i6, target, targets) : _isString(value2) && ~value2.indexOf("random(") ? _replaceRandom(value2) : value2;
  };
  var _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert";
  var _staggerPropsToSkip = {};
  _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function(name2) {
    return _staggerPropsToSkip[name2] = 1;
  });
  var Tween = /* @__PURE__ */ function(_Animation2) {
    _inheritsLoose(Tween2, _Animation2);
    function Tween2(targets, vars, position2, skipInherit) {
      var _this3;
      if (typeof vars === "number") {
        position2.duration = vars;
        vars = position2;
        position2 = null;
      }
      _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
      var _this3$vars = _this3.vars, duration = _this3$vars.duration, delay3 = _this3$vars.delay, immediateRender = _this3$vars.immediateRender, stagger = _this3$vars.stagger, overwrite = _this3$vars.overwrite, keyframes = _this3$vars.keyframes, defaults3 = _this3$vars.defaults, scrollTrigger = _this3$vars.scrollTrigger, yoyoEase = _this3$vars.yoyoEase, parent2 = vars.parent || _globalTimeline, parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets), tl, i6, copy, l6, p3, curTarget, staggerFunc, staggerVarsToMerge;
      _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://gsap.com", !_config.nullTargetWarn) || [];
      _this3._ptLookup = [];
      _this3._overwrite = overwrite;
      if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay3)) {
        vars = _this3.vars;
        tl = _this3.timeline = new Timeline({
          data: "nested",
          defaults: defaults3 || {},
          targets: parent2 && parent2.data === "nested" ? parent2.vars.targets : parsedTargets
        });
        tl.kill();
        tl.parent = tl._dp = _assertThisInitialized(_this3);
        tl._start = 0;
        if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay3)) {
          l6 = parsedTargets.length;
          staggerFunc = stagger && distribute(stagger);
          if (_isObject(stagger)) {
            for (p3 in stagger) {
              if (~_staggerTweenProps.indexOf(p3)) {
                staggerVarsToMerge || (staggerVarsToMerge = {});
                staggerVarsToMerge[p3] = stagger[p3];
              }
            }
          }
          for (i6 = 0; i6 < l6; i6++) {
            copy = _copyExcluding(vars, _staggerPropsToSkip);
            copy.stagger = 0;
            yoyoEase && (copy.yoyoEase = yoyoEase);
            staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
            curTarget = parsedTargets[i6];
            copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i6, curTarget, parsedTargets);
            copy.delay = (+_parseFuncOrString(delay3, _assertThisInitialized(_this3), i6, curTarget, parsedTargets) || 0) - _this3._delay;
            if (!stagger && l6 === 1 && copy.delay) {
              _this3._delay = delay3 = copy.delay;
              _this3._start += delay3;
              copy.delay = 0;
            }
            tl.to(curTarget, copy, staggerFunc ? staggerFunc(i6, curTarget, parsedTargets) : 0);
            tl._ease = _easeMap.none;
          }
          tl.duration() ? duration = delay3 = 0 : _this3.timeline = 0;
        } else if (keyframes) {
          _inheritDefaults(_setDefaults(tl.vars.defaults, {
            ease: "none"
          }));
          tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
          var time2 = 0, a5, kf, v2;
          if (_isArray(keyframes)) {
            keyframes.forEach(function(frame) {
              return tl.to(parsedTargets, frame, ">");
            });
            tl.duration();
          } else {
            copy = {};
            for (p3 in keyframes) {
              p3 === "ease" || p3 === "easeEach" || _parseKeyframe(p3, keyframes[p3], copy, keyframes.easeEach);
            }
            for (p3 in copy) {
              a5 = copy[p3].sort(function(a6, b3) {
                return a6.t - b3.t;
              });
              time2 = 0;
              for (i6 = 0; i6 < a5.length; i6++) {
                kf = a5[i6];
                v2 = {
                  ease: kf.e,
                  duration: (kf.t - (i6 ? a5[i6 - 1].t : 0)) / 100 * duration
                };
                v2[p3] = kf.v;
                tl.to(parsedTargets, v2, time2);
                time2 += v2.duration;
              }
            }
            tl.duration() < duration && tl.to({}, {
              duration: duration - tl.duration()
            });
          }
        }
        duration || _this3.duration(duration = tl.duration());
      } else {
        _this3.timeline = 0;
      }
      if (overwrite === true && !_suppressOverwrites) {
        _overwritingTween = _assertThisInitialized(_this3);
        _globalTimeline.killTweensOf(parsedTargets);
        _overwritingTween = 0;
      }
      _addToTimeline(parent2, _assertThisInitialized(_this3), position2);
      vars.reversed && _this3.reverse();
      vars.paused && _this3.paused(true);
      if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent2._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent2.data !== "nested") {
        _this3._tTime = -_tinyNum;
        _this3.render(Math.max(0, -delay3) || 0);
      }
      scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
      return _this3;
    }
    var _proto3 = Tween2.prototype;
    _proto3.render = function render3(totalTime, suppressEvents, force) {
      var prevTime = this._time, tDur = this._tDur, dur = this._dur, isNegative = totalTime < 0, tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime, time2, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline2, yoyoEase;
      if (!dur) {
        _renderZeroDurationTween(this, totalTime, suppressEvents, force);
      } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {
        time2 = tTime;
        timeline2 = this.timeline;
        if (this._repeat) {
          cycleDuration = dur + this._rDelay;
          if (this._repeat < -1 && isNegative) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }
          time2 = _roundPrecise(tTime % cycleDuration);
          if (tTime === tDur) {
            iteration = this._repeat;
            time2 = dur;
          } else {
            iteration = ~~(tTime / cycleDuration);
            if (iteration && iteration === _roundPrecise(tTime / cycleDuration)) {
              time2 = dur;
              iteration--;
            }
            time2 > dur && (time2 = dur);
          }
          isYoyo = this._yoyo && iteration & 1;
          if (isYoyo) {
            yoyoEase = this._yEase;
            time2 = dur - time2;
          }
          prevIteration = _animationCycle(this._tTime, cycleDuration);
          if (time2 === prevTime && !force && this._initted && iteration === prevIteration) {
            this._tTime = tTime;
            return this;
          }
          if (iteration !== prevIteration) {
            timeline2 && this._yEase && _propagateYoyoEase(timeline2, isYoyo);
            if (this.vars.repeatRefresh && !isYoyo && !this._lock && this._time !== cycleDuration && this._initted) {
              this._lock = force = 1;
              this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
            }
          }
        }
        if (!this._initted) {
          if (_attemptInitTween(this, isNegative ? totalTime : time2, force, suppressEvents, tTime)) {
            this._tTime = 0;
            return this;
          }
          if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {
            return this;
          }
          if (dur !== this._dur) {
            return this.render(totalTime, suppressEvents, force);
          }
        }
        this._tTime = tTime;
        this._time = time2;
        if (!this._act && this._ts) {
          this._act = 1;
          this._lazy = 0;
        }
        this.ratio = ratio = (yoyoEase || this._ease)(time2 / dur);
        if (this._from) {
          this.ratio = ratio = 1 - ratio;
        }
        if (time2 && !prevTime && !suppressEvents && !iteration) {
          _callback(this, "onStart");
          if (this._tTime !== tTime) {
            return this;
          }
        }
        pt = this._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
        timeline2 && timeline2.render(totalTime < 0 ? totalTime : timeline2._dur * timeline2._ease(time2 / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);
        if (this._onUpdate && !suppressEvents) {
          isNegative && _rewindStartAt(this, totalTime, suppressEvents, force);
          _callback(this, "onUpdate");
        }
        this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
        if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
          isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
          (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
          if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
            _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
          }
        }
      }
      return this;
    };
    _proto3.targets = function targets() {
      return this._targets;
    };
    _proto3.invalidate = function invalidate(soft) {
      (!soft || !this.vars.runBackwards) && (this._startAt = 0);
      this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
      this._ptLookup = [];
      this.timeline && this.timeline.invalidate(soft);
      return _Animation2.prototype.invalidate.call(this, soft);
    };
    _proto3.resetTo = function resetTo(property2, value2, start, startIsRelative, skipRecursion) {
      _tickerActive || _ticker.wake();
      this._ts || this.play();
      var time2 = Math.min(this._dur, (this._dp._time - this._start) * this._ts), ratio;
      this._initted || _initTween(this, time2);
      ratio = this._ease(time2 / this._dur);
      if (_updatePropTweens(this, property2, value2, start, startIsRelative, ratio, time2, skipRecursion)) {
        return this.resetTo(property2, value2, start, startIsRelative, 1);
      }
      _alignPlayhead(this, 0);
      this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
      return this.render(0);
    };
    _proto3.kill = function kill(targets, vars) {
      if (vars === void 0) {
        vars = "all";
      }
      if (!targets && (!vars || vars === "all")) {
        this._lazy = this._pt = 0;
        return this.parent ? _interrupt(this) : this;
      }
      if (this.timeline) {
        var tDur = this.timeline.totalDuration();
        this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);
        this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);
        return this;
      }
      var parsedTargets = this._targets, killingTargets = targets ? toArray(targets) : parsedTargets, propTweenLookup = this._ptLookup, firstPT = this._pt, overwrittenProps, curLookup, curOverwriteProps, props, p3, pt, i6;
      if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
        vars === "all" && (this._pt = 0);
        return _interrupt(this);
      }
      overwrittenProps = this._op = this._op || [];
      if (vars !== "all") {
        if (_isString(vars)) {
          p3 = {};
          _forEachName(vars, function(name2) {
            return p3[name2] = 1;
          });
          vars = p3;
        }
        vars = _addAliasesToVars(parsedTargets, vars);
      }
      i6 = parsedTargets.length;
      while (i6--) {
        if (~killingTargets.indexOf(parsedTargets[i6])) {
          curLookup = propTweenLookup[i6];
          if (vars === "all") {
            overwrittenProps[i6] = vars;
            props = curLookup;
            curOverwriteProps = {};
          } else {
            curOverwriteProps = overwrittenProps[i6] = overwrittenProps[i6] || {};
            props = vars;
          }
          for (p3 in props) {
            pt = curLookup && curLookup[p3];
            if (pt) {
              if (!("kill" in pt.d) || pt.d.kill(p3) === true) {
                _removeLinkedListItem(this, pt, "_pt");
              }
              delete curLookup[p3];
            }
            if (curOverwriteProps !== "all") {
              curOverwriteProps[p3] = 1;
            }
          }
        }
      }
      this._initted && !this._pt && firstPT && _interrupt(this);
      return this;
    };
    Tween2.to = function to(targets, vars) {
      return new Tween2(targets, vars, arguments[2]);
    };
    Tween2.from = function from(targets, vars) {
      return _createTweenType(1, arguments);
    };
    Tween2.delayedCall = function delayedCall(delay3, callback, params, scope) {
      return new Tween2(callback, 0, {
        immediateRender: false,
        lazy: false,
        overwrite: false,
        delay: delay3,
        onComplete: callback,
        onReverseComplete: callback,
        onCompleteParams: params,
        onReverseCompleteParams: params,
        callbackScope: scope
      });
    };
    Tween2.fromTo = function fromTo(targets, fromVars, toVars) {
      return _createTweenType(2, arguments);
    };
    Tween2.set = function set(targets, vars) {
      vars.duration = 0;
      vars.repeatDelay || (vars.repeat = 0);
      return new Tween2(targets, vars);
    };
    Tween2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      return _globalTimeline.killTweensOf(targets, props, onlyActive);
    };
    return Tween2;
  }(Animation);
  _setDefaults(Tween.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
  });
  _forEachName("staggerTo,staggerFrom,staggerFromTo", function(name2) {
    Tween[name2] = function() {
      var tl = new Timeline(), params = _slice.call(arguments, 0);
      params.splice(name2 === "staggerFromTo" ? 5 : 4, 0, 0);
      return tl[name2].apply(tl, params);
    };
  });
  var _setterPlain = function _setterPlain2(target, property2, value2) {
    return target[property2] = value2;
  };
  var _setterFunc = function _setterFunc2(target, property2, value2) {
    return target[property2](value2);
  };
  var _setterFuncWithParam = function _setterFuncWithParam2(target, property2, value2, data2) {
    return target[property2](data2.fp, value2);
  };
  var _setterAttribute = function _setterAttribute2(target, property2, value2) {
    return target.setAttribute(property2, value2);
  };
  var _getSetter = function _getSetter2(target, property2) {
    return _isFunction(target[property2]) ? _setterFunc : _isUndefined(target[property2]) && target.setAttribute ? _setterAttribute : _setterPlain;
  };
  var _renderPlain = function _renderPlain2(ratio, data2) {
    return data2.set(data2.t, data2.p, Math.round((data2.s + data2.c * ratio) * 1e6) / 1e6, data2);
  };
  var _renderBoolean = function _renderBoolean2(ratio, data2) {
    return data2.set(data2.t, data2.p, !!(data2.s + data2.c * ratio), data2);
  };
  var _renderComplexString = function _renderComplexString2(ratio, data2) {
    var pt = data2._pt, s4 = "";
    if (!ratio && data2.b) {
      s4 = data2.b;
    } else if (ratio === 1 && data2.e) {
      s4 = data2.e;
    } else {
      while (pt) {
        s4 = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 1e4) / 1e4) + s4;
        pt = pt._next;
      }
      s4 += data2.c;
    }
    data2.set(data2.t, data2.p, s4, data2);
  };
  var _renderPropTweens = function _renderPropTweens2(ratio, data2) {
    var pt = data2._pt;
    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }
  };
  var _addPluginModifier = function _addPluginModifier2(modifier, tween, target, property2) {
    var pt = this._pt, next;
    while (pt) {
      next = pt._next;
      pt.p === property2 && pt.modifier(modifier, tween, target);
      pt = next;
    }
  };
  var _killPropTweensOf = function _killPropTweensOf2(property2) {
    var pt = this._pt, hasNonDependentRemaining, next;
    while (pt) {
      next = pt._next;
      if (pt.p === property2 && !pt.op || pt.op === property2) {
        _removeLinkedListItem(this, pt, "_pt");
      } else if (!pt.dep) {
        hasNonDependentRemaining = 1;
      }
      pt = next;
    }
    return !hasNonDependentRemaining;
  };
  var _setterWithModifier = function _setterWithModifier2(target, property2, value2, data2) {
    data2.mSet(target, property2, data2.m.call(data2.tween, value2, data2.mt), data2);
  };
  var _sortPropTweensByPriority = function _sortPropTweensByPriority2(parent2) {
    var pt = parent2._pt, next, pt2, first, last;
    while (pt) {
      next = pt._next;
      pt2 = first;
      while (pt2 && pt2.pr > pt.pr) {
        pt2 = pt2._next;
      }
      if (pt._prev = pt2 ? pt2._prev : last) {
        pt._prev._next = pt;
      } else {
        first = pt;
      }
      if (pt._next = pt2) {
        pt2._prev = pt;
      } else {
        last = pt;
      }
      pt = next;
    }
    parent2._pt = first;
  };
  var PropTween = /* @__PURE__ */ function() {
    function PropTween2(next, target, prop, start, change, renderer2, data2, setter, priority) {
      this.t = target;
      this.s = start;
      this.c = change;
      this.p = prop;
      this.r = renderer2 || _renderPlain;
      this.d = data2 || this;
      this.set = setter || _setterPlain;
      this.pr = priority || 0;
      this._next = next;
      if (next) {
        next._prev = this;
      }
    }
    var _proto4 = PropTween2.prototype;
    _proto4.modifier = function modifier(func, tween, target) {
      this.mSet = this.mSet || this.set;
      this.set = _setterWithModifier;
      this.m = func;
      this.mt = target;
      this.tween = tween;
    };
    return PropTween2;
  }();
  _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(name2) {
    return _reservedProps[name2] = 1;
  });
  _globals.TweenMax = _globals.TweenLite = Tween;
  _globals.TimelineLite = _globals.TimelineMax = Timeline;
  _globalTimeline = new Timeline({
    sortChildren: false,
    defaults: _defaults,
    autoRemoveChildren: true,
    id: "root",
    smoothChildTiming: true
  });
  _config.stringFilter = _colorStringFilter;
  var _media = [];
  var _listeners = {};
  var _emptyArray = [];
  var _lastMediaTime = 0;
  var _contextID = 0;
  var _dispatch = function _dispatch2(type) {
    return (_listeners[type] || _emptyArray).map(function(f3) {
      return f3();
    });
  };
  var _onMediaChange = function _onMediaChange2() {
    var time2 = Date.now(), matches2 = [];
    if (time2 - _lastMediaTime > 2) {
      _dispatch("matchMediaInit");
      _media.forEach(function(c4) {
        var queries = c4.queries, conditions = c4.conditions, match, p3, anyMatch, toggled;
        for (p3 in queries) {
          match = _win.matchMedia(queries[p3]).matches;
          match && (anyMatch = 1);
          if (match !== conditions[p3]) {
            conditions[p3] = match;
            toggled = 1;
          }
        }
        if (toggled) {
          c4.revert();
          anyMatch && matches2.push(c4);
        }
      });
      _dispatch("matchMediaRevert");
      matches2.forEach(function(c4) {
        return c4.onMatch(c4, function(func) {
          return c4.add(null, func);
        });
      });
      _lastMediaTime = time2;
      _dispatch("matchMedia");
    }
  };
  var Context = /* @__PURE__ */ function() {
    function Context2(func, scope) {
      this.selector = scope && selector(scope);
      this.data = [];
      this._r = [];
      this.isReverted = false;
      this.id = _contextID++;
      func && this.add(func);
    }
    var _proto5 = Context2.prototype;
    _proto5.add = function add2(name2, func, scope) {
      if (_isFunction(name2)) {
        scope = func;
        func = name2;
        name2 = _isFunction;
      }
      var self2 = this, f3 = function f4() {
        var prev = _context, prevSelector = self2.selector, result;
        prev && prev !== self2 && prev.data.push(self2);
        scope && (self2.selector = selector(scope));
        _context = self2;
        result = func.apply(self2, arguments);
        _isFunction(result) && self2._r.push(result);
        _context = prev;
        self2.selector = prevSelector;
        self2.isReverted = false;
        return result;
      };
      self2.last = f3;
      return name2 === _isFunction ? f3(self2, function(func2) {
        return self2.add(null, func2);
      }) : name2 ? self2[name2] = f3 : f3;
    };
    _proto5.ignore = function ignore(func) {
      var prev = _context;
      _context = null;
      func(this);
      _context = prev;
    };
    _proto5.getTweens = function getTweens() {
      var a5 = [];
      this.data.forEach(function(e5) {
        return e5 instanceof Context2 ? a5.push.apply(a5, e5.getTweens()) : e5 instanceof Tween && !(e5.parent && e5.parent.data === "nested") && a5.push(e5);
      });
      return a5;
    };
    _proto5.clear = function clear() {
      this._r.length = this.data.length = 0;
    };
    _proto5.kill = function kill(revert, matchMedia3) {
      var _this4 = this;
      if (revert) {
        (function() {
          var tweens = _this4.getTweens(), i7 = _this4.data.length, t4;
          while (i7--) {
            t4 = _this4.data[i7];
            if (t4.data === "isFlip") {
              t4.revert();
              t4.getChildren(true, true, false).forEach(function(tween) {
                return tweens.splice(tweens.indexOf(tween), 1);
              });
            }
          }
          tweens.map(function(t5) {
            return {
              g: t5._dur || t5._delay || t5._sat && !t5._sat.vars.immediateRender ? t5.globalTime(0) : -Infinity,
              t: t5
            };
          }).sort(function(a5, b3) {
            return b3.g - a5.g || -Infinity;
          }).forEach(function(o5) {
            return o5.t.revert(revert);
          });
          i7 = _this4.data.length;
          while (i7--) {
            t4 = _this4.data[i7];
            if (t4 instanceof Timeline) {
              if (t4.data !== "nested") {
                t4.scrollTrigger && t4.scrollTrigger.revert();
                t4.kill();
              }
            } else {
              !(t4 instanceof Tween) && t4.revert && t4.revert(revert);
            }
          }
          _this4._r.forEach(function(f3) {
            return f3(revert, _this4);
          });
          _this4.isReverted = true;
        })();
      } else {
        this.data.forEach(function(e5) {
          return e5.kill && e5.kill();
        });
      }
      this.clear();
      if (matchMedia3) {
        var i6 = _media.length;
        while (i6--) {
          _media[i6].id === this.id && _media.splice(i6, 1);
        }
      }
    };
    _proto5.revert = function revert(config3) {
      this.kill(config3 || {});
    };
    return Context2;
  }();
  var MatchMedia = /* @__PURE__ */ function() {
    function MatchMedia2(scope) {
      this.contexts = [];
      this.scope = scope;
      _context && _context.data.push(this);
    }
    var _proto6 = MatchMedia2.prototype;
    _proto6.add = function add2(conditions, func, scope) {
      _isObject(conditions) || (conditions = {
        matches: conditions
      });
      var context3 = new Context(0, scope || this.scope), cond = context3.conditions = {}, mq, p3, active2;
      _context && !context3.selector && (context3.selector = _context.selector);
      this.contexts.push(context3);
      func = context3.add("onMatch", func);
      context3.queries = conditions;
      for (p3 in conditions) {
        if (p3 === "all") {
          active2 = 1;
        } else {
          mq = _win.matchMedia(conditions[p3]);
          if (mq) {
            _media.indexOf(context3) < 0 && _media.push(context3);
            (cond[p3] = mq.matches) && (active2 = 1);
            mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
          }
        }
      }
      active2 && func(context3, function(f3) {
        return context3.add(null, f3);
      });
      return this;
    };
    _proto6.revert = function revert(config3) {
      this.kill(config3 || {});
    };
    _proto6.kill = function kill(revert) {
      this.contexts.forEach(function(c4) {
        return c4.kill(revert, true);
      });
    };
    return MatchMedia2;
  }();
  var _gsap = {
    registerPlugin: function registerPlugin() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      args.forEach(function(config3) {
        return _createPlugin(config3);
      });
    },
    timeline: function timeline(vars) {
      return new Timeline(vars);
    },
    getTweensOf: function getTweensOf(targets, onlyActive) {
      return _globalTimeline.getTweensOf(targets, onlyActive);
    },
    getProperty: function getProperty(target, property2, unit, uncache) {
      _isString(target) && (target = toArray(target)[0]);
      var getter = _getCache(target || {}).get, format = unit ? _passThrough : _numericIfPossible;
      unit === "native" && (unit = "");
      return !target ? target : !property2 ? function(property3, unit2, uncache2) {
        return format((_plugins[property3] && _plugins[property3].get || getter)(target, property3, unit2, uncache2));
      } : format((_plugins[property2] && _plugins[property2].get || getter)(target, property2, unit, uncache));
    },
    quickSetter: function quickSetter(target, property2, unit) {
      target = toArray(target);
      if (target.length > 1) {
        var setters = target.map(function(t4) {
          return gsap.quickSetter(t4, property2, unit);
        }), l6 = setters.length;
        return function(value2) {
          var i6 = l6;
          while (i6--) {
            setters[i6](value2);
          }
        };
      }
      target = target[0] || {};
      var Plugin = _plugins[property2], cache = _getCache(target), p3 = cache.harness && (cache.harness.aliases || {})[property2] || property2, setter = Plugin ? function(value2) {
        var p4 = new Plugin();
        _quickTween._pt = 0;
        p4.init(target, unit ? value2 + unit : value2, _quickTween, 0, [target]);
        p4.render(1, p4);
        _quickTween._pt && _renderPropTweens(1, _quickTween);
      } : cache.set(target, p3);
      return Plugin ? setter : function(value2) {
        return setter(target, p3, unit ? value2 + unit : value2, cache, 1);
      };
    },
    quickTo: function quickTo(target, property2, vars) {
      var _merge22;
      var tween = gsap.to(target, _merge((_merge22 = {}, _merge22[property2] = "+=0.1", _merge22.paused = true, _merge22), vars || {})), func = function func2(value2, start, startIsRelative) {
        return tween.resetTo(property2, value2, start, startIsRelative);
      };
      func.tween = tween;
      return func;
    },
    isTweening: function isTweening(targets) {
      return _globalTimeline.getTweensOf(targets, true).length > 0;
    },
    defaults: function defaults(value2) {
      value2 && value2.ease && (value2.ease = _parseEase(value2.ease, _defaults.ease));
      return _mergeDeep(_defaults, value2 || {});
    },
    config: function config2(value2) {
      return _mergeDeep(_config, value2 || {});
    },
    registerEffect: function registerEffect2(_ref3) {
      var name2 = _ref3.name, effect2 = _ref3.effect, plugins = _ref3.plugins, defaults3 = _ref3.defaults, extendTimeline = _ref3.extendTimeline;
      (plugins || "").split(",").forEach(function(pluginName) {
        return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name2 + " effect requires " + pluginName + " plugin.");
      });
      _effects[name2] = function(targets, vars, tl) {
        return effect2(toArray(targets), _setDefaults(vars || {}, defaults3), tl);
      };
      if (extendTimeline) {
        Timeline.prototype[name2] = function(targets, vars, position2) {
          return this.add(_effects[name2](targets, _isObject(vars) ? vars : (position2 = vars) && {}, this), position2);
        };
      }
    },
    registerEase: function registerEase(name2, ease2) {
      _easeMap[name2] = _parseEase(ease2);
    },
    parseEase: function parseEase(ease2, defaultEase) {
      return arguments.length ? _parseEase(ease2, defaultEase) : _easeMap;
    },
    getById: function getById(id) {
      return _globalTimeline.getById(id);
    },
    exportRoot: function exportRoot(vars, includeDelayedCalls) {
      if (vars === void 0) {
        vars = {};
      }
      var tl = new Timeline(vars), child, next;
      tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
      _globalTimeline.remove(tl);
      tl._dp = 0;
      tl._time = tl._tTime = _globalTimeline._time;
      child = _globalTimeline._first;
      while (child) {
        next = child._next;
        if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
          _addToTimeline(tl, child, child._start - child._delay);
        }
        child = next;
      }
      _addToTimeline(_globalTimeline, tl, 0);
      return tl;
    },
    context: function context(func, scope) {
      return func ? new Context(func, scope) : _context;
    },
    matchMedia: function matchMedia2(scope) {
      return new MatchMedia(scope);
    },
    matchMediaRefresh: function matchMediaRefresh() {
      return _media.forEach(function(c4) {
        var cond = c4.conditions, found, p3;
        for (p3 in cond) {
          if (cond[p3]) {
            cond[p3] = false;
            found = 1;
          }
        }
        found && c4.revert();
      }) || _onMediaChange();
    },
    addEventListener: function addEventListener(type, callback) {
      var a5 = _listeners[type] || (_listeners[type] = []);
      ~a5.indexOf(callback) || a5.push(callback);
    },
    removeEventListener: function removeEventListener(type, callback) {
      var a5 = _listeners[type], i6 = a5 && a5.indexOf(callback);
      i6 >= 0 && a5.splice(i6, 1);
    },
    utils: {
      wrap,
      wrapYoyo,
      distribute,
      random: random2,
      snap,
      normalize: normalize2,
      getUnit,
      clamp: clamp2,
      splitColor,
      toArray,
      selector,
      mapRange,
      pipe,
      unitize,
      interpolate,
      shuffle
    },
    install: _install,
    effects: _effects,
    ticker: _ticker,
    updateRoot: Timeline.updateRoot,
    plugins: _plugins,
    globalTimeline: _globalTimeline,
    core: {
      PropTween,
      globals: _addGlobal,
      Tween,
      Timeline,
      Animation,
      getCache: _getCache,
      _removeLinkedListItem,
      reverting: function reverting() {
        return _reverting;
      },
      context: function context2(toAdd) {
        if (toAdd && _context) {
          _context.data.push(toAdd);
          toAdd._ctx = _context;
        }
        return _context;
      },
      suppressOverwrites: function suppressOverwrites(value2) {
        return _suppressOverwrites = value2;
      }
    }
  };
  _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(name2) {
    return _gsap[name2] = Tween[name2];
  });
  _ticker.add(Timeline.updateRoot);
  _quickTween = _gsap.to({}, {
    duration: 0
  });
  var _getPluginPropTween = function _getPluginPropTween2(plugin, prop) {
    var pt = plugin._pt;
    while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
      pt = pt._next;
    }
    return pt;
  };
  var _addModifiers = function _addModifiers2(tween, modifiers) {
    var targets = tween._targets, p3, i6, pt;
    for (p3 in modifiers) {
      i6 = targets.length;
      while (i6--) {
        pt = tween._ptLookup[i6][p3];
        if (pt && (pt = pt.d)) {
          if (pt._pt) {
            pt = _getPluginPropTween(pt, p3);
          }
          pt && pt.modifier && pt.modifier(modifiers[p3], tween, targets[i6], p3);
        }
      }
    }
  };
  var _buildModifierPlugin = function _buildModifierPlugin2(name2, modifier) {
    return {
      name: name2,
      rawVars: 1,
      //don't pre-process function-based values or "random()" strings.
      init: function init5(target, vars, tween) {
        tween._onInit = function(tween2) {
          var temp, p3;
          if (_isString(vars)) {
            temp = {};
            _forEachName(vars, function(name3) {
              return temp[name3] = 1;
            });
            vars = temp;
          }
          if (modifier) {
            temp = {};
            for (p3 in vars) {
              temp[p3] = modifier(vars[p3]);
            }
            vars = temp;
          }
          _addModifiers(tween2, vars);
        };
      }
    };
  };
  var gsap = _gsap.registerPlugin({
    name: "attr",
    init: function init(target, vars, tween, index2, targets) {
      var p3, pt, v2;
      this.tween = tween;
      for (p3 in vars) {
        v2 = target.getAttribute(p3) || "";
        pt = this.add(target, "setAttribute", (v2 || 0) + "", vars[p3], index2, targets, 0, 0, p3);
        pt.op = p3;
        pt.b = v2;
        this._props.push(p3);
      }
    },
    render: function render(ratio, data2) {
      var pt = data2._pt;
      while (pt) {
        _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d);
        pt = pt._next;
      }
    }
  }, {
    name: "endArray",
    init: function init2(target, value2) {
      var i6 = value2.length;
      while (i6--) {
        this.add(target, i6, target[i6] || 0, value2[i6], 0, 0, 0, 0, 0, 1);
      }
    }
  }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
  Tween.version = Timeline.version = gsap.version = "3.12.5";
  _coreReady = 1;
  _windowExists() && _wake();
  var Power0 = _easeMap.Power0;
  var Power1 = _easeMap.Power1;
  var Power2 = _easeMap.Power2;
  var Power3 = _easeMap.Power3;
  var Power4 = _easeMap.Power4;
  var Linear = _easeMap.Linear;
  var Quad = _easeMap.Quad;
  var Cubic = _easeMap.Cubic;
  var Quart = _easeMap.Quart;
  var Quint = _easeMap.Quint;
  var Strong = _easeMap.Strong;
  var Elastic = _easeMap.Elastic;
  var Back = _easeMap.Back;
  var SteppedEase = _easeMap.SteppedEase;
  var Bounce = _easeMap.Bounce;
  var Sine = _easeMap.Sine;
  var Expo = _easeMap.Expo;
  var Circ = _easeMap.Circ;

  // node_modules/gsap/CSSPlugin.js
  var _win2;
  var _doc2;
  var _docElement;
  var _pluginInitted;
  var _tempDiv;
  var _tempDivStyler;
  var _recentSetterPlugin;
  var _reverting2;
  var _windowExists3 = function _windowExists4() {
    return typeof window !== "undefined";
  };
  var _transformProps = {};
  var _RAD2DEG = 180 / Math.PI;
  var _DEG2RAD = Math.PI / 180;
  var _atan2 = Math.atan2;
  var _bigNum2 = 1e8;
  var _capsExp = /([A-Z])/g;
  var _horizontalExp = /(left|right|width|margin|padding|x)/i;
  var _complexExp = /[\s,\(]\S/;
  var _propertyAliases = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
  };
  var _renderCSSProp = function _renderCSSProp2(ratio, data2) {
    return data2.set(data2.t, data2.p, Math.round((data2.s + data2.c * ratio) * 1e4) / 1e4 + data2.u, data2);
  };
  var _renderPropWithEnd = function _renderPropWithEnd2(ratio, data2) {
    return data2.set(data2.t, data2.p, ratio === 1 ? data2.e : Math.round((data2.s + data2.c * ratio) * 1e4) / 1e4 + data2.u, data2);
  };
  var _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning2(ratio, data2) {
    return data2.set(data2.t, data2.p, ratio ? Math.round((data2.s + data2.c * ratio) * 1e4) / 1e4 + data2.u : data2.b, data2);
  };
  var _renderRoundedCSSProp = function _renderRoundedCSSProp2(ratio, data2) {
    var value2 = data2.s + data2.c * ratio;
    data2.set(data2.t, data2.p, ~~(value2 + (value2 < 0 ? -0.5 : 0.5)) + data2.u, data2);
  };
  var _renderNonTweeningValue = function _renderNonTweeningValue2(ratio, data2) {
    return data2.set(data2.t, data2.p, ratio ? data2.e : data2.b, data2);
  };
  var _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd2(ratio, data2) {
    return data2.set(data2.t, data2.p, ratio !== 1 ? data2.b : data2.e, data2);
  };
  var _setterCSSStyle = function _setterCSSStyle2(target, property2, value2) {
    return target.style[property2] = value2;
  };
  var _setterCSSProp = function _setterCSSProp2(target, property2, value2) {
    return target.style.setProperty(property2, value2);
  };
  var _setterTransform = function _setterTransform2(target, property2, value2) {
    return target._gsap[property2] = value2;
  };
  var _setterScale = function _setterScale2(target, property2, value2) {
    return target._gsap.scaleX = target._gsap.scaleY = value2;
  };
  var _setterScaleWithRender = function _setterScaleWithRender2(target, property2, value2, data2, ratio) {
    var cache = target._gsap;
    cache.scaleX = cache.scaleY = value2;
    cache.renderTransform(ratio, cache);
  };
  var _setterTransformWithRender = function _setterTransformWithRender2(target, property2, value2, data2, ratio) {
    var cache = target._gsap;
    cache[property2] = value2;
    cache.renderTransform(ratio, cache);
  };
  var _transformProp = "transform";
  var _transformOriginProp = _transformProp + "Origin";
  var _saveStyle = function _saveStyle2(property2, isNotCSS) {
    var _this = this;
    var target = this.target, style = target.style, cache = target._gsap;
    if (property2 in _transformProps && style) {
      this.tfm = this.tfm || {};
      if (property2 !== "transform") {
        property2 = _propertyAliases[property2] || property2;
        ~property2.indexOf(",") ? property2.split(",").forEach(function(a5) {
          return _this.tfm[a5] = _get(target, a5);
        }) : this.tfm[property2] = cache.x ? cache[property2] : _get(target, property2);
        property2 === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin);
      } else {
        return _propertyAliases.transform.split(",").forEach(function(p3) {
          return _saveStyle2.call(_this, p3, isNotCSS);
        });
      }
      if (this.props.indexOf(_transformProp) >= 0) {
        return;
      }
      if (cache.svg) {
        this.svgo = target.getAttribute("data-svg-origin");
        this.props.push(_transformOriginProp, isNotCSS, "");
      }
      property2 = _transformProp;
    }
    (style || isNotCSS) && this.props.push(property2, isNotCSS, style[property2]);
  };
  var _removeIndependentTransforms = function _removeIndependentTransforms2(style) {
    if (style.translate) {
      style.removeProperty("translate");
      style.removeProperty("scale");
      style.removeProperty("rotate");
    }
  };
  var _revertStyle = function _revertStyle2() {
    var props = this.props, target = this.target, style = target.style, cache = target._gsap, i6, p3;
    for (i6 = 0; i6 < props.length; i6 += 3) {
      props[i6 + 1] ? target[props[i6]] = props[i6 + 2] : props[i6 + 2] ? style[props[i6]] = props[i6 + 2] : style.removeProperty(props[i6].substr(0, 2) === "--" ? props[i6] : props[i6].replace(_capsExp, "-$1").toLowerCase());
    }
    if (this.tfm) {
      for (p3 in this.tfm) {
        cache[p3] = this.tfm[p3];
      }
      if (cache.svg) {
        cache.renderTransform();
        target.setAttribute("data-svg-origin", this.svgo || "");
      }
      i6 = _reverting2();
      if ((!i6 || !i6.isStart) && !style[_transformProp]) {
        _removeIndependentTransforms(style);
        if (cache.zOrigin && style[_transformOriginProp]) {
          style[_transformOriginProp] += " " + cache.zOrigin + "px";
          cache.zOrigin = 0;
          cache.renderTransform();
        }
        cache.uncache = 1;
      }
    }
  };
  var _getStyleSaver = function _getStyleSaver2(target, properties) {
    var saver = {
      target,
      props: [],
      revert: _revertStyle,
      save: _saveStyle
    };
    target._gsap || gsap.core.getCache(target);
    properties && properties.split(",").forEach(function(p3) {
      return saver.save(p3);
    });
    return saver;
  };
  var _supports3D;
  var _createElement = function _createElement2(type, ns) {
    var e5 = _doc2.createElementNS ? _doc2.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc2.createElement(type);
    return e5 && e5.style ? e5 : _doc2.createElement(type);
  };
  var _getComputedProperty = function _getComputedProperty2(target, property2, skipPrefixFallback) {
    var cs = getComputedStyle(target);
    return cs[property2] || cs.getPropertyValue(property2.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property2) || !skipPrefixFallback && _getComputedProperty2(target, _checkPropPrefix(property2) || property2, 1) || "";
  };
  var _prefixes = "O,Moz,ms,Ms,Webkit".split(",");
  var _checkPropPrefix = function _checkPropPrefix2(property2, element, preferPrefix) {
    var e5 = element || _tempDiv, s4 = e5.style, i6 = 5;
    if (property2 in s4 && !preferPrefix) {
      return property2;
    }
    property2 = property2.charAt(0).toUpperCase() + property2.substr(1);
    while (i6-- && !(_prefixes[i6] + property2 in s4)) {
    }
    return i6 < 0 ? null : (i6 === 3 ? "ms" : i6 >= 0 ? _prefixes[i6] : "") + property2;
  };
  var _initCore = function _initCore2() {
    if (_windowExists3() && window.document) {
      _win2 = window;
      _doc2 = _win2.document;
      _docElement = _doc2.documentElement;
      _tempDiv = _createElement("div") || {
        style: {}
      };
      _tempDivStyler = _createElement("div");
      _transformProp = _checkPropPrefix(_transformProp);
      _transformOriginProp = _transformProp + "Origin";
      _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0";
      _supports3D = !!_checkPropPrefix("perspective");
      _reverting2 = gsap.core.reverting;
      _pluginInitted = 1;
    }
  };
  var _getBBoxHack = function _getBBoxHack2(swapIfPossible) {
    var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), oldParent = this.parentNode, oldSibling = this.nextSibling, oldCSS = this.style.cssText, bbox;
    _docElement.appendChild(svg);
    svg.appendChild(this);
    this.style.display = "block";
    if (swapIfPossible) {
      try {
        bbox = this.getBBox();
        this._gsapBBox = this.getBBox;
        this.getBBox = _getBBoxHack2;
      } catch (e5) {
      }
    } else if (this._gsapBBox) {
      bbox = this._gsapBBox();
    }
    if (oldParent) {
      if (oldSibling) {
        oldParent.insertBefore(this, oldSibling);
      } else {
        oldParent.appendChild(this);
      }
    }
    _docElement.removeChild(svg);
    this.style.cssText = oldCSS;
    return bbox;
  };
  var _getAttributeFallbacks = function _getAttributeFallbacks2(target, attributesArray) {
    var i6 = attributesArray.length;
    while (i6--) {
      if (target.hasAttribute(attributesArray[i6])) {
        return target.getAttribute(attributesArray[i6]);
      }
    }
  };
  var _getBBox = function _getBBox2(target) {
    var bounds;
    try {
      bounds = target.getBBox();
    } catch (error) {
      bounds = _getBBoxHack.call(target, true);
    }
    bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true));
    return bounds && !bounds.width && !bounds.x && !bounds.y ? {
      x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
      y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
      width: 0,
      height: 0
    } : bounds;
  };
  var _isSVG = function _isSVG2(e5) {
    return !!(e5.getCTM && (!e5.parentNode || e5.ownerSVGElement) && _getBBox(e5));
  };
  var _removeProperty = function _removeProperty2(target, property2) {
    if (property2) {
      var style = target.style, first2Chars;
      if (property2 in _transformProps && property2 !== _transformOriginProp) {
        property2 = _transformProp;
      }
      if (style.removeProperty) {
        first2Chars = property2.substr(0, 2);
        if (first2Chars === "ms" || property2.substr(0, 6) === "webkit") {
          property2 = "-" + property2;
        }
        style.removeProperty(first2Chars === "--" ? property2 : property2.replace(_capsExp, "-$1").toLowerCase());
      } else {
        style.removeAttribute(property2);
      }
    }
  };
  var _addNonTweeningPT = function _addNonTweeningPT2(plugin, target, property2, beginning, end, onlySetAtEnd) {
    var pt = new PropTween(plugin._pt, target, property2, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
    plugin._pt = pt;
    pt.b = beginning;
    pt.e = end;
    plugin._props.push(property2);
    return pt;
  };
  var _nonConvertibleUnits = {
    deg: 1,
    rad: 1,
    turn: 1
  };
  var _nonStandardLayouts = {
    grid: 1,
    flex: 1
  };
  var _convertToUnit = function _convertToUnit2(target, property2, value2, unit) {
    var curValue = parseFloat(value2) || 0, curUnit = (value2 + "").trim().substr((curValue + "").length) || "px", style = _tempDiv.style, horizontal = _horizontalExp.test(property2), isRootSVG = target.tagName.toLowerCase() === "svg", measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"), amount = 100, toPixels = unit === "px", toPercent = unit === "%", px, parent2, cache, isSVG;
    if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
      return curValue;
    }
    curUnit !== "px" && !toPixels && (curValue = _convertToUnit2(target, property2, value2, "px"));
    isSVG = target.getCTM && _isSVG(target);
    if ((toPercent || curUnit === "%") && (_transformProps[property2] || ~property2.indexOf("adius"))) {
      px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
      return _round(toPercent ? curValue / px * amount : curValue / 100 * px);
    }
    style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
    parent2 = ~property2.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
    if (isSVG) {
      parent2 = (target.ownerSVGElement || {}).parentNode;
    }
    if (!parent2 || parent2 === _doc2 || !parent2.appendChild) {
      parent2 = _doc2.body;
    }
    cache = parent2._gsap;
    if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) {
      return _round(curValue / cache.width * amount);
    } else {
      if (toPercent && (property2 === "height" || property2 === "width")) {
        var v2 = target.style[property2];
        target.style[property2] = amount + unit;
        px = target[measureProperty];
        v2 ? target.style[property2] = v2 : _removeProperty(target, property2);
      } else {
        (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent2, "display")] && (style.position = _getComputedProperty(target, "position"));
        parent2 === target && (style.position = "static");
        parent2.appendChild(_tempDiv);
        px = _tempDiv[measureProperty];
        parent2.removeChild(_tempDiv);
        style.position = "absolute";
      }
      if (horizontal && toPercent) {
        cache = _getCache(parent2);
        cache.time = _ticker.time;
        cache.width = parent2[measureProperty];
      }
    }
    return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
  };
  var _get = function _get2(target, property2, unit, uncache) {
    var value2;
    _pluginInitted || _initCore();
    if (property2 in _propertyAliases && property2 !== "transform") {
      property2 = _propertyAliases[property2];
      if (~property2.indexOf(",")) {
        property2 = property2.split(",")[0];
      }
    }
    if (_transformProps[property2] && property2 !== "transform") {
      value2 = _parseTransform(target, uncache);
      value2 = property2 !== "transformOrigin" ? value2[property2] : value2.svg ? value2.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value2.zOrigin + "px";
    } else {
      value2 = target.style[property2];
      if (!value2 || value2 === "auto" || uncache || ~(value2 + "").indexOf("calc(")) {
        value2 = _specialProps[property2] && _specialProps[property2](target, property2, unit) || _getComputedProperty(target, property2) || _getProperty(target, property2) || (property2 === "opacity" ? 1 : 0);
      }
    }
    return unit && !~(value2 + "").trim().indexOf(" ") ? _convertToUnit(target, property2, value2, unit) + unit : value2;
  };
  var _tweenComplexCSSString = function _tweenComplexCSSString2(target, prop, start, end) {
    if (!start || start === "none") {
      var p3 = _checkPropPrefix(prop, target, 1), s4 = p3 && _getComputedProperty(target, p3, 1);
      if (s4 && s4 !== start) {
        prop = p3;
        start = s4;
      } else if (prop === "borderColor") {
        start = _getComputedProperty(target, "borderTopColor");
      }
    }
    var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString), index2 = 0, matchIndex = 0, a5, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues;
    pt.b = start;
    pt.e = end;
    start += "";
    end += "";
    if (end === "auto") {
      startValue = target.style[prop];
      target.style[prop] = end;
      end = _getComputedProperty(target, prop) || end;
      startValue ? target.style[prop] = startValue : _removeProperty(target, prop);
    }
    a5 = [start, end];
    _colorStringFilter(a5);
    start = a5[0];
    end = a5[1];
    startValues = start.match(_numWithUnitExp) || [];
    endValues = end.match(_numWithUnitExp) || [];
    if (endValues.length) {
      while (result = _numWithUnitExp.exec(end)) {
        endValue = result[0];
        chunk = end.substring(index2, result.index);
        if (color) {
          color = (color + 1) % 5;
        } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
          color = 1;
        }
        if (endValue !== (startValue = startValues[matchIndex++] || "")) {
          startNum = parseFloat(startValue) || 0;
          startUnit = startValue.substr((startNum + "").length);
          endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
          endNum = parseFloat(endValue);
          endUnit = endValue.substr((endNum + "").length);
          index2 = _numWithUnitExp.lastIndex - endUnit.length;
          if (!endUnit) {
            endUnit = endUnit || _config.units[prop] || startUnit;
            if (index2 === end.length) {
              end += endUnit;
              pt.e += endUnit;
            }
          }
          if (startUnit !== endUnit) {
            startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
          }
          pt._pt = {
            _next: pt._pt,
            p: chunk || matchIndex === 1 ? chunk : ",",
            //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
            s: startNum,
            c: endNum - startNum,
            m: color && color < 4 || prop === "zIndex" ? Math.round : 0
          };
        }
      }
      pt.c = index2 < end.length ? end.substring(index2, end.length) : "";
    } else {
      pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
    }
    _relExp.test(end) && (pt.e = 0);
    this._pt = pt;
    return pt;
  };
  var _keywordToPercent = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
  };
  var _convertKeywordsToPercentages = function _convertKeywordsToPercentages2(value2) {
    var split = value2.split(" "), x3 = split[0], y3 = split[1] || "50%";
    if (x3 === "top" || x3 === "bottom" || y3 === "left" || y3 === "right") {
      value2 = x3;
      x3 = y3;
      y3 = value2;
    }
    split[0] = _keywordToPercent[x3] || x3;
    split[1] = _keywordToPercent[y3] || y3;
    return split.join(" ");
  };
  var _renderClearProps = function _renderClearProps2(ratio, data2) {
    if (data2.tween && data2.tween._time === data2.tween._dur) {
      var target = data2.t, style = target.style, props = data2.u, cache = target._gsap, prop, clearTransforms, i6;
      if (props === "all" || props === true) {
        style.cssText = "";
        clearTransforms = 1;
      } else {
        props = props.split(",");
        i6 = props.length;
        while (--i6 > -1) {
          prop = props[i6];
          if (_transformProps[prop]) {
            clearTransforms = 1;
            prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
          }
          _removeProperty(target, prop);
        }
      }
      if (clearTransforms) {
        _removeProperty(target, _transformProp);
        if (cache) {
          cache.svg && target.removeAttribute("transform");
          _parseTransform(target, 1);
          cache.uncache = 1;
          _removeIndependentTransforms(style);
        }
      }
    }
  };
  var _specialProps = {
    clearProps: function clearProps(plugin, target, property2, endValue, tween) {
      if (tween.data !== "isFromStart") {
        var pt = plugin._pt = new PropTween(plugin._pt, target, property2, 0, 0, _renderClearProps);
        pt.u = endValue;
        pt.pr = -10;
        pt.tween = tween;
        plugin._props.push(property2);
        return 1;
      }
    }
    /* className feature (about 0.4kb gzipped).
    , className(plugin, target, property, endValue, tween) {
    	let _renderClassName = (ratio, data) => {
    			data.css.render(ratio, data.css);
    			if (!ratio || ratio === 1) {
    				let inline = data.rmv,
    					target = data.t,
    					p;
    				target.setAttribute("class", ratio ? data.e : data.b);
    				for (p in inline) {
    					_removeProperty(target, p);
    				}
    			}
    		},
    		_getAllStyles = (target) => {
    			let styles = {},
    				computed = getComputedStyle(target),
    				p;
    			for (p in computed) {
    				if (isNaN(p) && p !== "cssText" && p !== "length") {
    					styles[p] = computed[p];
    				}
    			}
    			_setDefaults(styles, _parseTransform(target, 1));
    			return styles;
    		},
    		startClassList = target.getAttribute("class"),
    		style = target.style,
    		cssText = style.cssText,
    		cache = target._gsap,
    		classPT = cache.classPT,
    		inlineToRemoveAtEnd = {},
    		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
    		changingVars = {},
    		startVars = _getAllStyles(target),
    		transformRelated = /(transform|perspective)/i,
    		endVars, p;
    	if (classPT) {
    		classPT.r(1, classPT.d);
    		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
    	}
    	target.setAttribute("class", data.e);
    	endVars = _getAllStyles(target, true);
    	target.setAttribute("class", startClassList);
    	for (p in endVars) {
    		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
    			changingVars[p] = endVars[p];
    			if (!style[p] && style[p] !== "0") {
    				inlineToRemoveAtEnd[p] = 1;
    			}
    		}
    	}
    	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
    	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
    		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
    	}
    	_parseTransform(target, true); //to clear the caching of transforms
    	data.css = new gsap.plugins.css();
    	data.css.init(target, changingVars, tween);
    	plugin._props.push(...data.css._props);
    	return 1;
    }
    */
  };
  var _identity2DMatrix = [1, 0, 0, 1, 0, 0];
  var _rotationalProperties = {};
  var _isNullTransform = function _isNullTransform2(value2) {
    return value2 === "matrix(1, 0, 0, 1, 0, 0)" || value2 === "none" || !value2;
  };
  var _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray2(target) {
    var matrixString = _getComputedProperty(target, _transformProp);
    return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
  };
  var _getMatrix = function _getMatrix2(target, force2D) {
    var cache = target._gsap || _getCache(target), style = target.style, matrix = _getComputedTransformMatrixAsArray(target), parent2, nextSibling, temp, addedToDOM;
    if (cache.svg && target.getAttribute("transform")) {
      temp = target.transform.baseVal.consolidate().matrix;
      matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
      return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
    } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
      temp = style.display;
      style.display = "block";
      parent2 = target.parentNode;
      if (!parent2 || !target.offsetParent) {
        addedToDOM = 1;
        nextSibling = target.nextElementSibling;
        _docElement.appendChild(target);
      }
      matrix = _getComputedTransformMatrixAsArray(target);
      temp ? style.display = temp : _removeProperty(target, "display");
      if (addedToDOM) {
        nextSibling ? parent2.insertBefore(target, nextSibling) : parent2 ? parent2.appendChild(target) : _docElement.removeChild(target);
      }
    }
    return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
  };
  var _applySVGOrigin = function _applySVGOrigin2(target, origin, originIsAbsolute, smooth2, matrixArray, pluginToAddPropTweensTo) {
    var cache = target._gsap, matrix = matrixArray || _getMatrix(target, true), xOriginOld = cache.xOrigin || 0, yOriginOld = cache.yOrigin || 0, xOffsetOld = cache.xOffset || 0, yOffsetOld = cache.yOffset || 0, a5 = matrix[0], b3 = matrix[1], c4 = matrix[2], d3 = matrix[3], tx = matrix[4], ty = matrix[5], originSplit = origin.split(" "), xOrigin = parseFloat(originSplit[0]) || 0, yOrigin = parseFloat(originSplit[1]) || 0, bounds, determinant, x3, y3;
    if (!originIsAbsolute) {
      bounds = _getBBox(target);
      xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
      yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
    } else if (matrix !== _identity2DMatrix && (determinant = a5 * d3 - b3 * c4)) {
      x3 = xOrigin * (d3 / determinant) + yOrigin * (-c4 / determinant) + (c4 * ty - d3 * tx) / determinant;
      y3 = xOrigin * (-b3 / determinant) + yOrigin * (a5 / determinant) - (a5 * ty - b3 * tx) / determinant;
      xOrigin = x3;
      yOrigin = y3;
    }
    if (smooth2 || smooth2 !== false && cache.smooth) {
      tx = xOrigin - xOriginOld;
      ty = yOrigin - yOriginOld;
      cache.xOffset = xOffsetOld + (tx * a5 + ty * c4) - tx;
      cache.yOffset = yOffsetOld + (tx * b3 + ty * d3) - ty;
    } else {
      cache.xOffset = cache.yOffset = 0;
    }
    cache.xOrigin = xOrigin;
    cache.yOrigin = yOrigin;
    cache.smooth = !!smooth2;
    cache.origin = origin;
    cache.originIsAbsolute = !!originIsAbsolute;
    target.style[_transformOriginProp] = "0px 0px";
    if (pluginToAddPropTweensTo) {
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
    }
    target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
  };
  var _parseTransform = function _parseTransform2(target, uncache) {
    var cache = target._gsap || new GSCache(target);
    if ("x" in cache && !uncache && !cache.uncache) {
      return cache;
    }
    var style = target.style, invertedScaleX = cache.scaleX < 0, px = "px", deg = "deg", cs = getComputedStyle(target), origin = _getComputedProperty(target, _transformOriginProp) || "0", x3, y3, z2, scaleX, scaleY, rotation2, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a5, b3, c4, d3, a12, a22, t1, t22, t32, a13, a23, a33, a42, a43, a32;
    x3 = y3 = z2 = rotation2 = rotationX = rotationY = skewX = skewY = perspective = 0;
    scaleX = scaleY = 1;
    cache.svg = !!(target.getCTM && _isSVG(target));
    if (cs.translate) {
      if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
        style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp] !== "none" ? cs[_transformProp] : "");
      }
      style.scale = style.rotate = style.translate = "none";
    }
    matrix = _getMatrix(target, cache.svg);
    if (cache.svg) {
      if (cache.uncache) {
        t22 = target.getBBox();
        origin = cache.xOrigin - t22.x + "px " + (cache.yOrigin - t22.y) + "px";
        t1 = "";
      } else {
        t1 = !uncache && target.getAttribute("data-svg-origin");
      }
      _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
    }
    xOrigin = cache.xOrigin || 0;
    yOrigin = cache.yOrigin || 0;
    if (matrix !== _identity2DMatrix) {
      a5 = matrix[0];
      b3 = matrix[1];
      c4 = matrix[2];
      d3 = matrix[3];
      x3 = a12 = matrix[4];
      y3 = a22 = matrix[5];
      if (matrix.length === 6) {
        scaleX = Math.sqrt(a5 * a5 + b3 * b3);
        scaleY = Math.sqrt(d3 * d3 + c4 * c4);
        rotation2 = a5 || b3 ? _atan2(b3, a5) * _RAD2DEG : 0;
        skewX = c4 || d3 ? _atan2(c4, d3) * _RAD2DEG + rotation2 : 0;
        skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
        if (cache.svg) {
          x3 -= xOrigin - (xOrigin * a5 + yOrigin * c4);
          y3 -= yOrigin - (xOrigin * b3 + yOrigin * d3);
        }
      } else {
        a32 = matrix[6];
        a42 = matrix[7];
        a13 = matrix[8];
        a23 = matrix[9];
        a33 = matrix[10];
        a43 = matrix[11];
        x3 = matrix[12];
        y3 = matrix[13];
        z2 = matrix[14];
        angle = _atan2(a32, a33);
        rotationX = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a12 * cos + a13 * sin;
          t22 = a22 * cos + a23 * sin;
          t32 = a32 * cos + a33 * sin;
          a13 = a12 * -sin + a13 * cos;
          a23 = a22 * -sin + a23 * cos;
          a33 = a32 * -sin + a33 * cos;
          a43 = a42 * -sin + a43 * cos;
          a12 = t1;
          a22 = t22;
          a32 = t32;
        }
        angle = _atan2(-c4, a33);
        rotationY = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a5 * cos - a13 * sin;
          t22 = b3 * cos - a23 * sin;
          t32 = c4 * cos - a33 * sin;
          a43 = d3 * sin + a43 * cos;
          a5 = t1;
          b3 = t22;
          c4 = t32;
        }
        angle = _atan2(b3, a5);
        rotation2 = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(angle);
          sin = Math.sin(angle);
          t1 = a5 * cos + b3 * sin;
          t22 = a12 * cos + a22 * sin;
          b3 = b3 * cos - a5 * sin;
          a22 = a22 * cos - a12 * sin;
          a5 = t1;
          a12 = t22;
        }
        if (rotationX && Math.abs(rotationX) + Math.abs(rotation2) > 359.9) {
          rotationX = rotation2 = 0;
          rotationY = 180 - rotationY;
        }
        scaleX = _round(Math.sqrt(a5 * a5 + b3 * b3 + c4 * c4));
        scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
        angle = _atan2(a12, a22);
        skewX = Math.abs(angle) > 2e-4 ? angle * _RAD2DEG : 0;
        perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
      }
      if (cache.svg) {
        t1 = target.getAttribute("transform");
        cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
        t1 && target.setAttribute("transform", t1);
      }
    }
    if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
      if (invertedScaleX) {
        scaleX *= -1;
        skewX += rotation2 <= 0 ? 180 : -180;
        rotation2 += rotation2 <= 0 ? 180 : -180;
      } else {
        scaleY *= -1;
        skewX += skewX <= 0 ? 180 : -180;
      }
    }
    uncache = uncache || cache.uncache;
    cache.x = x3 - ((cache.xPercent = x3 && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x3) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
    cache.y = y3 - ((cache.yPercent = y3 && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y3) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
    cache.z = z2 + px;
    cache.scaleX = _round(scaleX);
    cache.scaleY = _round(scaleY);
    cache.rotation = _round(rotation2) + deg;
    cache.rotationX = _round(rotationX) + deg;
    cache.rotationY = _round(rotationY) + deg;
    cache.skewX = skewX + deg;
    cache.skewY = skewY + deg;
    cache.transformPerspective = perspective + px;
    if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || !uncache && cache.zOrigin || 0) {
      style[_transformOriginProp] = _firstTwoOnly(origin);
    }
    cache.xOffset = cache.yOffset = 0;
    cache.force3D = _config.force3D;
    cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
    cache.uncache = 0;
    return cache;
  };
  var _firstTwoOnly = function _firstTwoOnly2(value2) {
    return (value2 = value2.split(" "))[0] + " " + value2[1];
  };
  var _addPxTranslate = function _addPxTranslate2(target, start, value2) {
    var unit = getUnit(start);
    return _round(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value2 + "px", unit))) + unit;
  };
  var _renderNon3DTransforms = function _renderNon3DTransforms2(ratio, cache) {
    cache.z = "0px";
    cache.rotationY = cache.rotationX = "0deg";
    cache.force3D = 0;
    _renderCSSTransforms(ratio, cache);
  };
  var _zeroDeg = "0deg";
  var _zeroPx = "0px";
  var _endParenthesis = ") ";
  var _renderCSSTransforms = function _renderCSSTransforms2(ratio, cache) {
    var _ref = cache || this, xPercent = _ref.xPercent, yPercent = _ref.yPercent, x3 = _ref.x, y3 = _ref.y, z2 = _ref.z, rotation2 = _ref.rotation, rotationY = _ref.rotationY, rotationX = _ref.rotationX, skewX = _ref.skewX, skewY = _ref.skewY, scaleX = _ref.scaleX, scaleY = _ref.scaleY, transformPerspective = _ref.transformPerspective, force3D = _ref.force3D, target = _ref.target, zOrigin = _ref.zOrigin, transforms = "", use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;
    if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
      var angle = parseFloat(rotationY) * _DEG2RAD, a13 = Math.sin(angle), a33 = Math.cos(angle), cos;
      angle = parseFloat(rotationX) * _DEG2RAD;
      cos = Math.cos(angle);
      x3 = _addPxTranslate(target, x3, a13 * cos * -zOrigin);
      y3 = _addPxTranslate(target, y3, -Math.sin(angle) * -zOrigin);
      z2 = _addPxTranslate(target, z2, a33 * cos * -zOrigin + zOrigin);
    }
    if (transformPerspective !== _zeroPx) {
      transforms += "perspective(" + transformPerspective + _endParenthesis;
    }
    if (xPercent || yPercent) {
      transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
    }
    if (use3D || x3 !== _zeroPx || y3 !== _zeroPx || z2 !== _zeroPx) {
      transforms += z2 !== _zeroPx || use3D ? "translate3d(" + x3 + ", " + y3 + ", " + z2 + ") " : "translate(" + x3 + ", " + y3 + _endParenthesis;
    }
    if (rotation2 !== _zeroDeg) {
      transforms += "rotate(" + rotation2 + _endParenthesis;
    }
    if (rotationY !== _zeroDeg) {
      transforms += "rotateY(" + rotationY + _endParenthesis;
    }
    if (rotationX !== _zeroDeg) {
      transforms += "rotateX(" + rotationX + _endParenthesis;
    }
    if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
      transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
    }
    if (scaleX !== 1 || scaleY !== 1) {
      transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
    }
    target.style[_transformProp] = transforms || "translate(0, 0)";
  };
  var _renderSVGTransforms = function _renderSVGTransforms2(ratio, cache) {
    var _ref2 = cache || this, xPercent = _ref2.xPercent, yPercent = _ref2.yPercent, x3 = _ref2.x, y3 = _ref2.y, rotation2 = _ref2.rotation, skewX = _ref2.skewX, skewY = _ref2.skewY, scaleX = _ref2.scaleX, scaleY = _ref2.scaleY, target = _ref2.target, xOrigin = _ref2.xOrigin, yOrigin = _ref2.yOrigin, xOffset = _ref2.xOffset, yOffset = _ref2.yOffset, forceCSS = _ref2.forceCSS, tx = parseFloat(x3), ty = parseFloat(y3), a11, a21, a12, a22, temp;
    rotation2 = parseFloat(rotation2);
    skewX = parseFloat(skewX);
    skewY = parseFloat(skewY);
    if (skewY) {
      skewY = parseFloat(skewY);
      skewX += skewY;
      rotation2 += skewY;
    }
    if (rotation2 || skewX) {
      rotation2 *= _DEG2RAD;
      skewX *= _DEG2RAD;
      a11 = Math.cos(rotation2) * scaleX;
      a21 = Math.sin(rotation2) * scaleX;
      a12 = Math.sin(rotation2 - skewX) * -scaleY;
      a22 = Math.cos(rotation2 - skewX) * scaleY;
      if (skewX) {
        skewY *= _DEG2RAD;
        temp = Math.tan(skewX - skewY);
        temp = Math.sqrt(1 + temp * temp);
        a12 *= temp;
        a22 *= temp;
        if (skewY) {
          temp = Math.tan(skewY);
          temp = Math.sqrt(1 + temp * temp);
          a11 *= temp;
          a21 *= temp;
        }
      }
      a11 = _round(a11);
      a21 = _round(a21);
      a12 = _round(a12);
      a22 = _round(a22);
    } else {
      a11 = scaleX;
      a22 = scaleY;
      a21 = a12 = 0;
    }
    if (tx && !~(x3 + "").indexOf("px") || ty && !~(y3 + "").indexOf("px")) {
      tx = _convertToUnit(target, "x", x3, "px");
      ty = _convertToUnit(target, "y", y3, "px");
    }
    if (xOrigin || yOrigin || xOffset || yOffset) {
      tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
      ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
    }
    if (xPercent || yPercent) {
      temp = target.getBBox();
      tx = _round(tx + xPercent / 100 * temp.width);
      ty = _round(ty + yPercent / 100 * temp.height);
    }
    temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
    target.setAttribute("transform", temp);
    forceCSS && (target.style[_transformProp] = temp);
  };
  var _addRotationalPropTween = function _addRotationalPropTween2(plugin, target, property2, startNum, endValue) {
    var cap = 360, isString = _isString(endValue), endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1), change = endNum - startNum, finalValue = startNum + change + "deg", direction, pt;
    if (isString) {
      direction = endValue.split("_")[1];
      if (direction === "short") {
        change %= cap;
        if (change !== change % (cap / 2)) {
          change += change < 0 ? cap : -cap;
        }
      }
      if (direction === "cw" && change < 0) {
        change = (change + cap * _bigNum2) % cap - ~~(change / cap) * cap;
      } else if (direction === "ccw" && change > 0) {
        change = (change - cap * _bigNum2) % cap - ~~(change / cap) * cap;
      }
    }
    plugin._pt = pt = new PropTween(plugin._pt, target, property2, startNum, change, _renderPropWithEnd);
    pt.e = finalValue;
    pt.u = "deg";
    plugin._props.push(property2);
    return pt;
  };
  var _assign = function _assign2(target, source) {
    for (var p3 in source) {
      target[p3] = source[p3];
    }
    return target;
  };
  var _addRawTransformPTs = function _addRawTransformPTs2(plugin, transforms, target) {
    var startCache = _assign({}, target._gsap), exclude = "perspective,force3D,transformOrigin,svgOrigin", style = target.style, endCache, p3, startValue, endValue, startNum, endNum, startUnit, endUnit;
    if (startCache.svg) {
      startValue = target.getAttribute("transform");
      target.setAttribute("transform", "");
      style[_transformProp] = transforms;
      endCache = _parseTransform(target, 1);
      _removeProperty(target, _transformProp);
      target.setAttribute("transform", startValue);
    } else {
      startValue = getComputedStyle(target)[_transformProp];
      style[_transformProp] = transforms;
      endCache = _parseTransform(target, 1);
      style[_transformProp] = startValue;
    }
    for (p3 in _transformProps) {
      startValue = startCache[p3];
      endValue = endCache[p3];
      if (startValue !== endValue && exclude.indexOf(p3) < 0) {
        startUnit = getUnit(startValue);
        endUnit = getUnit(endValue);
        startNum = startUnit !== endUnit ? _convertToUnit(target, p3, startValue, endUnit) : parseFloat(startValue);
        endNum = parseFloat(endValue);
        plugin._pt = new PropTween(plugin._pt, endCache, p3, startNum, endNum - startNum, _renderCSSProp);
        plugin._pt.u = endUnit || 0;
        plugin._props.push(p3);
      }
    }
    _assign(endCache, startCache);
  };
  _forEachName("padding,margin,Width,Radius", function(name2, index2) {
    var t4 = "Top", r6 = "Right", b3 = "Bottom", l6 = "Left", props = (index2 < 3 ? [t4, r6, b3, l6] : [t4 + l6, t4 + r6, b3 + r6, b3 + l6]).map(function(side) {
      return index2 < 2 ? name2 + side : "border" + side + name2;
    });
    _specialProps[index2 > 1 ? "border" + name2 : name2] = function(plugin, target, property2, endValue, tween) {
      var a5, vars;
      if (arguments.length < 4) {
        a5 = props.map(function(prop) {
          return _get(plugin, prop, property2);
        });
        vars = a5.join(" ");
        return vars.split(a5[0]).length === 5 ? a5[0] : vars;
      }
      a5 = (endValue + "").split(" ");
      vars = {};
      props.forEach(function(prop, i6) {
        return vars[prop] = a5[i6] = a5[i6] || a5[(i6 - 1) / 2 | 0];
      });
      plugin.init(target, vars, tween);
    };
  });
  var CSSPlugin = {
    name: "css",
    register: _initCore,
    targetTest: function targetTest(target) {
      return target.style && target.nodeType;
    },
    init: function init3(target, vars, tween, index2, targets) {
      var props = this._props, style = target.style, startAt = tween.vars.startAt, startValue, endValue, endNum, startNum, type, specialProp, p3, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth2, hasPriority, inlineProps;
      _pluginInitted || _initCore();
      this.styles = this.styles || _getStyleSaver(target);
      inlineProps = this.styles.props;
      this.tween = tween;
      for (p3 in vars) {
        if (p3 === "autoRound") {
          continue;
        }
        endValue = vars[p3];
        if (_plugins[p3] && _checkPlugin(p3, vars, tween, index2, target, targets)) {
          continue;
        }
        type = typeof endValue;
        specialProp = _specialProps[p3];
        if (type === "function") {
          endValue = endValue.call(tween, index2, target, targets);
          type = typeof endValue;
        }
        if (type === "string" && ~endValue.indexOf("random(")) {
          endValue = _replaceRandom(endValue);
        }
        if (specialProp) {
          specialProp(this, target, p3, endValue, tween) && (hasPriority = 1);
        } else if (p3.substr(0, 2) === "--") {
          startValue = (getComputedStyle(target).getPropertyValue(p3) + "").trim();
          endValue += "";
          _colorExp.lastIndex = 0;
          if (!_colorExp.test(startValue)) {
            startUnit = getUnit(startValue);
            endUnit = getUnit(endValue);
          }
          endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p3, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
          this.add(style, "setProperty", startValue, endValue, index2, targets, 0, 0, p3);
          props.push(p3);
          inlineProps.push(p3, 0, style[p3]);
        } else if (type !== "undefined") {
          if (startAt && p3 in startAt) {
            startValue = typeof startAt[p3] === "function" ? startAt[p3].call(tween, index2, target, targets) : startAt[p3];
            _isString(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
            getUnit(startValue + "") || startValue === "auto" || (startValue += _config.units[p3] || getUnit(_get(target, p3)) || "");
            (startValue + "").charAt(1) === "=" && (startValue = _get(target, p3));
          } else {
            startValue = _get(target, p3);
          }
          startNum = parseFloat(startValue);
          relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
          relative && (endValue = endValue.substr(2));
          endNum = parseFloat(endValue);
          if (p3 in _propertyAliases) {
            if (p3 === "autoAlpha") {
              if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                startNum = 0;
              }
              inlineProps.push("visibility", 0, style.visibility);
              _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
            }
            if (p3 !== "scale" && p3 !== "transform") {
              p3 = _propertyAliases[p3];
              ~p3.indexOf(",") && (p3 = p3.split(",")[0]);
            }
          }
          isTransformRelated = p3 in _transformProps;
          if (isTransformRelated) {
            this.styles.save(p3);
            if (!transformPropTween) {
              cache = target._gsap;
              cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);
              smooth2 = vars.smoothOrigin !== false && cache.smooth;
              transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);
              transformPropTween.dep = 1;
            }
            if (p3 === "scale") {
              this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
              this._pt.u = 0;
              props.push("scaleY", p3);
              p3 += "X";
            } else if (p3 === "transformOrigin") {
              inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
              endValue = _convertKeywordsToPercentages(endValue);
              if (cache.svg) {
                _applySVGOrigin(target, endValue, 0, smooth2, 0, this);
              } else {
                endUnit = parseFloat(endValue.split(" ")[2]) || 0;
                endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
                _addNonTweeningPT(this, style, p3, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
              }
              continue;
            } else if (p3 === "svgOrigin") {
              _applySVGOrigin(target, endValue, 1, smooth2, 0, this);
              continue;
            } else if (p3 in _rotationalProperties) {
              _addRotationalPropTween(this, cache, p3, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);
              continue;
            } else if (p3 === "smoothOrigin") {
              _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
              continue;
            } else if (p3 === "force3D") {
              cache[p3] = endValue;
              continue;
            } else if (p3 === "transform") {
              _addRawTransformPTs(this, endValue, target);
              continue;
            }
          } else if (!(p3 in style)) {
            p3 = _checkPropPrefix(p3) || p3;
          }
          if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p3 in style) {
            startUnit = (startValue + "").substr((startNum + "").length);
            endNum || (endNum = 0);
            endUnit = getUnit(endValue) || (p3 in _config.units ? _config.units[p3] : startUnit);
            startUnit !== endUnit && (startNum = _convertToUnit(target, p3, startValue, endUnit));
            this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p3, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p3 === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
            this._pt.u = endUnit || 0;
            if (startUnit !== endUnit && endUnit !== "%") {
              this._pt.b = startValue;
              this._pt.r = _renderCSSPropWithBeginning;
            }
          } else if (!(p3 in style)) {
            if (p3 in target) {
              this.add(target, p3, startValue || target[p3], relative ? relative + endValue : endValue, index2, targets);
            } else if (p3 !== "parseTransform") {
              _missingPlugin(p3, endValue);
              continue;
            }
          } else {
            _tweenComplexCSSString.call(this, target, p3, startValue, relative ? relative + endValue : endValue);
          }
          isTransformRelated || (p3 in style ? inlineProps.push(p3, 0, style[p3]) : inlineProps.push(p3, 1, startValue || target[p3]));
          props.push(p3);
        }
      }
      hasPriority && _sortPropTweensByPriority(this);
    },
    render: function render2(ratio, data2) {
      if (data2.tween._time || !_reverting2()) {
        var pt = data2._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
      } else {
        data2.styles.revert();
      }
    },
    get: _get,
    aliases: _propertyAliases,
    getSetter: function getSetter(target, property2, plugin) {
      var p3 = _propertyAliases[property2];
      p3 && p3.indexOf(",") < 0 && (property2 = p3);
      return property2 in _transformProps && property2 !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property2 === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property2 === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property2]) ? _setterCSSStyle : ~property2.indexOf("-") ? _setterCSSProp : _getSetter(target, property2);
    },
    core: {
      _removeProperty,
      _getMatrix
    }
  };
  gsap.utils.checkPrefix = _checkPropPrefix;
  gsap.core.getStyleSaver = _getStyleSaver;
  (function(positionAndScale, rotation2, others, aliases) {
    var all = _forEachName(positionAndScale + "," + rotation2 + "," + others, function(name2) {
      _transformProps[name2] = 1;
    });
    _forEachName(rotation2, function(name2) {
      _config.units[name2] = "deg";
      _rotationalProperties[name2] = 1;
    });
    _propertyAliases[all[13]] = positionAndScale + "," + rotation2;
    _forEachName(aliases, function(name2) {
      var split = name2.split(":");
      _propertyAliases[split[1]] = all[split[0]];
    });
  })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
  _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(name2) {
    _config.units[name2] = "px";
  });
  gsap.registerPlugin(CSSPlugin);

  // node_modules/gsap/index.js
  var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap;
  var TweenMaxWithCSS = gsapWithCSS.core.Tween;

  // node_modules/swiper/shared/ssr-window.esm.mjs
  function isObject(obj) {
    return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
  }
  function extend(target, src) {
    if (target === void 0) {
      target = {};
    }
    if (src === void 0) {
      src = {};
    }
    Object.keys(src).forEach((key2) => {
      if (typeof target[key2] === "undefined") target[key2] = src[key2];
      else if (isObject(src[key2]) && isObject(target[key2]) && Object.keys(src[key2]).length > 0) {
        extend(target[key2], src[key2]);
      }
    });
  }
  var ssrDocument = {
    body: {},
    addEventListener() {
    },
    removeEventListener() {
    },
    activeElement: {
      blur() {
      },
      nodeName: ""
    },
    querySelector() {
      return null;
    },
    querySelectorAll() {
      return [];
    },
    getElementById() {
      return null;
    },
    createEvent() {
      return {
        initEvent() {
        }
      };
    },
    createElement() {
      return {
        children: [],
        childNodes: [],
        style: {},
        setAttribute() {
        },
        getElementsByTagName() {
          return [];
        }
      };
    },
    createElementNS() {
      return {};
    },
    importNode() {
      return null;
    },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
    }
  };
  function getDocument() {
    const doc = typeof document !== "undefined" ? document : {};
    extend(doc, ssrDocument);
    return doc;
  }
  var ssrWindow = {
    document: ssrDocument,
    navigator: {
      userAgent: ""
    },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
    },
    history: {
      replaceState() {
      },
      pushState() {
      },
      go() {
      },
      back() {
      }
    },
    CustomEvent: function CustomEvent2() {
      return this;
    },
    addEventListener() {
    },
    removeEventListener() {
    },
    getComputedStyle() {
      return {
        getPropertyValue() {
          return "";
        }
      };
    },
    Image() {
    },
    Date() {
    },
    screen: {},
    setTimeout() {
    },
    clearTimeout() {
    },
    matchMedia() {
      return {};
    },
    requestAnimationFrame(callback) {
      if (typeof setTimeout === "undefined") {
        callback();
        return null;
      }
      return setTimeout(callback, 0);
    },
    cancelAnimationFrame(id) {
      if (typeof setTimeout === "undefined") {
        return;
      }
      clearTimeout(id);
    }
  };
  function getWindow() {
    const win = typeof window !== "undefined" ? window : {};
    extend(win, ssrWindow);
    return win;
  }

  // node_modules/swiper/shared/utils.mjs
  function classesToTokens(classes2) {
    if (classes2 === void 0) {
      classes2 = "";
    }
    return classes2.trim().split(" ").filter((c4) => !!c4.trim());
  }
  function deleteProps(obj) {
    const object = obj;
    Object.keys(object).forEach((key2) => {
      try {
        object[key2] = null;
      } catch (e5) {
      }
      try {
        delete object[key2];
      } catch (e5) {
      }
    });
  }
  function nextTick(callback, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    return setTimeout(callback, delay3);
  }
  function now() {
    return Date.now();
  }
  function getComputedStyle2(el) {
    const window2 = getWindow();
    let style;
    if (window2.getComputedStyle) {
      style = window2.getComputedStyle(el, null);
    }
    if (!style && el.currentStyle) {
      style = el.currentStyle;
    }
    if (!style) {
      style = el.style;
    }
    return style;
  }
  function getTranslate(el, axis) {
    if (axis === void 0) {
      axis = "x";
    }
    const window2 = getWindow();
    let matrix;
    let curTransform;
    let transformMatrix;
    const curStyle = getComputedStyle2(el);
    if (window2.WebKitCSSMatrix) {
      curTransform = curStyle.transform || curStyle.webkitTransform;
      if (curTransform.split(",").length > 6) {
        curTransform = curTransform.split(", ").map((a5) => a5.replace(",", ".")).join(", ");
      }
      transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
    } else {
      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
      matrix = transformMatrix.toString().split(",");
    }
    if (axis === "x") {
      if (window2.WebKitCSSMatrix) curTransform = transformMatrix.m41;
      else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
      else curTransform = parseFloat(matrix[4]);
    }
    if (axis === "y") {
      if (window2.WebKitCSSMatrix) curTransform = transformMatrix.m42;
      else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
      else curTransform = parseFloat(matrix[5]);
    }
    return curTransform || 0;
  }
  function isObject2(o5) {
    return typeof o5 === "object" && o5 !== null && o5.constructor && Object.prototype.toString.call(o5).slice(8, -1) === "Object";
  }
  function isNode(node) {
    if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") {
      return node instanceof HTMLElement;
    }
    return node && (node.nodeType === 1 || node.nodeType === 11);
  }
  function extend2() {
    const to = Object(arguments.length <= 0 ? void 0 : arguments[0]);
    const noExtend = ["__proto__", "constructor", "prototype"];
    for (let i6 = 1; i6 < arguments.length; i6 += 1) {
      const nextSource = i6 < 0 || arguments.length <= i6 ? void 0 : arguments[i6];
      if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
        const keysArray = Object.keys(Object(nextSource)).filter((key2) => noExtend.indexOf(key2) < 0);
        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
          const nextKey = keysArray[nextIndex];
          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== void 0 && desc.enumerable) {
            if (isObject2(to[nextKey]) && isObject2(nextSource[nextKey])) {
              if (nextSource[nextKey].__swiper__) {
                to[nextKey] = nextSource[nextKey];
              } else {
                extend2(to[nextKey], nextSource[nextKey]);
              }
            } else if (!isObject2(to[nextKey]) && isObject2(nextSource[nextKey])) {
              to[nextKey] = {};
              if (nextSource[nextKey].__swiper__) {
                to[nextKey] = nextSource[nextKey];
              } else {
                extend2(to[nextKey], nextSource[nextKey]);
              }
            } else {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
    }
    return to;
  }
  function setCSSProperty(el, varName, varValue) {
    el.style.setProperty(varName, varValue);
  }
  function animateCSSModeScroll(_ref) {
    let {
      swiper,
      targetPosition,
      side
    } = _ref;
    const window2 = getWindow();
    const startPosition = -swiper.translate;
    let startTime = null;
    let time2;
    const duration = swiper.params.speed;
    swiper.wrapperEl.style.scrollSnapType = "none";
    window2.cancelAnimationFrame(swiper.cssModeFrameID);
    const dir = targetPosition > startPosition ? "next" : "prev";
    const isOutOfBound = (current, target) => {
      return dir === "next" && current >= target || dir === "prev" && current <= target;
    };
    const animate = () => {
      time2 = (/* @__PURE__ */ new Date()).getTime();
      if (startTime === null) {
        startTime = time2;
      }
      const progress = Math.max(Math.min((time2 - startTime) / duration, 1), 0);
      const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
      let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
      if (isOutOfBound(currentPosition, targetPosition)) {
        currentPosition = targetPosition;
      }
      swiper.wrapperEl.scrollTo({
        [side]: currentPosition
      });
      if (isOutOfBound(currentPosition, targetPosition)) {
        swiper.wrapperEl.style.overflow = "hidden";
        swiper.wrapperEl.style.scrollSnapType = "";
        setTimeout(() => {
          swiper.wrapperEl.style.overflow = "";
          swiper.wrapperEl.scrollTo({
            [side]: currentPosition
          });
        });
        window2.cancelAnimationFrame(swiper.cssModeFrameID);
        return;
      }
      swiper.cssModeFrameID = window2.requestAnimationFrame(animate);
    };
    animate();
  }
  function elementChildren(element, selector3) {
    if (selector3 === void 0) {
      selector3 = "";
    }
    const children = [...element.children];
    if (element instanceof HTMLSlotElement) {
      children.push(...element.assignedElements());
    }
    if (!selector3) {
      return children;
    }
    return children.filter((el) => el.matches(selector3));
  }
  function elementIsChildOf(el, parent2) {
    const isChild = parent2.contains(el);
    if (!isChild && parent2 instanceof HTMLSlotElement) {
      const children = [...parent2.assignedElements()];
      return children.includes(el);
    }
    return isChild;
  }
  function showWarning(text2) {
    try {
      console.warn(text2);
      return;
    } catch (err) {
    }
  }
  function createElement(tag, classes2) {
    if (classes2 === void 0) {
      classes2 = [];
    }
    const el = document.createElement(tag);
    el.classList.add(...Array.isArray(classes2) ? classes2 : classesToTokens(classes2));
    return el;
  }
  function elementPrevAll(el, selector3) {
    const prevEls = [];
    while (el.previousElementSibling) {
      const prev = el.previousElementSibling;
      if (selector3) {
        if (prev.matches(selector3)) prevEls.push(prev);
      } else prevEls.push(prev);
      el = prev;
    }
    return prevEls;
  }
  function elementNextAll(el, selector3) {
    const nextEls = [];
    while (el.nextElementSibling) {
      const next = el.nextElementSibling;
      if (selector3) {
        if (next.matches(selector3)) nextEls.push(next);
      } else nextEls.push(next);
      el = next;
    }
    return nextEls;
  }
  function elementStyle(el, prop) {
    const window2 = getWindow();
    return window2.getComputedStyle(el, null).getPropertyValue(prop);
  }
  function elementIndex(el) {
    let child = el;
    let i6;
    if (child) {
      i6 = 0;
      while ((child = child.previousSibling) !== null) {
        if (child.nodeType === 1) i6 += 1;
      }
      return i6;
    }
    return void 0;
  }
  function elementParents(el, selector3) {
    const parents = [];
    let parent2 = el.parentElement;
    while (parent2) {
      if (selector3) {
        if (parent2.matches(selector3)) parents.push(parent2);
      } else {
        parents.push(parent2);
      }
      parent2 = parent2.parentElement;
    }
    return parents;
  }
  function elementOuterSize(el, size, includeMargins) {
    const window2 = getWindow();
    if (includeMargins) {
      return el[size === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-right" : "margin-top")) + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-left" : "margin-bottom"));
    }
    return el.offsetWidth;
  }
  function makeElementsArray(el) {
    return (Array.isArray(el) ? el : [el]).filter((e5) => !!e5);
  }

  // node_modules/swiper/shared/swiper-core.mjs
  var support;
  function calcSupport() {
    const window2 = getWindow();
    const document2 = getDocument();
    return {
      smoothScroll: document2.documentElement && document2.documentElement.style && "scrollBehavior" in document2.documentElement.style,
      touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch)
    };
  }
  function getSupport() {
    if (!support) {
      support = calcSupport();
    }
    return support;
  }
  var deviceCached;
  function calcDevice(_temp) {
    let {
      userAgent
    } = _temp === void 0 ? {} : _temp;
    const support2 = getSupport();
    const window2 = getWindow();
    const platform = window2.navigator.platform;
    const ua = userAgent || window2.navigator.userAgent;
    const device = {
      ios: false,
      android: false
    };
    const screenWidth = window2.screen.width;
    const screenHeight = window2.screen.height;
    const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
    let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
    const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
    const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
    const windows = platform === "Win32";
    let macos = platform === "MacIntel";
    const iPadScreens = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
    if (!ipad && macos && support2.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
      ipad = ua.match(/(Version)\/([\d.]+)/);
      if (!ipad) ipad = [0, 1, "13_0_0"];
      macos = false;
    }
    if (android && !windows) {
      device.os = "android";
      device.android = true;
    }
    if (ipad || iphone || ipod) {
      device.os = "ios";
      device.ios = true;
    }
    return device;
  }
  function getDevice(overrides) {
    if (overrides === void 0) {
      overrides = {};
    }
    if (!deviceCached) {
      deviceCached = calcDevice(overrides);
    }
    return deviceCached;
  }
  var browser;
  function calcBrowser() {
    const window2 = getWindow();
    const device = getDevice();
    let needPerspectiveFix = false;
    function isSafari2() {
      const ua = window2.navigator.userAgent.toLowerCase();
      return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
    }
    if (isSafari2()) {
      const ua = String(window2.navigator.userAgent);
      if (ua.includes("Version/")) {
        const [major, minor] = ua.split("Version/")[1].split(" ")[0].split(".").map((num) => Number(num));
        needPerspectiveFix = major < 16 || major === 16 && minor < 2;
      }
    }
    const isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent);
    const isSafariBrowser = isSafari2();
    const need3dFix = isSafariBrowser || isWebView && device.ios;
    return {
      isSafari: needPerspectiveFix || isSafariBrowser,
      needPerspectiveFix,
      need3dFix,
      isWebView
    };
  }
  function getBrowser() {
    if (!browser) {
      browser = calcBrowser();
    }
    return browser;
  }
  function Resize(_ref) {
    let {
      swiper,
      on,
      emit
    } = _ref;
    const window2 = getWindow();
    let observer = null;
    let animationFrame = null;
    const resizeHandler = () => {
      if (!swiper || swiper.destroyed || !swiper.initialized) return;
      emit("beforeResize");
      emit("resize");
    };
    const createObserver = () => {
      if (!swiper || swiper.destroyed || !swiper.initialized) return;
      observer = new ResizeObserver((entries) => {
        animationFrame = window2.requestAnimationFrame(() => {
          const {
            width: width2,
            height: height2
          } = swiper;
          let newWidth = width2;
          let newHeight = height2;
          entries.forEach((_ref2) => {
            let {
              contentBoxSize,
              contentRect,
              target
            } = _ref2;
            if (target && target !== swiper.el) return;
            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
          });
          if (newWidth !== width2 || newHeight !== height2) {
            resizeHandler();
          }
        });
      });
      observer.observe(swiper.el);
    };
    const removeObserver = () => {
      if (animationFrame) {
        window2.cancelAnimationFrame(animationFrame);
      }
      if (observer && observer.unobserve && swiper.el) {
        observer.unobserve(swiper.el);
        observer = null;
      }
    };
    const orientationChangeHandler = () => {
      if (!swiper || swiper.destroyed || !swiper.initialized) return;
      emit("orientationchange");
    };
    on("init", () => {
      if (swiper.params.resizeObserver && typeof window2.ResizeObserver !== "undefined") {
        createObserver();
        return;
      }
      window2.addEventListener("resize", resizeHandler);
      window2.addEventListener("orientationchange", orientationChangeHandler);
    });
    on("destroy", () => {
      removeObserver();
      window2.removeEventListener("resize", resizeHandler);
      window2.removeEventListener("orientationchange", orientationChangeHandler);
    });
  }
  function Observer(_ref) {
    let {
      swiper,
      extendParams,
      on,
      emit
    } = _ref;
    const observers = [];
    const window2 = getWindow();
    const attach = function(target, options) {
      if (options === void 0) {
        options = {};
      }
      const ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;
      const observer = new ObserverFunc((mutations) => {
        if (swiper.__preventObserver__) return;
        if (mutations.length === 1) {
          emit("observerUpdate", mutations[0]);
          return;
        }
        const observerUpdate = function observerUpdate2() {
          emit("observerUpdate", mutations[0]);
        };
        if (window2.requestAnimationFrame) {
          window2.requestAnimationFrame(observerUpdate);
        } else {
          window2.setTimeout(observerUpdate, 0);
        }
      });
      observer.observe(target, {
        attributes: typeof options.attributes === "undefined" ? true : options.attributes,
        childList: swiper.isElement || (typeof options.childList === "undefined" ? true : options).childList,
        characterData: typeof options.characterData === "undefined" ? true : options.characterData
      });
      observers.push(observer);
    };
    const init5 = () => {
      if (!swiper.params.observer) return;
      if (swiper.params.observeParents) {
        const containerParents = elementParents(swiper.hostEl);
        for (let i6 = 0; i6 < containerParents.length; i6 += 1) {
          attach(containerParents[i6]);
        }
      }
      attach(swiper.hostEl, {
        childList: swiper.params.observeSlideChildren
      });
      attach(swiper.wrapperEl, {
        attributes: false
      });
    };
    const destroy = () => {
      observers.forEach((observer) => {
        observer.disconnect();
      });
      observers.splice(0, observers.length);
    };
    extendParams({
      observer: false,
      observeParents: false,
      observeSlideChildren: false
    });
    on("init", init5);
    on("destroy", destroy);
  }
  var eventsEmitter = {
    on(events2, handler, priority) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed) return self2;
      if (typeof handler !== "function") return self2;
      const method = priority ? "unshift" : "push";
      events2.split(" ").forEach((event2) => {
        if (!self2.eventsListeners[event2]) self2.eventsListeners[event2] = [];
        self2.eventsListeners[event2][method](handler);
      });
      return self2;
    },
    once(events2, handler, priority) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed) return self2;
      if (typeof handler !== "function") return self2;
      function onceHandler() {
        self2.off(events2, onceHandler);
        if (onceHandler.__emitterProxy) {
          delete onceHandler.__emitterProxy;
        }
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        handler.apply(self2, args);
      }
      onceHandler.__emitterProxy = handler;
      return self2.on(events2, onceHandler, priority);
    },
    onAny(handler, priority) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed) return self2;
      if (typeof handler !== "function") return self2;
      const method = priority ? "unshift" : "push";
      if (self2.eventsAnyListeners.indexOf(handler) < 0) {
        self2.eventsAnyListeners[method](handler);
      }
      return self2;
    },
    offAny(handler) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed) return self2;
      if (!self2.eventsAnyListeners) return self2;
      const index2 = self2.eventsAnyListeners.indexOf(handler);
      if (index2 >= 0) {
        self2.eventsAnyListeners.splice(index2, 1);
      }
      return self2;
    },
    off(events2, handler) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed) return self2;
      if (!self2.eventsListeners) return self2;
      events2.split(" ").forEach((event2) => {
        if (typeof handler === "undefined") {
          self2.eventsListeners[event2] = [];
        } else if (self2.eventsListeners[event2]) {
          self2.eventsListeners[event2].forEach((eventHandler, index2) => {
            if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
              self2.eventsListeners[event2].splice(index2, 1);
            }
          });
        }
      });
      return self2;
    },
    emit() {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed) return self2;
      if (!self2.eventsListeners) return self2;
      let events2;
      let data2;
      let context3;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      if (typeof args[0] === "string" || Array.isArray(args[0])) {
        events2 = args[0];
        data2 = args.slice(1, args.length);
        context3 = self2;
      } else {
        events2 = args[0].events;
        data2 = args[0].data;
        context3 = args[0].context || self2;
      }
      data2.unshift(context3);
      const eventsArray = Array.isArray(events2) ? events2 : events2.split(" ");
      eventsArray.forEach((event2) => {
        if (self2.eventsAnyListeners && self2.eventsAnyListeners.length) {
          self2.eventsAnyListeners.forEach((eventHandler) => {
            eventHandler.apply(context3, [event2, ...data2]);
          });
        }
        if (self2.eventsListeners && self2.eventsListeners[event2]) {
          self2.eventsListeners[event2].forEach((eventHandler) => {
            eventHandler.apply(context3, data2);
          });
        }
      });
      return self2;
    }
  };
  function updateSize() {
    const swiper = this;
    let width2;
    let height2;
    const el = swiper.el;
    if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) {
      width2 = swiper.params.width;
    } else {
      width2 = el.clientWidth;
    }
    if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) {
      height2 = swiper.params.height;
    } else {
      height2 = el.clientHeight;
    }
    if (width2 === 0 && swiper.isHorizontal() || height2 === 0 && swiper.isVertical()) {
      return;
    }
    width2 = width2 - parseInt(elementStyle(el, "padding-left") || 0, 10) - parseInt(elementStyle(el, "padding-right") || 0, 10);
    height2 = height2 - parseInt(elementStyle(el, "padding-top") || 0, 10) - parseInt(elementStyle(el, "padding-bottom") || 0, 10);
    if (Number.isNaN(width2)) width2 = 0;
    if (Number.isNaN(height2)) height2 = 0;
    Object.assign(swiper, {
      width: width2,
      height: height2,
      size: swiper.isHorizontal() ? width2 : height2
    });
  }
  function updateSlides() {
    const swiper = this;
    function getDirectionPropertyValue(node, label) {
      return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);
    }
    const params = swiper.params;
    const {
      wrapperEl,
      slidesEl,
      size: swiperSize,
      rtlTranslate: rtl,
      wrongRTL
    } = swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
    const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
    const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
    let snapGrid = [];
    const slidesGrid = [];
    const slidesSizesGrid = [];
    let offsetBefore = params.slidesOffsetBefore;
    if (typeof offsetBefore === "function") {
      offsetBefore = params.slidesOffsetBefore.call(swiper);
    }
    let offsetAfter = params.slidesOffsetAfter;
    if (typeof offsetAfter === "function") {
      offsetAfter = params.slidesOffsetAfter.call(swiper);
    }
    const previousSnapGridLength = swiper.snapGrid.length;
    const previousSlidesGridLength = swiper.slidesGrid.length;
    let spaceBetween = params.spaceBetween;
    let slidePosition = -offsetBefore;
    let prevSlideSize = 0;
    let index2 = 0;
    if (typeof swiperSize === "undefined") {
      return;
    }
    if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
      spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
    } else if (typeof spaceBetween === "string") {
      spaceBetween = parseFloat(spaceBetween);
    }
    swiper.virtualSize = -spaceBetween;
    slides.forEach((slideEl) => {
      if (rtl) {
        slideEl.style.marginLeft = "";
      } else {
        slideEl.style.marginRight = "";
      }
      slideEl.style.marginBottom = "";
      slideEl.style.marginTop = "";
    });
    if (params.centeredSlides && params.cssMode) {
      setCSSProperty(wrapperEl, "--swiper-centered-offset-before", "");
      setCSSProperty(wrapperEl, "--swiper-centered-offset-after", "");
    }
    const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
    if (gridEnabled) {
      swiper.grid.initSlides(slides);
    } else if (swiper.grid) {
      swiper.grid.unsetSlides();
    }
    let slideSize;
    const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key2) => {
      return typeof params.breakpoints[key2].slidesPerView !== "undefined";
    }).length > 0;
    for (let i6 = 0; i6 < slidesLength; i6 += 1) {
      slideSize = 0;
      let slide2;
      if (slides[i6]) slide2 = slides[i6];
      if (gridEnabled) {
        swiper.grid.updateSlide(i6, slide2, slides);
      }
      if (slides[i6] && elementStyle(slide2, "display") === "none") continue;
      if (params.slidesPerView === "auto") {
        if (shouldResetSlideSize) {
          slides[i6].style[swiper.getDirectionLabel("width")] = ``;
        }
        const slideStyles = getComputedStyle(slide2);
        const currentTransform = slide2.style.transform;
        const currentWebKitTransform = slide2.style.webkitTransform;
        if (currentTransform) {
          slide2.style.transform = "none";
        }
        if (currentWebKitTransform) {
          slide2.style.webkitTransform = "none";
        }
        if (params.roundLengths) {
          slideSize = swiper.isHorizontal() ? elementOuterSize(slide2, "width", true) : elementOuterSize(slide2, "height", true);
        } else {
          const width2 = getDirectionPropertyValue(slideStyles, "width");
          const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
          const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
          const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
          const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
          const boxSizing = slideStyles.getPropertyValue("box-sizing");
          if (boxSizing && boxSizing === "border-box") {
            slideSize = width2 + marginLeft + marginRight;
          } else {
            const {
              clientWidth,
              offsetWidth
            } = slide2;
            slideSize = width2 + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
          }
        }
        if (currentTransform) {
          slide2.style.transform = currentTransform;
        }
        if (currentWebKitTransform) {
          slide2.style.webkitTransform = currentWebKitTransform;
        }
        if (params.roundLengths) slideSize = Math.floor(slideSize);
      } else {
        slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
        if (params.roundLengths) slideSize = Math.floor(slideSize);
        if (slides[i6]) {
          slides[i6].style[swiper.getDirectionLabel("width")] = `${slideSize}px`;
        }
      }
      if (slides[i6]) {
        slides[i6].swiperSlideSize = slideSize;
      }
      slidesSizesGrid.push(slideSize);
      if (params.centeredSlides) {
        slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
        if (prevSlideSize === 0 && i6 !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        if (i6 === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        if (Math.abs(slidePosition) < 1 / 1e3) slidePosition = 0;
        if (params.roundLengths) slidePosition = Math.floor(slidePosition);
        if (index2 % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
        slidesGrid.push(slidePosition);
      } else {
        if (params.roundLengths) slidePosition = Math.floor(slidePosition);
        if ((index2 - Math.min(swiper.params.slidesPerGroupSkip, index2)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
        slidesGrid.push(slidePosition);
        slidePosition = slidePosition + slideSize + spaceBetween;
      }
      swiper.virtualSize += slideSize + spaceBetween;
      prevSlideSize = slideSize;
      index2 += 1;
    }
    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
    if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) {
      wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
    }
    if (params.setWrapperSize) {
      wrapperEl.style[swiper.getDirectionLabel("width")] = `${swiper.virtualSize + spaceBetween}px`;
    }
    if (gridEnabled) {
      swiper.grid.updateWrapperSize(slideSize, snapGrid);
    }
    if (!params.centeredSlides) {
      const newSlidesGrid = [];
      for (let i6 = 0; i6 < snapGrid.length; i6 += 1) {
        let slidesGridItem = snapGrid[i6];
        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[i6] <= swiper.virtualSize - swiperSize) {
          newSlidesGrid.push(slidesGridItem);
        }
      }
      snapGrid = newSlidesGrid;
      if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
        snapGrid.push(swiper.virtualSize - swiperSize);
      }
    }
    if (isVirtual && params.loop) {
      const size = slidesSizesGrid[0] + spaceBetween;
      if (params.slidesPerGroup > 1) {
        const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
        const groupSize = size * params.slidesPerGroup;
        for (let i6 = 0; i6 < groups; i6 += 1) {
          snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
        }
      }
      for (let i6 = 0; i6 < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i6 += 1) {
        if (params.slidesPerGroup === 1) {
          snapGrid.push(snapGrid[snapGrid.length - 1] + size);
        }
        slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
        swiper.virtualSize += size;
      }
    }
    if (snapGrid.length === 0) snapGrid = [0];
    if (spaceBetween !== 0) {
      const key2 = swiper.isHorizontal() && rtl ? "marginLeft" : swiper.getDirectionLabel("marginRight");
      slides.filter((_3, slideIndex) => {
        if (!params.cssMode || params.loop) return true;
        if (slideIndex === slides.length - 1) {
          return false;
        }
        return true;
      }).forEach((slideEl) => {
        slideEl.style[key2] = `${spaceBetween}px`;
      });
    }
    if (params.centeredSlides && params.centeredSlidesBounds) {
      let allSlidesSize = 0;
      slidesSizesGrid.forEach((slideSizeValue) => {
        allSlidesSize += slideSizeValue + (spaceBetween || 0);
      });
      allSlidesSize -= spaceBetween;
      const maxSnap = allSlidesSize > swiperSize ? allSlidesSize - swiperSize : 0;
      snapGrid = snapGrid.map((snap3) => {
        if (snap3 <= 0) return -offsetBefore;
        if (snap3 > maxSnap) return maxSnap + offsetAfter;
        return snap3;
      });
    }
    if (params.centerInsufficientSlides) {
      let allSlidesSize = 0;
      slidesSizesGrid.forEach((slideSizeValue) => {
        allSlidesSize += slideSizeValue + (spaceBetween || 0);
      });
      allSlidesSize -= spaceBetween;
      const offsetSize = (params.slidesOffsetBefore || 0) + (params.slidesOffsetAfter || 0);
      if (allSlidesSize + offsetSize < swiperSize) {
        const allSlidesOffset = (swiperSize - allSlidesSize - offsetSize) / 2;
        snapGrid.forEach((snap3, snapIndex) => {
          snapGrid[snapIndex] = snap3 - allSlidesOffset;
        });
        slidesGrid.forEach((snap3, snapIndex) => {
          slidesGrid[snapIndex] = snap3 + allSlidesOffset;
        });
      }
    }
    Object.assign(swiper, {
      slides,
      snapGrid,
      slidesGrid,
      slidesSizesGrid
    });
    if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
      setCSSProperty(wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
      setCSSProperty(wrapperEl, "--swiper-centered-offset-after", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
      const addToSnapGrid = -swiper.snapGrid[0];
      const addToSlidesGrid = -swiper.slidesGrid[0];
      swiper.snapGrid = swiper.snapGrid.map((v2) => v2 + addToSnapGrid);
      swiper.slidesGrid = swiper.slidesGrid.map((v2) => v2 + addToSlidesGrid);
    }
    if (slidesLength !== previousSlidesLength) {
      swiper.emit("slidesLengthChange");
    }
    if (snapGrid.length !== previousSnapGridLength) {
      if (swiper.params.watchOverflow) swiper.checkOverflow();
      swiper.emit("snapGridLengthChange");
    }
    if (slidesGrid.length !== previousSlidesGridLength) {
      swiper.emit("slidesGridLengthChange");
    }
    if (params.watchSlidesProgress) {
      swiper.updateSlidesOffset();
    }
    swiper.emit("slidesUpdated");
    if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
      const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
      const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
      if (slidesLength <= params.maxBackfaceHiddenSlides) {
        if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);
      } else if (hasClassBackfaceClassAdded) {
        swiper.el.classList.remove(backFaceHiddenClass);
      }
    }
  }
  function updateAutoHeight(speed) {
    const swiper = this;
    const activeSlides = [];
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let newHeight = 0;
    let i6;
    if (typeof speed === "number") {
      swiper.setTransition(speed);
    } else if (speed === true) {
      swiper.setTransition(swiper.params.speed);
    }
    const getSlideByIndex = (index2) => {
      if (isVirtual) {
        return swiper.slides[swiper.getSlideIndexByData(index2)];
      }
      return swiper.slides[index2];
    };
    if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) {
      if (swiper.params.centeredSlides) {
        (swiper.visibleSlides || []).forEach((slide2) => {
          activeSlides.push(slide2);
        });
      } else {
        for (i6 = 0; i6 < Math.ceil(swiper.params.slidesPerView); i6 += 1) {
          const index2 = swiper.activeIndex + i6;
          if (index2 > swiper.slides.length && !isVirtual) break;
          activeSlides.push(getSlideByIndex(index2));
        }
      }
    } else {
      activeSlides.push(getSlideByIndex(swiper.activeIndex));
    }
    for (i6 = 0; i6 < activeSlides.length; i6 += 1) {
      if (typeof activeSlides[i6] !== "undefined") {
        const height2 = activeSlides[i6].offsetHeight;
        newHeight = height2 > newHeight ? height2 : newHeight;
      }
    }
    if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;
  }
  function updateSlidesOffset() {
    const swiper = this;
    const slides = swiper.slides;
    const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
    for (let i6 = 0; i6 < slides.length; i6 += 1) {
      slides[i6].swiperSlideOffset = (swiper.isHorizontal() ? slides[i6].offsetLeft : slides[i6].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
    }
  }
  var toggleSlideClasses$1 = (slideEl, condition, className) => {
    if (condition && !slideEl.classList.contains(className)) {
      slideEl.classList.add(className);
    } else if (!condition && slideEl.classList.contains(className)) {
      slideEl.classList.remove(className);
    }
  };
  function updateSlidesProgress(translate2) {
    if (translate2 === void 0) {
      translate2 = this && this.translate || 0;
    }
    const swiper = this;
    const params = swiper.params;
    const {
      slides,
      rtlTranslate: rtl,
      snapGrid
    } = swiper;
    if (slides.length === 0) return;
    if (typeof slides[0].swiperSlideOffset === "undefined") swiper.updateSlidesOffset();
    let offsetCenter = -translate2;
    if (rtl) offsetCenter = translate2;
    swiper.visibleSlidesIndexes = [];
    swiper.visibleSlides = [];
    let spaceBetween = params.spaceBetween;
    if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
      spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiper.size;
    } else if (typeof spaceBetween === "string") {
      spaceBetween = parseFloat(spaceBetween);
    }
    for (let i6 = 0; i6 < slides.length; i6 += 1) {
      const slide2 = slides[i6];
      let slideOffset = slide2.swiperSlideOffset;
      if (params.cssMode && params.centeredSlides) {
        slideOffset -= slides[0].swiperSlideOffset;
      }
      const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
      const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
      const slideBefore = -(offsetCenter - slideOffset);
      const slideAfter = slideBefore + swiper.slidesSizesGrid[i6];
      const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i6];
      const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
      if (isVisible) {
        swiper.visibleSlides.push(slide2);
        swiper.visibleSlidesIndexes.push(i6);
      }
      toggleSlideClasses$1(slide2, isVisible, params.slideVisibleClass);
      toggleSlideClasses$1(slide2, isFullyVisible, params.slideFullyVisibleClass);
      slide2.progress = rtl ? -slideProgress : slideProgress;
      slide2.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
    }
  }
  function updateProgress(translate2) {
    const swiper = this;
    if (typeof translate2 === "undefined") {
      const multiplier = swiper.rtlTranslate ? -1 : 1;
      translate2 = swiper && swiper.translate && swiper.translate * multiplier || 0;
    }
    const params = swiper.params;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    let {
      progress,
      isBeginning,
      isEnd,
      progressLoop
    } = swiper;
    const wasBeginning = isBeginning;
    const wasEnd = isEnd;
    if (translatesDiff === 0) {
      progress = 0;
      isBeginning = true;
      isEnd = true;
    } else {
      progress = (translate2 - swiper.minTranslate()) / translatesDiff;
      const isBeginningRounded = Math.abs(translate2 - swiper.minTranslate()) < 1;
      const isEndRounded = Math.abs(translate2 - swiper.maxTranslate()) < 1;
      isBeginning = isBeginningRounded || progress <= 0;
      isEnd = isEndRounded || progress >= 1;
      if (isBeginningRounded) progress = 0;
      if (isEndRounded) progress = 1;
    }
    if (params.loop) {
      const firstSlideIndex = swiper.getSlideIndexByData(0);
      const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
      const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
      const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
      const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
      const translateAbs = Math.abs(translate2);
      if (translateAbs >= firstSlideTranslate) {
        progressLoop = (translateAbs - firstSlideTranslate) / translateMax;
      } else {
        progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
      }
      if (progressLoop > 1) progressLoop -= 1;
    }
    Object.assign(swiper, {
      progress,
      progressLoop,
      isBeginning,
      isEnd
    });
    if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate2);
    if (isBeginning && !wasBeginning) {
      swiper.emit("reachBeginning toEdge");
    }
    if (isEnd && !wasEnd) {
      swiper.emit("reachEnd toEdge");
    }
    if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
      swiper.emit("fromEdge");
    }
    swiper.emit("progress", progress);
  }
  var toggleSlideClasses = (slideEl, condition, className) => {
    if (condition && !slideEl.classList.contains(className)) {
      slideEl.classList.add(className);
    } else if (!condition && slideEl.classList.contains(className)) {
      slideEl.classList.remove(className);
    }
  };
  function updateSlidesClasses() {
    const swiper = this;
    const {
      slides,
      params,
      slidesEl,
      activeIndex
    } = swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    const getFilteredSlide = (selector3) => {
      return elementChildren(slidesEl, `.${params.slideClass}${selector3}, swiper-slide${selector3}`)[0];
    };
    let activeSlide;
    let prevSlide;
    let nextSlide;
    if (isVirtual) {
      if (params.loop) {
        let slideIndex = activeIndex - swiper.virtual.slidesBefore;
        if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;
        if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;
        activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
      } else {
        activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`);
      }
    } else {
      if (gridEnabled) {
        activeSlide = slides.filter((slideEl) => slideEl.column === activeIndex)[0];
        nextSlide = slides.filter((slideEl) => slideEl.column === activeIndex + 1)[0];
        prevSlide = slides.filter((slideEl) => slideEl.column === activeIndex - 1)[0];
      } else {
        activeSlide = slides[activeIndex];
      }
    }
    if (activeSlide) {
      if (!gridEnabled) {
        nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
        if (params.loop && !nextSlide) {
          nextSlide = slides[0];
        }
        prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
        if (params.loop && !prevSlide === 0) {
          prevSlide = slides[slides.length - 1];
        }
      }
    }
    slides.forEach((slideEl) => {
      toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);
      toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);
      toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);
    });
    swiper.emitSlidesClasses();
  }
  var processLazyPreloader = (swiper, imageEl) => {
    if (!swiper || swiper.destroyed || !swiper.params) return;
    const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
    const slideEl = imageEl.closest(slideSelector());
    if (slideEl) {
      let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
      if (!lazyEl && swiper.isElement) {
        if (slideEl.shadowRoot) {
          lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
        } else {
          requestAnimationFrame(() => {
            if (slideEl.shadowRoot) {
              lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
              if (lazyEl) lazyEl.remove();
            }
          });
        }
      }
      if (lazyEl) lazyEl.remove();
    }
  };
  var unlazy = (swiper, index2) => {
    if (!swiper.slides[index2]) return;
    const imageEl = swiper.slides[index2].querySelector('[loading="lazy"]');
    if (imageEl) imageEl.removeAttribute("loading");
  };
  var preload = (swiper) => {
    if (!swiper || swiper.destroyed || !swiper.params) return;
    let amount = swiper.params.lazyPreloadPrevNext;
    const len = swiper.slides.length;
    if (!len || !amount || amount < 0) return;
    amount = Math.min(amount, len);
    const slidesPerView = swiper.params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
    const activeIndex = swiper.activeIndex;
    if (swiper.params.grid && swiper.params.grid.rows > 1) {
      const activeColumn = activeIndex;
      const preloadColumns = [activeColumn - amount];
      preloadColumns.push(...Array.from({
        length: amount
      }).map((_3, i6) => {
        return activeColumn + slidesPerView + i6;
      }));
      swiper.slides.forEach((slideEl, i6) => {
        if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i6);
      });
      return;
    }
    const slideIndexLastInView = activeIndex + slidesPerView - 1;
    if (swiper.params.rewind || swiper.params.loop) {
      for (let i6 = activeIndex - amount; i6 <= slideIndexLastInView + amount; i6 += 1) {
        const realIndex = (i6 % len + len) % len;
        if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);
      }
    } else {
      for (let i6 = Math.max(activeIndex - amount, 0); i6 <= Math.min(slideIndexLastInView + amount, len - 1); i6 += 1) {
        if (i6 !== activeIndex && (i6 > slideIndexLastInView || i6 < activeIndex)) {
          unlazy(swiper, i6);
        }
      }
    }
  };
  function getActiveIndexByTranslate(swiper) {
    const {
      slidesGrid,
      params
    } = swiper;
    const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    let activeIndex;
    for (let i6 = 0; i6 < slidesGrid.length; i6 += 1) {
      if (typeof slidesGrid[i6 + 1] !== "undefined") {
        if (translate2 >= slidesGrid[i6] && translate2 < slidesGrid[i6 + 1] - (slidesGrid[i6 + 1] - slidesGrid[i6]) / 2) {
          activeIndex = i6;
        } else if (translate2 >= slidesGrid[i6] && translate2 < slidesGrid[i6 + 1]) {
          activeIndex = i6 + 1;
        }
      } else if (translate2 >= slidesGrid[i6]) {
        activeIndex = i6;
      }
    }
    if (params.normalizeSlideIndex) {
      if (activeIndex < 0 || typeof activeIndex === "undefined") activeIndex = 0;
    }
    return activeIndex;
  }
  function updateActiveIndex(newActiveIndex) {
    const swiper = this;
    const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    const {
      snapGrid,
      params,
      activeIndex: previousIndex,
      realIndex: previousRealIndex,
      snapIndex: previousSnapIndex
    } = swiper;
    let activeIndex = newActiveIndex;
    let snapIndex;
    const getVirtualRealIndex = (aIndex) => {
      let realIndex2 = aIndex - swiper.virtual.slidesBefore;
      if (realIndex2 < 0) {
        realIndex2 = swiper.virtual.slides.length + realIndex2;
      }
      if (realIndex2 >= swiper.virtual.slides.length) {
        realIndex2 -= swiper.virtual.slides.length;
      }
      return realIndex2;
    };
    if (typeof activeIndex === "undefined") {
      activeIndex = getActiveIndexByTranslate(swiper);
    }
    if (snapGrid.indexOf(translate2) >= 0) {
      snapIndex = snapGrid.indexOf(translate2);
    } else {
      const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
      snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
    }
    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
    if (activeIndex === previousIndex && !swiper.params.loop) {
      if (snapIndex !== previousSnapIndex) {
        swiper.snapIndex = snapIndex;
        swiper.emit("snapIndexChange");
      }
      return;
    }
    if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
      swiper.realIndex = getVirtualRealIndex(activeIndex);
      return;
    }
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    let realIndex;
    if (swiper.virtual && params.virtual.enabled && params.loop) {
      realIndex = getVirtualRealIndex(activeIndex);
    } else if (gridEnabled) {
      const firstSlideInColumn = swiper.slides.filter((slideEl) => slideEl.column === activeIndex)[0];
      let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute("data-swiper-slide-index"), 10);
      if (Number.isNaN(activeSlideIndex)) {
        activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);
      }
      realIndex = Math.floor(activeSlideIndex / params.grid.rows);
    } else if (swiper.slides[activeIndex]) {
      const slideIndex = swiper.slides[activeIndex].getAttribute("data-swiper-slide-index");
      if (slideIndex) {
        realIndex = parseInt(slideIndex, 10);
      } else {
        realIndex = activeIndex;
      }
    } else {
      realIndex = activeIndex;
    }
    Object.assign(swiper, {
      previousSnapIndex,
      snapIndex,
      previousRealIndex,
      realIndex,
      previousIndex,
      activeIndex
    });
    if (swiper.initialized) {
      preload(swiper);
    }
    swiper.emit("activeIndexChange");
    swiper.emit("snapIndexChange");
    if (swiper.initialized || swiper.params.runCallbacksOnInit) {
      if (previousRealIndex !== realIndex) {
        swiper.emit("realIndexChange");
      }
      swiper.emit("slideChange");
    }
  }
  function updateClickedSlide(el, path) {
    const swiper = this;
    const params = swiper.params;
    let slide2 = el.closest(`.${params.slideClass}, swiper-slide`);
    if (!slide2 && swiper.isElement && path && path.length > 1 && path.includes(el)) {
      [...path.slice(path.indexOf(el) + 1, path.length)].forEach((pathEl) => {
        if (!slide2 && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {
          slide2 = pathEl;
        }
      });
    }
    let slideFound = false;
    let slideIndex;
    if (slide2) {
      for (let i6 = 0; i6 < swiper.slides.length; i6 += 1) {
        if (swiper.slides[i6] === slide2) {
          slideFound = true;
          slideIndex = i6;
          break;
        }
      }
    }
    if (slide2 && slideFound) {
      swiper.clickedSlide = slide2;
      if (swiper.virtual && swiper.params.virtual.enabled) {
        swiper.clickedIndex = parseInt(slide2.getAttribute("data-swiper-slide-index"), 10);
      } else {
        swiper.clickedIndex = slideIndex;
      }
    } else {
      swiper.clickedSlide = void 0;
      swiper.clickedIndex = void 0;
      return;
    }
    if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) {
      swiper.slideToClickedSlide();
    }
  }
  var update = {
    updateSize,
    updateSlides,
    updateAutoHeight,
    updateSlidesOffset,
    updateSlidesProgress,
    updateProgress,
    updateSlidesClasses,
    updateActiveIndex,
    updateClickedSlide
  };
  function getSwiperTranslate(axis) {
    if (axis === void 0) {
      axis = this.isHorizontal() ? "x" : "y";
    }
    const swiper = this;
    const {
      params,
      rtlTranslate: rtl,
      translate: translate2,
      wrapperEl
    } = swiper;
    if (params.virtualTranslate) {
      return rtl ? -translate2 : translate2;
    }
    if (params.cssMode) {
      return translate2;
    }
    let currentTranslate = getTranslate(wrapperEl, axis);
    currentTranslate += swiper.cssOverflowAdjustment();
    if (rtl) currentTranslate = -currentTranslate;
    return currentTranslate || 0;
  }
  function setTranslate(translate2, byController) {
    const swiper = this;
    const {
      rtlTranslate: rtl,
      params,
      wrapperEl,
      progress
    } = swiper;
    let x3 = 0;
    let y3 = 0;
    const z2 = 0;
    if (swiper.isHorizontal()) {
      x3 = rtl ? -translate2 : translate2;
    } else {
      y3 = translate2;
    }
    if (params.roundLengths) {
      x3 = Math.floor(x3);
      y3 = Math.floor(y3);
    }
    swiper.previousTranslate = swiper.translate;
    swiper.translate = swiper.isHorizontal() ? x3 : y3;
    if (params.cssMode) {
      wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x3 : -y3;
    } else if (!params.virtualTranslate) {
      if (swiper.isHorizontal()) {
        x3 -= swiper.cssOverflowAdjustment();
      } else {
        y3 -= swiper.cssOverflowAdjustment();
      }
      wrapperEl.style.transform = `translate3d(${x3}px, ${y3}px, ${z2}px)`;
    }
    let newProgress;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (translate2 - swiper.minTranslate()) / translatesDiff;
    }
    if (newProgress !== progress) {
      swiper.updateProgress(translate2);
    }
    swiper.emit("setTranslate", swiper.translate, byController);
  }
  function minTranslate() {
    return -this.snapGrid[0];
  }
  function maxTranslate() {
    return -this.snapGrid[this.snapGrid.length - 1];
  }
  function translateTo(translate2, speed, runCallbacks, translateBounds, internal) {
    if (translate2 === void 0) {
      translate2 = 0;
    }
    if (speed === void 0) {
      speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    if (translateBounds === void 0) {
      translateBounds = true;
    }
    const swiper = this;
    const {
      params,
      wrapperEl
    } = swiper;
    if (swiper.animating && params.preventInteractionOnTransition) {
      return false;
    }
    const minTranslate2 = swiper.minTranslate();
    const maxTranslate2 = swiper.maxTranslate();
    let newTranslate;
    if (translateBounds && translate2 > minTranslate2) newTranslate = minTranslate2;
    else if (translateBounds && translate2 < maxTranslate2) newTranslate = maxTranslate2;
    else newTranslate = translate2;
    swiper.updateProgress(newTranslate);
    if (params.cssMode) {
      const isH = swiper.isHorizontal();
      if (speed === 0) {
        wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
      } else {
        if (!swiper.support.smoothScroll) {
          animateCSSModeScroll({
            swiper,
            targetPosition: -newTranslate,
            side: isH ? "left" : "top"
          });
          return true;
        }
        wrapperEl.scrollTo({
          [isH ? "left" : "top"]: -newTranslate,
          behavior: "smooth"
        });
      }
      return true;
    }
    if (speed === 0) {
      swiper.setTransition(0);
      swiper.setTranslate(newTranslate);
      if (runCallbacks) {
        swiper.emit("beforeTransitionStart", speed, internal);
        swiper.emit("transitionEnd");
      }
    } else {
      swiper.setTransition(speed);
      swiper.setTranslate(newTranslate);
      if (runCallbacks) {
        swiper.emit("beforeTransitionStart", speed, internal);
        swiper.emit("transitionStart");
      }
      if (!swiper.animating) {
        swiper.animating = true;
        if (!swiper.onTranslateToWrapperTransitionEnd) {
          swiper.onTranslateToWrapperTransitionEnd = function transitionEnd2(e5) {
            if (!swiper || swiper.destroyed) return;
            if (e5.target !== this) return;
            swiper.wrapperEl.removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
            swiper.onTranslateToWrapperTransitionEnd = null;
            delete swiper.onTranslateToWrapperTransitionEnd;
            swiper.animating = false;
            if (runCallbacks) {
              swiper.emit("transitionEnd");
            }
          };
        }
        swiper.wrapperEl.addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
      }
    }
    return true;
  }
  var translate = {
    getTranslate: getSwiperTranslate,
    setTranslate,
    minTranslate,
    maxTranslate,
    translateTo
  };
  function setTransition(duration, byController) {
    const swiper = this;
    if (!swiper.params.cssMode) {
      swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
      swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : "";
    }
    swiper.emit("setTransition", duration, byController);
  }
  function transitionEmit(_ref) {
    let {
      swiper,
      runCallbacks,
      direction,
      step
    } = _ref;
    const {
      activeIndex,
      previousIndex
    } = swiper;
    let dir = direction;
    if (!dir) {
      if (activeIndex > previousIndex) dir = "next";
      else if (activeIndex < previousIndex) dir = "prev";
      else dir = "reset";
    }
    swiper.emit(`transition${step}`);
    if (runCallbacks && activeIndex !== previousIndex) {
      if (dir === "reset") {
        swiper.emit(`slideResetTransition${step}`);
        return;
      }
      swiper.emit(`slideChangeTransition${step}`);
      if (dir === "next") {
        swiper.emit(`slideNextTransition${step}`);
      } else {
        swiper.emit(`slidePrevTransition${step}`);
      }
    }
  }
  function transitionStart(runCallbacks, direction) {
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    const swiper = this;
    const {
      params
    } = swiper;
    if (params.cssMode) return;
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    transitionEmit({
      swiper,
      runCallbacks,
      direction,
      step: "Start"
    });
  }
  function transitionEnd(runCallbacks, direction) {
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    const swiper = this;
    const {
      params
    } = swiper;
    swiper.animating = false;
    if (params.cssMode) return;
    swiper.setTransition(0);
    transitionEmit({
      swiper,
      runCallbacks,
      direction,
      step: "End"
    });
  }
  var transition = {
    setTransition,
    transitionStart,
    transitionEnd
  };
  function slideTo(index2, speed, runCallbacks, internal, initial) {
    if (index2 === void 0) {
      index2 = 0;
    }
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    if (typeof index2 === "string") {
      index2 = parseInt(index2, 10);
    }
    const swiper = this;
    let slideIndex = index2;
    if (slideIndex < 0) slideIndex = 0;
    const {
      params,
      snapGrid,
      slidesGrid,
      previousIndex,
      activeIndex,
      rtlTranslate: rtl,
      wrapperEl,
      enabled
    } = swiper;
    if (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) {
      return false;
    }
    if (typeof speed === "undefined") {
      speed = swiper.params.speed;
    }
    const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
    let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
    const translate2 = -snapGrid[snapIndex];
    if (params.normalizeSlideIndex) {
      for (let i6 = 0; i6 < slidesGrid.length; i6 += 1) {
        const normalizedTranslate = -Math.floor(translate2 * 100);
        const normalizedGrid = Math.floor(slidesGrid[i6] * 100);
        const normalizedGridNext = Math.floor(slidesGrid[i6 + 1] * 100);
        if (typeof slidesGrid[i6 + 1] !== "undefined") {
          if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
            slideIndex = i6;
          } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
            slideIndex = i6 + 1;
          }
        } else if (normalizedTranslate >= normalizedGrid) {
          slideIndex = i6;
        }
      }
    }
    if (swiper.initialized && slideIndex !== activeIndex) {
      if (!swiper.allowSlideNext && (rtl ? translate2 > swiper.translate && translate2 > swiper.minTranslate() : translate2 < swiper.translate && translate2 < swiper.minTranslate())) {
        return false;
      }
      if (!swiper.allowSlidePrev && translate2 > swiper.translate && translate2 > swiper.maxTranslate()) {
        if ((activeIndex || 0) !== slideIndex) {
          return false;
        }
      }
    }
    if (slideIndex !== (previousIndex || 0) && runCallbacks) {
      swiper.emit("beforeSlideChangeStart");
    }
    swiper.updateProgress(translate2);
    let direction;
    if (slideIndex > activeIndex) direction = "next";
    else if (slideIndex < activeIndex) direction = "prev";
    else direction = "reset";
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    const isInitialVirtual = isVirtual && initial;
    if (!isInitialVirtual && (rtl && -translate2 === swiper.translate || !rtl && translate2 === swiper.translate)) {
      swiper.updateActiveIndex(slideIndex);
      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }
      swiper.updateSlidesClasses();
      if (params.effect !== "slide") {
        swiper.setTranslate(translate2);
      }
      if (direction !== "reset") {
        swiper.transitionStart(runCallbacks, direction);
        swiper.transitionEnd(runCallbacks, direction);
      }
      return false;
    }
    if (params.cssMode) {
      const isH = swiper.isHorizontal();
      const t4 = rtl ? translate2 : -translate2;
      if (speed === 0) {
        if (isVirtual) {
          swiper.wrapperEl.style.scrollSnapType = "none";
          swiper._immediateVirtual = true;
        }
        if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
          swiper._cssModeVirtualInitialSet = true;
          requestAnimationFrame(() => {
            wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t4;
          });
        } else {
          wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t4;
        }
        if (isVirtual) {
          requestAnimationFrame(() => {
            swiper.wrapperEl.style.scrollSnapType = "";
            swiper._immediateVirtual = false;
          });
        }
      } else {
        if (!swiper.support.smoothScroll) {
          animateCSSModeScroll({
            swiper,
            targetPosition: t4,
            side: isH ? "left" : "top"
          });
          return true;
        }
        wrapperEl.scrollTo({
          [isH ? "left" : "top"]: t4,
          behavior: "smooth"
        });
      }
      return true;
    }
    swiper.setTransition(speed);
    swiper.setTranslate(translate2);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit("beforeTransitionStart", speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    if (speed === 0) {
      swiper.transitionEnd(runCallbacks, direction);
    } else if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onSlideToWrapperTransitionEnd) {
        swiper.onSlideToWrapperTransitionEnd = function transitionEnd2(e5) {
          if (!swiper || swiper.destroyed) return;
          if (e5.target !== this) return;
          swiper.wrapperEl.removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
          swiper.onSlideToWrapperTransitionEnd = null;
          delete swiper.onSlideToWrapperTransitionEnd;
          swiper.transitionEnd(runCallbacks, direction);
        };
      }
      swiper.wrapperEl.addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
    }
    return true;
  }
  function slideToLoop(index2, speed, runCallbacks, internal) {
    if (index2 === void 0) {
      index2 = 0;
    }
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    if (typeof index2 === "string") {
      const indexAsNumber = parseInt(index2, 10);
      index2 = indexAsNumber;
    }
    const swiper = this;
    if (swiper.destroyed) return;
    if (typeof speed === "undefined") {
      speed = swiper.params.speed;
    }
    const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
    let newIndex = index2;
    if (swiper.params.loop) {
      if (swiper.virtual && swiper.params.virtual.enabled) {
        newIndex = newIndex + swiper.virtual.slidesBefore;
      } else {
        let targetSlideIndex;
        if (gridEnabled) {
          const slideIndex = newIndex * swiper.params.grid.rows;
          targetSlideIndex = swiper.slides.filter((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex)[0].column;
        } else {
          targetSlideIndex = swiper.getSlideIndexByData(newIndex);
        }
        const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;
        const {
          centeredSlides
        } = swiper.params;
        let slidesPerView = swiper.params.slidesPerView;
        if (slidesPerView === "auto") {
          slidesPerView = swiper.slidesPerViewDynamic();
        } else {
          slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));
          if (centeredSlides && slidesPerView % 2 === 0) {
            slidesPerView = slidesPerView + 1;
          }
        }
        let needLoopFix = cols - targetSlideIndex < slidesPerView;
        if (centeredSlides) {
          needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);
        }
        if (internal && centeredSlides && swiper.params.slidesPerView !== "auto" && !gridEnabled) {
          needLoopFix = false;
        }
        if (needLoopFix) {
          const direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? "prev" : "next" : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? "next" : "prev";
          swiper.loopFix({
            direction,
            slideTo: true,
            activeSlideIndex: direction === "next" ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,
            slideRealIndex: direction === "next" ? swiper.realIndex : void 0
          });
        }
        if (gridEnabled) {
          const slideIndex = newIndex * swiper.params.grid.rows;
          newIndex = swiper.slides.filter((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex)[0].column;
        } else {
          newIndex = swiper.getSlideIndexByData(newIndex);
        }
      }
    }
    requestAnimationFrame(() => {
      swiper.slideTo(newIndex, speed, runCallbacks, internal);
    });
    return swiper;
  }
  function slideNext(speed, runCallbacks, internal) {
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    const swiper = this;
    const {
      enabled,
      params,
      animating
    } = swiper;
    if (!enabled || swiper.destroyed) return swiper;
    if (typeof speed === "undefined") {
      speed = swiper.params.speed;
    }
    let perGroup = params.slidesPerGroup;
    if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1);
    }
    const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    if (params.loop) {
      if (animating && !isVirtual && params.loopPreventsSliding) return false;
      swiper.loopFix({
        direction: "next"
      });
      swiper._clientLeft = swiper.wrapperEl.clientLeft;
      if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {
        requestAnimationFrame(() => {
          swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
        });
        return true;
      }
    }
    if (params.rewind && swiper.isEnd) {
      return swiper.slideTo(0, speed, runCallbacks, internal);
    }
    return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
  }
  function slidePrev(speed, runCallbacks, internal) {
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    const swiper = this;
    const {
      params,
      snapGrid,
      slidesGrid,
      rtlTranslate,
      enabled,
      animating
    } = swiper;
    if (!enabled || swiper.destroyed) return swiper;
    if (typeof speed === "undefined") {
      speed = swiper.params.speed;
    }
    const isVirtual = swiper.virtual && params.virtual.enabled;
    if (params.loop) {
      if (animating && !isVirtual && params.loopPreventsSliding) return false;
      swiper.loopFix({
        direction: "prev"
      });
      swiper._clientLeft = swiper.wrapperEl.clientLeft;
    }
    const translate2 = rtlTranslate ? swiper.translate : -swiper.translate;
    function normalize4(val2) {
      if (val2 < 0) return -Math.floor(Math.abs(val2));
      return Math.floor(val2);
    }
    const normalizedTranslate = normalize4(translate2);
    const normalizedSnapGrid = snapGrid.map((val2) => normalize4(val2));
    let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
    if (typeof prevSnap === "undefined" && params.cssMode) {
      let prevSnapIndex;
      snapGrid.forEach((snap3, snapIndex) => {
        if (normalizedTranslate >= snap3) {
          prevSnapIndex = snapIndex;
        }
      });
      if (typeof prevSnapIndex !== "undefined") {
        prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
      }
    }
    let prevIndex = 0;
    if (typeof prevSnap !== "undefined") {
      prevIndex = slidesGrid.indexOf(prevSnap);
      if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
      if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
        prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
        prevIndex = Math.max(prevIndex, 0);
      }
    }
    if (params.rewind && swiper.isBeginning) {
      const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
      return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
    } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {
      requestAnimationFrame(() => {
        swiper.slideTo(prevIndex, speed, runCallbacks, internal);
      });
      return true;
    }
    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
  }
  function slideReset(speed, runCallbacks, internal) {
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    const swiper = this;
    if (swiper.destroyed) return;
    if (typeof speed === "undefined") {
      speed = swiper.params.speed;
    }
    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
  }
  function slideToClosest(speed, runCallbacks, internal, threshold) {
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    if (threshold === void 0) {
      threshold = 0.5;
    }
    const swiper = this;
    if (swiper.destroyed) return;
    if (typeof speed === "undefined") {
      speed = swiper.params.speed;
    }
    let index2 = swiper.activeIndex;
    const skip = Math.min(swiper.params.slidesPerGroupSkip, index2);
    const snapIndex = skip + Math.floor((index2 - skip) / swiper.params.slidesPerGroup);
    const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    if (translate2 >= swiper.snapGrid[snapIndex]) {
      const currentSnap = swiper.snapGrid[snapIndex];
      const nextSnap = swiper.snapGrid[snapIndex + 1];
      if (translate2 - currentSnap > (nextSnap - currentSnap) * threshold) {
        index2 += swiper.params.slidesPerGroup;
      }
    } else {
      const prevSnap = swiper.snapGrid[snapIndex - 1];
      const currentSnap = swiper.snapGrid[snapIndex];
      if (translate2 - prevSnap <= (currentSnap - prevSnap) * threshold) {
        index2 -= swiper.params.slidesPerGroup;
      }
    }
    index2 = Math.max(index2, 0);
    index2 = Math.min(index2, swiper.slidesGrid.length - 1);
    return swiper.slideTo(index2, speed, runCallbacks, internal);
  }
  function slideToClickedSlide() {
    const swiper = this;
    if (swiper.destroyed) return;
    const {
      params,
      slidesEl
    } = swiper;
    const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
    let slideToIndex = swiper.clickedIndex;
    let realIndex;
    const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
    if (params.loop) {
      if (swiper.animating) return;
      realIndex = parseInt(swiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10);
      if (params.centeredSlides) {
        if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
          swiper.loopFix();
          slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
          nextTick(() => {
            swiper.slideTo(slideToIndex);
          });
        } else {
          swiper.slideTo(slideToIndex);
        }
      } else if (slideToIndex > swiper.slides.length - slidesPerView) {
        swiper.loopFix();
        slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
        nextTick(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else {
      swiper.slideTo(slideToIndex);
    }
  }
  var slide = {
    slideTo,
    slideToLoop,
    slideNext,
    slidePrev,
    slideReset,
    slideToClosest,
    slideToClickedSlide
  };
  function loopCreate(slideRealIndex) {
    const swiper = this;
    const {
      params,
      slidesEl
    } = swiper;
    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
    const initSlides = () => {
      const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
      slides.forEach((el, index2) => {
        el.setAttribute("data-swiper-slide-index", index2);
      });
    };
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);
    const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;
    const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;
    const addBlankSlides = (amountOfSlides) => {
      for (let i6 = 0; i6 < amountOfSlides; i6 += 1) {
        const slideEl = swiper.isElement ? createElement("swiper-slide", [params.slideBlankClass]) : createElement("div", [params.slideClass, params.slideBlankClass]);
        swiper.slidesEl.append(slideEl);
      }
    };
    if (shouldFillGroup) {
      if (params.loopAddBlankSlides) {
        const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;
        addBlankSlides(slidesToAdd);
        swiper.recalcSlides();
        swiper.updateSlides();
      } else {
        showWarning("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
      }
      initSlides();
    } else if (shouldFillGrid) {
      if (params.loopAddBlankSlides) {
        const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;
        addBlankSlides(slidesToAdd);
        swiper.recalcSlides();
        swiper.updateSlides();
      } else {
        showWarning("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
      }
      initSlides();
    } else {
      initSlides();
    }
    swiper.loopFix({
      slideRealIndex,
      direction: params.centeredSlides ? void 0 : "next"
    });
  }
  function loopFix(_temp) {
    let {
      slideRealIndex,
      slideTo: slideTo2 = true,
      direction,
      setTranslate: setTranslate2,
      activeSlideIndex,
      byController,
      byMousewheel
    } = _temp === void 0 ? {} : _temp;
    const swiper = this;
    if (!swiper.params.loop) return;
    swiper.emit("beforeLoopFix");
    const {
      slides,
      allowSlidePrev,
      allowSlideNext,
      slidesEl,
      params
    } = swiper;
    const {
      centeredSlides
    } = params;
    swiper.allowSlidePrev = true;
    swiper.allowSlideNext = true;
    if (swiper.virtual && params.virtual.enabled) {
      if (slideTo2) {
        if (!params.centeredSlides && swiper.snapIndex === 0) {
          swiper.slideTo(swiper.virtual.slides.length, 0, false, true);
        } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {
          swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);
        } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {
          swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
        }
      }
      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;
      swiper.emit("loopFix");
      return;
    }
    let slidesPerView = params.slidesPerView;
    if (slidesPerView === "auto") {
      slidesPerView = swiper.slidesPerViewDynamic();
    } else {
      slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));
      if (centeredSlides && slidesPerView % 2 === 0) {
        slidesPerView = slidesPerView + 1;
      }
    }
    const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;
    let loopedSlides = slidesPerGroup;
    if (loopedSlides % slidesPerGroup !== 0) {
      loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;
    }
    loopedSlides += params.loopAdditionalSlides;
    swiper.loopedSlides = loopedSlides;
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    if (slides.length < slidesPerView + loopedSlides) {
      showWarning("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters");
    } else if (gridEnabled && params.grid.fill === "row") {
      showWarning("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
    }
    const prependSlidesIndexes = [];
    const appendSlidesIndexes = [];
    let activeIndex = swiper.activeIndex;
    if (typeof activeSlideIndex === "undefined") {
      activeSlideIndex = swiper.getSlideIndex(slides.filter((el) => el.classList.contains(params.slideActiveClass))[0]);
    } else {
      activeIndex = activeSlideIndex;
    }
    const isNext = direction === "next" || !direction;
    const isPrev = direction === "prev" || !direction;
    let slidesPrepended = 0;
    let slidesAppended = 0;
    const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;
    const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;
    const activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate2 === "undefined" ? -slidesPerView / 2 + 0.5 : 0);
    if (activeColIndexWithShift < loopedSlides) {
      slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);
      for (let i6 = 0; i6 < loopedSlides - activeColIndexWithShift; i6 += 1) {
        const index2 = i6 - Math.floor(i6 / cols) * cols;
        if (gridEnabled) {
          const colIndexToPrepend = cols - index2 - 1;
          for (let i7 = slides.length - 1; i7 >= 0; i7 -= 1) {
            if (slides[i7].column === colIndexToPrepend) prependSlidesIndexes.push(i7);
          }
        } else {
          prependSlidesIndexes.push(cols - index2 - 1);
        }
      }
    } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {
      slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);
      for (let i6 = 0; i6 < slidesAppended; i6 += 1) {
        const index2 = i6 - Math.floor(i6 / cols) * cols;
        if (gridEnabled) {
          slides.forEach((slide2, slideIndex) => {
            if (slide2.column === index2) appendSlidesIndexes.push(slideIndex);
          });
        } else {
          appendSlidesIndexes.push(index2);
        }
      }
    }
    swiper.__preventObserver__ = true;
    requestAnimationFrame(() => {
      swiper.__preventObserver__ = false;
    });
    if (isPrev) {
      prependSlidesIndexes.forEach((index2) => {
        slides[index2].swiperLoopMoveDOM = true;
        slidesEl.prepend(slides[index2]);
        slides[index2].swiperLoopMoveDOM = false;
      });
    }
    if (isNext) {
      appendSlidesIndexes.forEach((index2) => {
        slides[index2].swiperLoopMoveDOM = true;
        slidesEl.append(slides[index2]);
        slides[index2].swiperLoopMoveDOM = false;
      });
    }
    swiper.recalcSlides();
    if (params.slidesPerView === "auto") {
      swiper.updateSlides();
    } else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {
      swiper.slides.forEach((slide2, slideIndex) => {
        swiper.grid.updateSlide(slideIndex, slide2, swiper.slides);
      });
    }
    if (params.watchSlidesProgress) {
      swiper.updateSlidesOffset();
    }
    if (slideTo2) {
      if (prependSlidesIndexes.length > 0 && isPrev) {
        if (typeof slideRealIndex === "undefined") {
          const currentSlideTranslate = swiper.slidesGrid[activeIndex];
          const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
          const diff = newSlideTranslate - currentSlideTranslate;
          if (byMousewheel) {
            swiper.setTranslate(swiper.translate - diff);
          } else {
            swiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);
            if (setTranslate2) {
              swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
              swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
            }
          }
        } else {
          if (setTranslate2) {
            const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;
            swiper.slideTo(swiper.activeIndex + shift, 0, false, true);
            swiper.touchEventsData.currentTranslate = swiper.translate;
          }
        }
      } else if (appendSlidesIndexes.length > 0 && isNext) {
        if (typeof slideRealIndex === "undefined") {
          const currentSlideTranslate = swiper.slidesGrid[activeIndex];
          const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
          const diff = newSlideTranslate - currentSlideTranslate;
          if (byMousewheel) {
            swiper.setTranslate(swiper.translate - diff);
          } else {
            swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
            if (setTranslate2) {
              swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
              swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
            }
          }
        } else {
          const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;
          swiper.slideTo(swiper.activeIndex - shift, 0, false, true);
        }
      }
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    if (swiper.controller && swiper.controller.control && !byController) {
      const loopParams = {
        slideRealIndex,
        direction,
        setTranslate: setTranslate2,
        activeSlideIndex,
        byController: true
      };
      if (Array.isArray(swiper.controller.control)) {
        swiper.controller.control.forEach((c4) => {
          if (!c4.destroyed && c4.params.loop) c4.loopFix(__spreadProps(__spreadValues({}, loopParams), {
            slideTo: c4.params.slidesPerView === params.slidesPerView ? slideTo2 : false
          }));
        });
      } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {
        swiper.controller.control.loopFix(__spreadProps(__spreadValues({}, loopParams), {
          slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo2 : false
        }));
      }
    }
    swiper.emit("loopFix");
  }
  function loopDestroy() {
    const swiper = this;
    const {
      params,
      slidesEl
    } = swiper;
    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
    swiper.recalcSlides();
    const newSlidesOrder = [];
    swiper.slides.forEach((slideEl) => {
      const index2 = typeof slideEl.swiperSlideIndex === "undefined" ? slideEl.getAttribute("data-swiper-slide-index") * 1 : slideEl.swiperSlideIndex;
      newSlidesOrder[index2] = slideEl;
    });
    swiper.slides.forEach((slideEl) => {
      slideEl.removeAttribute("data-swiper-slide-index");
    });
    newSlidesOrder.forEach((slideEl) => {
      slidesEl.append(slideEl);
    });
    swiper.recalcSlides();
    swiper.slideTo(swiper.realIndex, 0);
  }
  var loop = {
    loopCreate,
    loopFix,
    loopDestroy
  };
  function setGrabCursor(moving) {
    const swiper = this;
    if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
    const el = swiper.params.touchEventsTarget === "container" ? swiper.el : swiper.wrapperEl;
    if (swiper.isElement) {
      swiper.__preventObserver__ = true;
    }
    el.style.cursor = "move";
    el.style.cursor = moving ? "grabbing" : "grab";
    if (swiper.isElement) {
      requestAnimationFrame(() => {
        swiper.__preventObserver__ = false;
      });
    }
  }
  function unsetGrabCursor() {
    const swiper = this;
    if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
      return;
    }
    if (swiper.isElement) {
      swiper.__preventObserver__ = true;
    }
    swiper[swiper.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
    if (swiper.isElement) {
      requestAnimationFrame(() => {
        swiper.__preventObserver__ = false;
      });
    }
  }
  var grabCursor = {
    setGrabCursor,
    unsetGrabCursor
  };
  function closestElement(selector3, base) {
    if (base === void 0) {
      base = this;
    }
    function __closestFrom(el) {
      if (!el || el === getDocument() || el === getWindow()) return null;
      if (el.assignedSlot) el = el.assignedSlot;
      const found = el.closest(selector3);
      if (!found && !el.getRootNode) {
        return null;
      }
      return found || __closestFrom(el.getRootNode().host);
    }
    return __closestFrom(base);
  }
  function preventEdgeSwipe(swiper, event2, startX) {
    const window2 = getWindow();
    const {
      params
    } = swiper;
    const edgeSwipeDetection = params.edgeSwipeDetection;
    const edgeSwipeThreshold = params.edgeSwipeThreshold;
    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {
      if (edgeSwipeDetection === "prevent") {
        event2.preventDefault();
        return true;
      }
      return false;
    }
    return true;
  }
  function onTouchStart(event2) {
    const swiper = this;
    const document2 = getDocument();
    let e5 = event2;
    if (e5.originalEvent) e5 = e5.originalEvent;
    const data2 = swiper.touchEventsData;
    if (e5.type === "pointerdown") {
      if (data2.pointerId !== null && data2.pointerId !== e5.pointerId) {
        return;
      }
      data2.pointerId = e5.pointerId;
    } else if (e5.type === "touchstart" && e5.targetTouches.length === 1) {
      data2.touchId = e5.targetTouches[0].identifier;
    }
    if (e5.type === "touchstart") {
      preventEdgeSwipe(swiper, e5, e5.targetTouches[0].pageX);
      return;
    }
    const {
      params,
      touches,
      enabled
    } = swiper;
    if (!enabled) return;
    if (!params.simulateTouch && e5.pointerType === "mouse") return;
    if (swiper.animating && params.preventInteractionOnTransition) {
      return;
    }
    if (!swiper.animating && params.cssMode && params.loop) {
      swiper.loopFix();
    }
    let targetEl = e5.target;
    if (params.touchEventsTarget === "wrapper") {
      if (!elementIsChildOf(targetEl, swiper.wrapperEl)) return;
    }
    if ("which" in e5 && e5.which === 3) return;
    if ("button" in e5 && e5.button > 0) return;
    if (data2.isTouched && data2.isMoved) return;
    const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
    const eventPath = e5.composedPath ? e5.composedPath() : e5.path;
    if (swipingClassHasValue && e5.target && e5.target.shadowRoot && eventPath) {
      targetEl = eventPath[0];
    }
    const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
    const isTargetShadow = !!(e5.target && e5.target.shadowRoot);
    if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
      swiper.allowClick = true;
      return;
    }
    if (params.swipeHandler) {
      if (!targetEl.closest(params.swipeHandler)) return;
    }
    touches.currentX = e5.pageX;
    touches.currentY = e5.pageY;
    const startX = touches.currentX;
    const startY = touches.currentY;
    if (!preventEdgeSwipe(swiper, e5, startX)) {
      return;
    }
    Object.assign(data2, {
      isTouched: true,
      isMoved: false,
      allowTouchCallbacks: true,
      isScrolling: void 0,
      startMoving: void 0
    });
    touches.startX = startX;
    touches.startY = startY;
    data2.touchStartTime = now();
    swiper.allowClick = true;
    swiper.updateSize();
    swiper.swipeDirection = void 0;
    if (params.threshold > 0) data2.allowThresholdMove = false;
    let preventDefault = true;
    if (targetEl.matches(data2.focusableElements)) {
      preventDefault = false;
      if (targetEl.nodeName === "SELECT") {
        data2.isTouched = false;
      }
    }
    if (document2.activeElement && document2.activeElement.matches(data2.focusableElements) && document2.activeElement !== targetEl && (e5.pointerType === "mouse" || e5.pointerType !== "mouse" && !targetEl.matches(data2.focusableElements))) {
      document2.activeElement.blur();
    }
    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
      e5.preventDefault();
    }
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
      swiper.freeMode.onTouchStart();
    }
    swiper.emit("touchStart", e5);
  }
  function onTouchMove(event2) {
    const document2 = getDocument();
    const swiper = this;
    const data2 = swiper.touchEventsData;
    const {
      params,
      touches,
      rtlTranslate: rtl,
      enabled
    } = swiper;
    if (!enabled) return;
    if (!params.simulateTouch && event2.pointerType === "mouse") return;
    let e5 = event2;
    if (e5.originalEvent) e5 = e5.originalEvent;
    if (e5.type === "pointermove") {
      if (data2.touchId !== null) return;
      const id = e5.pointerId;
      if (id !== data2.pointerId) return;
    }
    let targetTouch;
    if (e5.type === "touchmove") {
      targetTouch = [...e5.changedTouches].filter((t4) => t4.identifier === data2.touchId)[0];
      if (!targetTouch || targetTouch.identifier !== data2.touchId) return;
    } else {
      targetTouch = e5;
    }
    if (!data2.isTouched) {
      if (data2.startMoving && data2.isScrolling) {
        swiper.emit("touchMoveOpposite", e5);
      }
      return;
    }
    const pageX = targetTouch.pageX;
    const pageY = targetTouch.pageY;
    if (e5.preventedByNestedSwiper) {
      touches.startX = pageX;
      touches.startY = pageY;
      return;
    }
    if (!swiper.allowTouchMove) {
      if (!e5.target.matches(data2.focusableElements)) {
        swiper.allowClick = false;
      }
      if (data2.isTouched) {
        Object.assign(touches, {
          startX: pageX,
          startY: pageY,
          currentX: pageX,
          currentY: pageY
        });
        data2.touchStartTime = now();
      }
      return;
    }
    if (params.touchReleaseOnEdges && !params.loop) {
      if (swiper.isVertical()) {
        if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
          data2.isTouched = false;
          data2.isMoved = false;
          return;
        }
      } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
        return;
      }
    }
    if (document2.activeElement && document2.activeElement.matches(data2.focusableElements) && document2.activeElement !== e5.target && e5.pointerType !== "mouse") {
      document2.activeElement.blur();
    }
    if (document2.activeElement) {
      if (e5.target === document2.activeElement && e5.target.matches(data2.focusableElements)) {
        data2.isMoved = true;
        swiper.allowClick = false;
        return;
      }
    }
    if (data2.allowTouchCallbacks) {
      swiper.emit("touchMove", e5);
    }
    touches.previousX = touches.currentX;
    touches.previousY = touches.currentY;
    touches.currentX = pageX;
    touches.currentY = pageY;
    const diffX = touches.currentX - touches.startX;
    const diffY = touches.currentY - touches.startY;
    if (swiper.params.threshold && Math.sqrt(__pow(diffX, 2) + __pow(diffY, 2)) < swiper.params.threshold) return;
    if (typeof data2.isScrolling === "undefined") {
      let touchAngle;
      if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
        data2.isScrolling = false;
      } else {
        if (diffX * diffX + diffY * diffY >= 25) {
          touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
          data2.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
        }
      }
    }
    if (data2.isScrolling) {
      swiper.emit("touchMoveOpposite", e5);
    }
    if (typeof data2.startMoving === "undefined") {
      if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
        data2.startMoving = true;
      }
    }
    if (data2.isScrolling || e5.type === "touchmove" && data2.preventTouchMoveFromPointerMove) {
      data2.isTouched = false;
      return;
    }
    if (!data2.startMoving) {
      return;
    }
    swiper.allowClick = false;
    if (!params.cssMode && e5.cancelable) {
      e5.preventDefault();
    }
    if (params.touchMoveStopPropagation && !params.nested) {
      e5.stopPropagation();
    }
    let diff = swiper.isHorizontal() ? diffX : diffY;
    let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
    if (params.oneWayMovement) {
      diff = Math.abs(diff) * (rtl ? 1 : -1);
      touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
    }
    touches.diff = diff;
    diff *= params.touchRatio;
    if (rtl) {
      diff = -diff;
      touchesDiff = -touchesDiff;
    }
    const prevTouchesDirection = swiper.touchesDirection;
    swiper.swipeDirection = diff > 0 ? "prev" : "next";
    swiper.touchesDirection = touchesDiff > 0 ? "prev" : "next";
    const isLoop = swiper.params.loop && !params.cssMode;
    const allowLoopFix = swiper.touchesDirection === "next" && swiper.allowSlideNext || swiper.touchesDirection === "prev" && swiper.allowSlidePrev;
    if (!data2.isMoved) {
      if (isLoop && allowLoopFix) {
        swiper.loopFix({
          direction: swiper.swipeDirection
        });
      }
      data2.startTranslate = swiper.getTranslate();
      swiper.setTransition(0);
      if (swiper.animating) {
        const evt = new window.CustomEvent("transitionend", {
          bubbles: true,
          cancelable: true,
          detail: {
            bySwiperTouchMove: true
          }
        });
        swiper.wrapperEl.dispatchEvent(evt);
      }
      data2.allowMomentumBounce = false;
      if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(true);
      }
      swiper.emit("sliderFirstMove", e5);
    }
    let loopFixed;
    (/* @__PURE__ */ new Date()).getTime();
    if (data2.isMoved && data2.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
      Object.assign(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY,
        startTranslate: data2.currentTranslate
      });
      data2.loopSwapReset = true;
      data2.startTranslate = data2.currentTranslate;
      return;
    }
    swiper.emit("sliderMove", e5);
    data2.isMoved = true;
    data2.currentTranslate = diff + data2.startTranslate;
    let disableParentSwiper = true;
    let resistanceRatio = params.resistanceRatio;
    if (params.touchReleaseOnEdges) {
      resistanceRatio = 0;
    }
    if (diff > 0) {
      if (isLoop && allowLoopFix && !loopFixed && data2.allowThresholdMove && data2.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] - (params.slidesPerView !== "auto" && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.activeIndex + 1] + swiper.params.spaceBetween : 0) - swiper.params.spaceBetween : swiper.minTranslate())) {
        swiper.loopFix({
          direction: "prev",
          setTranslate: true,
          activeSlideIndex: 0
        });
      }
      if (data2.currentTranslate > swiper.minTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) {
          data2.currentTranslate = swiper.minTranslate() - 1 + __pow(-swiper.minTranslate() + data2.startTranslate + diff, resistanceRatio);
        }
      }
    } else if (diff < 0) {
      if (isLoop && allowLoopFix && !loopFixed && data2.allowThresholdMove && data2.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween + (params.slidesPerView !== "auto" && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween : 0) : swiper.maxTranslate())) {
        swiper.loopFix({
          direction: "next",
          setTranslate: true,
          activeSlideIndex: swiper.slides.length - (params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
        });
      }
      if (data2.currentTranslate < swiper.maxTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) {
          data2.currentTranslate = swiper.maxTranslate() + 1 - __pow(swiper.maxTranslate() - data2.startTranslate - diff, resistanceRatio);
        }
      }
    }
    if (disableParentSwiper) {
      e5.preventedByNestedSwiper = true;
    }
    if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data2.currentTranslate < data2.startTranslate) {
      data2.currentTranslate = data2.startTranslate;
    }
    if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data2.currentTranslate > data2.startTranslate) {
      data2.currentTranslate = data2.startTranslate;
    }
    if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
      data2.currentTranslate = data2.startTranslate;
    }
    if (params.threshold > 0) {
      if (Math.abs(diff) > params.threshold || data2.allowThresholdMove) {
        if (!data2.allowThresholdMove) {
          data2.allowThresholdMove = true;
          touches.startX = touches.currentX;
          touches.startY = touches.currentY;
          data2.currentTranslate = data2.startTranslate;
          touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
          return;
        }
      } else {
        data2.currentTranslate = data2.startTranslate;
        return;
      }
    }
    if (!params.followFinger || params.cssMode) return;
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {
      swiper.freeMode.onTouchMove();
    }
    swiper.updateProgress(data2.currentTranslate);
    swiper.setTranslate(data2.currentTranslate);
  }
  function onTouchEnd(event2) {
    const swiper = this;
    const data2 = swiper.touchEventsData;
    let e5 = event2;
    if (e5.originalEvent) e5 = e5.originalEvent;
    let targetTouch;
    const isTouchEvent = e5.type === "touchend" || e5.type === "touchcancel";
    if (!isTouchEvent) {
      if (data2.touchId !== null) return;
      if (e5.pointerId !== data2.pointerId) return;
      targetTouch = e5;
    } else {
      targetTouch = [...e5.changedTouches].filter((t4) => t4.identifier === data2.touchId)[0];
      if (!targetTouch || targetTouch.identifier !== data2.touchId) return;
    }
    if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(e5.type)) {
      const proceed = ["pointercancel", "contextmenu"].includes(e5.type) && (swiper.browser.isSafari || swiper.browser.isWebView);
      if (!proceed) {
        return;
      }
    }
    data2.pointerId = null;
    data2.touchId = null;
    const {
      params,
      touches,
      rtlTranslate: rtl,
      slidesGrid,
      enabled
    } = swiper;
    if (!enabled) return;
    if (!params.simulateTouch && e5.pointerType === "mouse") return;
    if (data2.allowTouchCallbacks) {
      swiper.emit("touchEnd", e5);
    }
    data2.allowTouchCallbacks = false;
    if (!data2.isTouched) {
      if (data2.isMoved && params.grabCursor) {
        swiper.setGrabCursor(false);
      }
      data2.isMoved = false;
      data2.startMoving = false;
      return;
    }
    if (params.grabCursor && data2.isMoved && data2.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(false);
    }
    const touchEndTime = now();
    const timeDiff = touchEndTime - data2.touchStartTime;
    if (swiper.allowClick) {
      const pathTree = e5.path || e5.composedPath && e5.composedPath();
      swiper.updateClickedSlide(pathTree && pathTree[0] || e5.target, pathTree);
      swiper.emit("tap click", e5);
      if (timeDiff < 300 && touchEndTime - data2.lastClickTime < 300) {
        swiper.emit("doubleTap doubleClick", e5);
      }
    }
    data2.lastClickTime = now();
    nextTick(() => {
      if (!swiper.destroyed) swiper.allowClick = true;
    });
    if (!data2.isTouched || !data2.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data2.loopSwapReset || data2.currentTranslate === data2.startTranslate && !data2.loopSwapReset) {
      data2.isTouched = false;
      data2.isMoved = false;
      data2.startMoving = false;
      return;
    }
    data2.isTouched = false;
    data2.isMoved = false;
    data2.startMoving = false;
    let currentPos;
    if (params.followFinger) {
      currentPos = rtl ? swiper.translate : -swiper.translate;
    } else {
      currentPos = -data2.currentTranslate;
    }
    if (params.cssMode) {
      return;
    }
    if (params.freeMode && params.freeMode.enabled) {
      swiper.freeMode.onTouchEnd({
        currentPos
      });
      return;
    }
    const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;
    let stopIndex = 0;
    let groupSize = swiper.slidesSizesGrid[0];
    for (let i6 = 0; i6 < slidesGrid.length; i6 += i6 < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
      const increment2 = i6 < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
      if (typeof slidesGrid[i6 + increment2] !== "undefined") {
        if (swipeToLast || currentPos >= slidesGrid[i6] && currentPos < slidesGrid[i6 + increment2]) {
          stopIndex = i6;
          groupSize = slidesGrid[i6 + increment2] - slidesGrid[i6];
        }
      } else if (swipeToLast || currentPos >= slidesGrid[i6]) {
        stopIndex = i6;
        groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
      }
    }
    let rewindFirstIndex = null;
    let rewindLastIndex = null;
    if (params.rewind) {
      if (swiper.isBeginning) {
        rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
      } else if (swiper.isEnd) {
        rewindFirstIndex = 0;
      }
    }
    const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
    const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (timeDiff > params.longSwipesMs) {
      if (!params.longSwipes) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }
      if (swiper.swipeDirection === "next") {
        if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);
        else swiper.slideTo(stopIndex);
      }
      if (swiper.swipeDirection === "prev") {
        if (ratio > 1 - params.longSwipesRatio) {
          swiper.slideTo(stopIndex + increment);
        } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
          swiper.slideTo(rewindLastIndex);
        } else {
          swiper.slideTo(stopIndex);
        }
      }
    } else {
      if (!params.shortSwipes) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }
      const isNavButtonTarget = swiper.navigation && (e5.target === swiper.navigation.nextEl || e5.target === swiper.navigation.prevEl);
      if (!isNavButtonTarget) {
        if (swiper.swipeDirection === "next") {
          swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
        }
        if (swiper.swipeDirection === "prev") {
          swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
        }
      } else if (e5.target === swiper.navigation.nextEl) {
        swiper.slideTo(stopIndex + increment);
      } else {
        swiper.slideTo(stopIndex);
      }
    }
  }
  function onResize() {
    const swiper = this;
    const {
      params,
      el
    } = swiper;
    if (el && el.offsetWidth === 0) return;
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    const {
      allowSlideNext,
      allowSlidePrev,
      snapGrid
    } = swiper;
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    swiper.allowSlideNext = true;
    swiper.allowSlidePrev = true;
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateSlidesClasses();
    const isVirtualLoop = isVirtual && params.loop;
    if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {
      swiper.slideTo(swiper.slides.length - 1, 0, false, true);
    } else {
      if (swiper.params.loop && !isVirtual) {
        swiper.slideToLoop(swiper.realIndex, 0, false, true);
      } else {
        swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
    }
    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
      clearTimeout(swiper.autoplay.resizeTimeout);
      swiper.autoplay.resizeTimeout = setTimeout(() => {
        if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
          swiper.autoplay.resume();
        }
      }, 500);
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
  }
  function onClick(e5) {
    const swiper = this;
    if (!swiper.enabled) return;
    if (!swiper.allowClick) {
      if (swiper.params.preventClicks) e5.preventDefault();
      if (swiper.params.preventClicksPropagation && swiper.animating) {
        e5.stopPropagation();
        e5.stopImmediatePropagation();
      }
    }
  }
  function onScroll() {
    const swiper = this;
    const {
      wrapperEl,
      rtlTranslate,
      enabled
    } = swiper;
    if (!enabled) return;
    swiper.previousTranslate = swiper.translate;
    if (swiper.isHorizontal()) {
      swiper.translate = -wrapperEl.scrollLeft;
    } else {
      swiper.translate = -wrapperEl.scrollTop;
    }
    if (swiper.translate === 0) swiper.translate = 0;
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
    let newProgress;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
    }
    if (newProgress !== swiper.progress) {
      swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
    }
    swiper.emit("setTranslate", swiper.translate, false);
  }
  function onLoad(e5) {
    const swiper = this;
    processLazyPreloader(swiper, e5.target);
    if (swiper.params.cssMode || swiper.params.slidesPerView !== "auto" && !swiper.params.autoHeight) {
      return;
    }
    swiper.update();
  }
  function onDocumentTouchStart() {
    const swiper = this;
    if (swiper.documentTouchHandlerProceeded) return;
    swiper.documentTouchHandlerProceeded = true;
    if (swiper.params.touchReleaseOnEdges) {
      swiper.el.style.touchAction = "auto";
    }
  }
  var events = (swiper, method) => {
    const document2 = getDocument();
    const {
      params,
      el,
      wrapperEl,
      device
    } = swiper;
    const capture = !!params.nested;
    const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
    const swiperMethod = method;
    if (!el || typeof el === "string") return;
    document2[domMethod]("touchstart", swiper.onDocumentTouchStart, {
      passive: false,
      capture
    });
    el[domMethod]("touchstart", swiper.onTouchStart, {
      passive: false
    });
    el[domMethod]("pointerdown", swiper.onTouchStart, {
      passive: false
    });
    document2[domMethod]("touchmove", swiper.onTouchMove, {
      passive: false,
      capture
    });
    document2[domMethod]("pointermove", swiper.onTouchMove, {
      passive: false,
      capture
    });
    document2[domMethod]("touchend", swiper.onTouchEnd, {
      passive: true
    });
    document2[domMethod]("pointerup", swiper.onTouchEnd, {
      passive: true
    });
    document2[domMethod]("pointercancel", swiper.onTouchEnd, {
      passive: true
    });
    document2[domMethod]("touchcancel", swiper.onTouchEnd, {
      passive: true
    });
    document2[domMethod]("pointerout", swiper.onTouchEnd, {
      passive: true
    });
    document2[domMethod]("pointerleave", swiper.onTouchEnd, {
      passive: true
    });
    document2[domMethod]("contextmenu", swiper.onTouchEnd, {
      passive: true
    });
    if (params.preventClicks || params.preventClicksPropagation) {
      el[domMethod]("click", swiper.onClick, true);
    }
    if (params.cssMode) {
      wrapperEl[domMethod]("scroll", swiper.onScroll);
    }
    if (params.updateOnWindowResize) {
      swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true);
    } else {
      swiper[swiperMethod]("observerUpdate", onResize, true);
    }
    el[domMethod]("load", swiper.onLoad, {
      capture: true
    });
  };
  function attachEvents() {
    const swiper = this;
    const {
      params
    } = swiper;
    swiper.onTouchStart = onTouchStart.bind(swiper);
    swiper.onTouchMove = onTouchMove.bind(swiper);
    swiper.onTouchEnd = onTouchEnd.bind(swiper);
    swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);
    if (params.cssMode) {
      swiper.onScroll = onScroll.bind(swiper);
    }
    swiper.onClick = onClick.bind(swiper);
    swiper.onLoad = onLoad.bind(swiper);
    events(swiper, "on");
  }
  function detachEvents() {
    const swiper = this;
    events(swiper, "off");
  }
  var events$1 = {
    attachEvents,
    detachEvents
  };
  var isGridEnabled = (swiper, params) => {
    return swiper.grid && params.grid && params.grid.rows > 1;
  };
  function setBreakpoint() {
    const swiper = this;
    const {
      realIndex,
      initialized,
      params,
      el
    } = swiper;
    const breakpoints2 = params.breakpoints;
    if (!breakpoints2 || breakpoints2 && Object.keys(breakpoints2).length === 0) return;
    const breakpoint = swiper.getBreakpoint(breakpoints2, swiper.params.breakpointsBase, swiper.el);
    if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
    const breakpointOnlyParams = breakpoint in breakpoints2 ? breakpoints2[breakpoint] : void 0;
    const breakpointParams = breakpointOnlyParams || swiper.originalParams;
    const wasMultiRow = isGridEnabled(swiper, params);
    const isMultiRow = isGridEnabled(swiper, breakpointParams);
    const wasGrabCursor = swiper.params.grabCursor;
    const isGrabCursor = breakpointParams.grabCursor;
    const wasEnabled = params.enabled;
    if (wasMultiRow && !isMultiRow) {
      el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
      swiper.emitContainerClasses();
    } else if (!wasMultiRow && isMultiRow) {
      el.classList.add(`${params.containerModifierClass}grid`);
      if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") {
        el.classList.add(`${params.containerModifierClass}grid-column`);
      }
      swiper.emitContainerClasses();
    }
    if (wasGrabCursor && !isGrabCursor) {
      swiper.unsetGrabCursor();
    } else if (!wasGrabCursor && isGrabCursor) {
      swiper.setGrabCursor();
    }
    ["navigation", "pagination", "scrollbar"].forEach((prop) => {
      if (typeof breakpointParams[prop] === "undefined") return;
      const wasModuleEnabled = params[prop] && params[prop].enabled;
      const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
      if (wasModuleEnabled && !isModuleEnabled) {
        swiper[prop].disable();
      }
      if (!wasModuleEnabled && isModuleEnabled) {
        swiper[prop].enable();
      }
    });
    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
    const wasLoop = params.loop;
    if (directionChanged && initialized) {
      swiper.changeDirection();
    }
    extend2(swiper.params, breakpointParams);
    const isEnabled = swiper.params.enabled;
    const hasLoop = swiper.params.loop;
    Object.assign(swiper, {
      allowTouchMove: swiper.params.allowTouchMove,
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev
    });
    if (wasEnabled && !isEnabled) {
      swiper.disable();
    } else if (!wasEnabled && isEnabled) {
      swiper.enable();
    }
    swiper.currentBreakpoint = breakpoint;
    swiper.emit("_beforeBreakpoint", breakpointParams);
    if (initialized) {
      if (needsReLoop) {
        swiper.loopDestroy();
        swiper.loopCreate(realIndex);
        swiper.updateSlides();
      } else if (!wasLoop && hasLoop) {
        swiper.loopCreate(realIndex);
        swiper.updateSlides();
      } else if (wasLoop && !hasLoop) {
        swiper.loopDestroy();
      }
    }
    swiper.emit("breakpoint", breakpointParams);
  }
  function getBreakpoint(breakpoints2, base, containerEl) {
    if (base === void 0) {
      base = "window";
    }
    if (!breakpoints2 || base === "container" && !containerEl) return void 0;
    let breakpoint = false;
    const window2 = getWindow();
    const currentHeight = base === "window" ? window2.innerHeight : containerEl.clientHeight;
    const points = Object.keys(breakpoints2).map((point) => {
      if (typeof point === "string" && point.indexOf("@") === 0) {
        const minRatio = parseFloat(point.substr(1));
        const value2 = currentHeight * minRatio;
        return {
          value: value2,
          point
        };
      }
      return {
        value: point,
        point
      };
    });
    points.sort((a5, b3) => parseInt(a5.value, 10) - parseInt(b3.value, 10));
    for (let i6 = 0; i6 < points.length; i6 += 1) {
      const {
        point,
        value: value2
      } = points[i6];
      if (base === "window") {
        if (window2.matchMedia(`(min-width: ${value2}px)`).matches) {
          breakpoint = point;
        }
      } else if (value2 <= containerEl.clientWidth) {
        breakpoint = point;
      }
    }
    return breakpoint || "max";
  }
  var breakpoints = {
    setBreakpoint,
    getBreakpoint
  };
  function prepareClasses(entries, prefix) {
    const resultClasses = [];
    entries.forEach((item) => {
      if (typeof item === "object") {
        Object.keys(item).forEach((classNames) => {
          if (item[classNames]) {
            resultClasses.push(prefix + classNames);
          }
        });
      } else if (typeof item === "string") {
        resultClasses.push(prefix + item);
      }
    });
    return resultClasses;
  }
  function addClasses() {
    const swiper = this;
    const {
      classNames,
      params,
      rtl,
      el,
      device
    } = swiper;
    const suffixes = prepareClasses(["initialized", params.direction, {
      "free-mode": swiper.params.freeMode && params.freeMode.enabled
    }, {
      "autoheight": params.autoHeight
    }, {
      "rtl": rtl
    }, {
      "grid": params.grid && params.grid.rows > 1
    }, {
      "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
    }, {
      "android": device.android
    }, {
      "ios": device.ios
    }, {
      "css-mode": params.cssMode
    }, {
      "centered": params.cssMode && params.centeredSlides
    }, {
      "watch-progress": params.watchSlidesProgress
    }], params.containerModifierClass);
    classNames.push(...suffixes);
    el.classList.add(...classNames);
    swiper.emitContainerClasses();
  }
  function removeClasses() {
    const swiper = this;
    const {
      el,
      classNames
    } = swiper;
    if (!el || typeof el === "string") return;
    el.classList.remove(...classNames);
    swiper.emitContainerClasses();
  }
  var classes = {
    addClasses,
    removeClasses
  };
  function checkOverflow() {
    const swiper = this;
    const {
      isLocked: wasLocked,
      params
    } = swiper;
    const {
      slidesOffsetBefore
    } = params;
    if (slidesOffsetBefore) {
      const lastSlideIndex = swiper.slides.length - 1;
      const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
      swiper.isLocked = swiper.size > lastSlideRightEdge;
    } else {
      swiper.isLocked = swiper.snapGrid.length === 1;
    }
    if (params.allowSlideNext === true) {
      swiper.allowSlideNext = !swiper.isLocked;
    }
    if (params.allowSlidePrev === true) {
      swiper.allowSlidePrev = !swiper.isLocked;
    }
    if (wasLocked && wasLocked !== swiper.isLocked) {
      swiper.isEnd = false;
    }
    if (wasLocked !== swiper.isLocked) {
      swiper.emit(swiper.isLocked ? "lock" : "unlock");
    }
  }
  var checkOverflow$1 = {
    checkOverflow
  };
  var defaults2 = {
    init: true,
    direction: "horizontal",
    oneWayMovement: false,
    swiperElementNodeName: "SWIPER-CONTAINER",
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: false,
    updateOnWindowResize: true,
    resizeObserver: true,
    nested: false,
    createElements: false,
    eventsPrefix: "swiper",
    enabled: true,
    focusableElements: "input, select, option, textarea, button, video, label",
    // Overrides
    width: null,
    height: null,
    //
    preventInteractionOnTransition: false,
    // ssr
    userAgent: null,
    url: null,
    // To support iOS's swipe-to-go-back gesture (when being used in-app).
    edgeSwipeDetection: false,
    edgeSwipeThreshold: 20,
    // Autoheight
    autoHeight: false,
    // Set wrapper width
    setWrapperSize: false,
    // Virtual Translate
    virtualTranslate: false,
    // Effects
    effect: "slide",
    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
    // Breakpoints
    breakpoints: void 0,
    breakpointsBase: "window",
    // Slides grid
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: false,
    centeredSlides: false,
    centeredSlidesBounds: false,
    slidesOffsetBefore: 0,
    // in px
    slidesOffsetAfter: 0,
    // in px
    normalizeSlideIndex: true,
    centerInsufficientSlides: false,
    // Disable swiper and hide navigation when container not overflow
    watchOverflow: true,
    // Round length
    roundLengths: false,
    // Touches
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: true,
    shortSwipes: true,
    longSwipes: true,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: true,
    allowTouchMove: true,
    threshold: 5,
    touchMoveStopPropagation: false,
    touchStartPreventDefault: true,
    touchStartForcePreventDefault: false,
    touchReleaseOnEdges: false,
    // Unique Navigation Elements
    uniqueNavElements: true,
    // Resistance
    resistance: true,
    resistanceRatio: 0.85,
    // Progress
    watchSlidesProgress: false,
    // Cursor
    grabCursor: false,
    // Clicks
    preventClicks: true,
    preventClicksPropagation: true,
    slideToClickedSlide: false,
    // loop
    loop: false,
    loopAddBlankSlides: true,
    loopAdditionalSlides: 0,
    loopPreventsSliding: true,
    // rewind
    rewind: false,
    // Swiping/no swiping
    allowSlidePrev: true,
    allowSlideNext: true,
    swipeHandler: null,
    // '.swipe-handler',
    noSwiping: true,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    // Passive Listeners
    passiveListeners: true,
    maxBackfaceHiddenSlides: 10,
    // NS
    containerModifierClass: "swiper-",
    // NEW
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-blank",
    slideActiveClass: "swiper-slide-active",
    slideVisibleClass: "swiper-slide-visible",
    slideFullyVisibleClass: "swiper-slide-fully-visible",
    slideNextClass: "swiper-slide-next",
    slidePrevClass: "swiper-slide-prev",
    wrapperClass: "swiper-wrapper",
    lazyPreloaderClass: "swiper-lazy-preloader",
    lazyPreloadPrevNext: 0,
    // Callbacks
    runCallbacksOnInit: true,
    // Internals
    _emitClasses: false
  };
  function moduleExtendParams(params, allModulesParams) {
    return function extendParams(obj) {
      if (obj === void 0) {
        obj = {};
      }
      const moduleParamName = Object.keys(obj)[0];
      const moduleParams = obj[moduleParamName];
      if (typeof moduleParams !== "object" || moduleParams === null) {
        extend2(allModulesParams, obj);
        return;
      }
      if (params[moduleParamName] === true) {
        params[moduleParamName] = {
          enabled: true
        };
      }
      if (moduleParamName === "navigation" && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {
        params[moduleParamName].auto = true;
      }
      if (["pagination", "scrollbar"].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {
        params[moduleParamName].auto = true;
      }
      if (!(moduleParamName in params && "enabled" in moduleParams)) {
        extend2(allModulesParams, obj);
        return;
      }
      if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) {
        params[moduleParamName].enabled = true;
      }
      if (!params[moduleParamName]) params[moduleParamName] = {
        enabled: false
      };
      extend2(allModulesParams, obj);
    };
  }
  var prototypes = {
    eventsEmitter,
    update,
    translate,
    transition,
    slide,
    loop,
    grabCursor,
    events: events$1,
    breakpoints,
    checkOverflow: checkOverflow$1,
    classes
  };
  var extendedDefaults = {};
  var Swiper = class _Swiper {
    constructor() {
      let el;
      let params;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") {
        params = args[0];
      } else {
        [el, params] = args;
      }
      if (!params) params = {};
      params = extend2({}, params);
      if (el && !params.el) params.el = el;
      const document2 = getDocument();
      if (params.el && typeof params.el === "string" && document2.querySelectorAll(params.el).length > 1) {
        const swipers = [];
        document2.querySelectorAll(params.el).forEach((containerEl) => {
          const newParams = extend2({}, params, {
            el: containerEl
          });
          swipers.push(new _Swiper(newParams));
        });
        return swipers;
      }
      const swiper = this;
      swiper.__swiper__ = true;
      swiper.support = getSupport();
      swiper.device = getDevice({
        userAgent: params.userAgent
      });
      swiper.browser = getBrowser();
      swiper.eventsListeners = {};
      swiper.eventsAnyListeners = [];
      swiper.modules = [...swiper.__modules__];
      if (params.modules && Array.isArray(params.modules)) {
        swiper.modules.push(...params.modules);
      }
      const allModulesParams = {};
      swiper.modules.forEach((mod2) => {
        mod2({
          params,
          swiper,
          extendParams: moduleExtendParams(params, allModulesParams),
          on: swiper.on.bind(swiper),
          once: swiper.once.bind(swiper),
          off: swiper.off.bind(swiper),
          emit: swiper.emit.bind(swiper)
        });
      });
      const swiperParams = extend2({}, defaults2, allModulesParams);
      swiper.params = extend2({}, swiperParams, extendedDefaults, params);
      swiper.originalParams = extend2({}, swiper.params);
      swiper.passedParams = extend2({}, params);
      if (swiper.params && swiper.params.on) {
        Object.keys(swiper.params.on).forEach((eventName) => {
          swiper.on(eventName, swiper.params.on[eventName]);
        });
      }
      if (swiper.params && swiper.params.onAny) {
        swiper.onAny(swiper.params.onAny);
      }
      Object.assign(swiper, {
        enabled: swiper.params.enabled,
        el,
        // Classes
        classNames: [],
        // Slides
        slides: [],
        slidesGrid: [],
        snapGrid: [],
        slidesSizesGrid: [],
        // isDirection
        isHorizontal() {
          return swiper.params.direction === "horizontal";
        },
        isVertical() {
          return swiper.params.direction === "vertical";
        },
        // Indexes
        activeIndex: 0,
        realIndex: 0,
        //
        isBeginning: true,
        isEnd: false,
        // Props
        translate: 0,
        previousTranslate: 0,
        progress: 0,
        velocity: 0,
        animating: false,
        cssOverflowAdjustment() {
          return Math.trunc(this.translate / __pow(2, 23)) * __pow(2, 23);
        },
        // Locks
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev,
        // Touch Events
        touchEventsData: {
          isTouched: void 0,
          isMoved: void 0,
          allowTouchCallbacks: void 0,
          touchStartTime: void 0,
          isScrolling: void 0,
          currentTranslate: void 0,
          startTranslate: void 0,
          allowThresholdMove: void 0,
          // Form elements to match
          focusableElements: swiper.params.focusableElements,
          // Last click time
          lastClickTime: 0,
          clickTimeout: void 0,
          // Velocities
          velocities: [],
          allowMomentumBounce: void 0,
          startMoving: void 0,
          pointerId: null,
          touchId: null
        },
        // Clicks
        allowClick: true,
        // Touches
        allowTouchMove: swiper.params.allowTouchMove,
        touches: {
          startX: 0,
          startY: 0,
          currentX: 0,
          currentY: 0,
          diff: 0
        },
        // Images
        imagesToLoad: [],
        imagesLoaded: 0
      });
      swiper.emit("_swiper");
      if (swiper.params.init) {
        swiper.init();
      }
      return swiper;
    }
    getDirectionLabel(property2) {
      if (this.isHorizontal()) {
        return property2;
      }
      return {
        "width": "height",
        "margin-top": "margin-left",
        "margin-bottom ": "margin-right",
        "margin-left": "margin-top",
        "margin-right": "margin-bottom",
        "padding-left": "padding-top",
        "padding-right": "padding-bottom",
        "marginRight": "marginBottom"
      }[property2];
    }
    getSlideIndex(slideEl) {
      const {
        slidesEl,
        params
      } = this;
      const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
      const firstSlideIndex = elementIndex(slides[0]);
      return elementIndex(slideEl) - firstSlideIndex;
    }
    getSlideIndexByData(index2) {
      return this.getSlideIndex(this.slides.filter((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === index2)[0]);
    }
    recalcSlides() {
      const swiper = this;
      const {
        slidesEl,
        params
      } = swiper;
      swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
    }
    enable() {
      const swiper = this;
      if (swiper.enabled) return;
      swiper.enabled = true;
      if (swiper.params.grabCursor) {
        swiper.setGrabCursor();
      }
      swiper.emit("enable");
    }
    disable() {
      const swiper = this;
      if (!swiper.enabled) return;
      swiper.enabled = false;
      if (swiper.params.grabCursor) {
        swiper.unsetGrabCursor();
      }
      swiper.emit("disable");
    }
    setProgress(progress, speed) {
      const swiper = this;
      progress = Math.min(Math.max(progress, 0), 1);
      const min = swiper.minTranslate();
      const max = swiper.maxTranslate();
      const current = (max - min) * progress + min;
      swiper.translateTo(current, typeof speed === "undefined" ? 0 : speed);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    emitContainerClasses() {
      const swiper = this;
      if (!swiper.params._emitClasses || !swiper.el) return;
      const cls = swiper.el.className.split(" ").filter((className) => {
        return className.indexOf("swiper") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
      });
      swiper.emit("_containerClasses", cls.join(" "));
    }
    getSlideClasses(slideEl) {
      const swiper = this;
      if (swiper.destroyed) return "";
      return slideEl.className.split(" ").filter((className) => {
        return className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0;
      }).join(" ");
    }
    emitSlidesClasses() {
      const swiper = this;
      if (!swiper.params._emitClasses || !swiper.el) return;
      const updates = [];
      swiper.slides.forEach((slideEl) => {
        const classNames = swiper.getSlideClasses(slideEl);
        updates.push({
          slideEl,
          classNames
        });
        swiper.emit("_slideClass", slideEl, classNames);
      });
      swiper.emit("_slideClasses", updates);
    }
    slidesPerViewDynamic(view, exact) {
      if (view === void 0) {
        view = "current";
      }
      if (exact === void 0) {
        exact = false;
      }
      const swiper = this;
      const {
        params,
        slides,
        slidesGrid,
        slidesSizesGrid,
        size: swiperSize,
        activeIndex
      } = swiper;
      let spv = 1;
      if (typeof params.slidesPerView === "number") return params.slidesPerView;
      if (params.centeredSlides) {
        let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;
        let breakLoop;
        for (let i6 = activeIndex + 1; i6 < slides.length; i6 += 1) {
          if (slides[i6] && !breakLoop) {
            slideSize += Math.ceil(slides[i6].swiperSlideSize);
            spv += 1;
            if (slideSize > swiperSize) breakLoop = true;
          }
        }
        for (let i6 = activeIndex - 1; i6 >= 0; i6 -= 1) {
          if (slides[i6] && !breakLoop) {
            slideSize += slides[i6].swiperSlideSize;
            spv += 1;
            if (slideSize > swiperSize) breakLoop = true;
          }
        }
      } else {
        if (view === "current") {
          for (let i6 = activeIndex + 1; i6 < slides.length; i6 += 1) {
            const slideInView = exact ? slidesGrid[i6] + slidesSizesGrid[i6] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i6] - slidesGrid[activeIndex] < swiperSize;
            if (slideInView) {
              spv += 1;
            }
          }
        } else {
          for (let i6 = activeIndex - 1; i6 >= 0; i6 -= 1) {
            const slideInView = slidesGrid[activeIndex] - slidesGrid[i6] < swiperSize;
            if (slideInView) {
              spv += 1;
            }
          }
        }
      }
      return spv;
    }
    update() {
      const swiper = this;
      if (!swiper || swiper.destroyed) return;
      const {
        snapGrid,
        params
      } = swiper;
      if (params.breakpoints) {
        swiper.setBreakpoint();
      }
      [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach((imageEl) => {
        if (imageEl.complete) {
          processLazyPreloader(swiper, imageEl);
        }
      });
      swiper.updateSize();
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();
      function setTranslate2() {
        const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
        const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
        swiper.setTranslate(newTranslate);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }
      let translated;
      if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
        setTranslate2();
        if (params.autoHeight) {
          swiper.updateAutoHeight();
        }
      } else {
        if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
          const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
          translated = swiper.slideTo(slides.length - 1, 0, false, true);
        } else {
          translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
        }
        if (!translated) {
          setTranslate2();
        }
      }
      if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }
      swiper.emit("update");
    }
    changeDirection(newDirection, needUpdate) {
      if (needUpdate === void 0) {
        needUpdate = true;
      }
      const swiper = this;
      const currentDirection = swiper.params.direction;
      if (!newDirection) {
        newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
      }
      if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") {
        return swiper;
      }
      swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
      swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
      swiper.emitContainerClasses();
      swiper.params.direction = newDirection;
      swiper.slides.forEach((slideEl) => {
        if (newDirection === "vertical") {
          slideEl.style.width = "";
        } else {
          slideEl.style.height = "";
        }
      });
      swiper.emit("changeDirection");
      if (needUpdate) swiper.update();
      return swiper;
    }
    changeLanguageDirection(direction) {
      const swiper = this;
      if (swiper.rtl && direction === "rtl" || !swiper.rtl && direction === "ltr") return;
      swiper.rtl = direction === "rtl";
      swiper.rtlTranslate = swiper.params.direction === "horizontal" && swiper.rtl;
      if (swiper.rtl) {
        swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
        swiper.el.dir = "rtl";
      } else {
        swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
        swiper.el.dir = "ltr";
      }
      swiper.update();
    }
    mount(element) {
      const swiper = this;
      if (swiper.mounted) return true;
      let el = element || swiper.params.el;
      if (typeof el === "string") {
        el = document.querySelector(el);
      }
      if (!el) {
        return false;
      }
      el.swiper = swiper;
      if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) {
        swiper.isElement = true;
      }
      const getWrapperSelector = () => {
        return `.${(swiper.params.wrapperClass || "").trim().split(" ").join(".")}`;
      };
      const getWrapper = () => {
        if (el && el.shadowRoot && el.shadowRoot.querySelector) {
          const res = el.shadowRoot.querySelector(getWrapperSelector());
          return res;
        }
        return elementChildren(el, getWrapperSelector())[0];
      };
      let wrapperEl = getWrapper();
      if (!wrapperEl && swiper.params.createElements) {
        wrapperEl = createElement("div", swiper.params.wrapperClass);
        el.append(wrapperEl);
        elementChildren(el, `.${swiper.params.slideClass}`).forEach((slideEl) => {
          wrapperEl.append(slideEl);
        });
      }
      Object.assign(swiper, {
        el,
        wrapperEl,
        slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,
        hostEl: swiper.isElement ? el.parentNode.host : el,
        mounted: true,
        // RTL
        rtl: el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl",
        rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl"),
        wrongRTL: elementStyle(wrapperEl, "display") === "-webkit-box"
      });
      return true;
    }
    init(el) {
      const swiper = this;
      if (swiper.initialized) return swiper;
      const mounted = swiper.mount(el);
      if (mounted === false) return swiper;
      swiper.emit("beforeInit");
      if (swiper.params.breakpoints) {
        swiper.setBreakpoint();
      }
      swiper.addClasses();
      swiper.updateSize();
      swiper.updateSlides();
      if (swiper.params.watchOverflow) {
        swiper.checkOverflow();
      }
      if (swiper.params.grabCursor && swiper.enabled) {
        swiper.setGrabCursor();
      }
      if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
        swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);
      } else {
        swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
      }
      if (swiper.params.loop) {
        swiper.loopCreate();
      }
      swiper.attachEvents();
      const lazyElements = [...swiper.el.querySelectorAll('[loading="lazy"]')];
      if (swiper.isElement) {
        lazyElements.push(...swiper.hostEl.querySelectorAll('[loading="lazy"]'));
      }
      lazyElements.forEach((imageEl) => {
        if (imageEl.complete) {
          processLazyPreloader(swiper, imageEl);
        } else {
          imageEl.addEventListener("load", (e5) => {
            processLazyPreloader(swiper, e5.target);
          });
        }
      });
      preload(swiper);
      swiper.initialized = true;
      preload(swiper);
      swiper.emit("init");
      swiper.emit("afterInit");
      return swiper;
    }
    destroy(deleteInstance, cleanStyles) {
      if (deleteInstance === void 0) {
        deleteInstance = true;
      }
      if (cleanStyles === void 0) {
        cleanStyles = true;
      }
      const swiper = this;
      const {
        params,
        el,
        wrapperEl,
        slides
      } = swiper;
      if (typeof swiper.params === "undefined" || swiper.destroyed) {
        return null;
      }
      swiper.emit("beforeDestroy");
      swiper.initialized = false;
      swiper.detachEvents();
      if (params.loop) {
        swiper.loopDestroy();
      }
      if (cleanStyles) {
        swiper.removeClasses();
        if (el && typeof el !== "string") {
          el.removeAttribute("style");
        }
        if (wrapperEl) {
          wrapperEl.removeAttribute("style");
        }
        if (slides && slides.length) {
          slides.forEach((slideEl) => {
            slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
            slideEl.removeAttribute("style");
            slideEl.removeAttribute("data-swiper-slide-index");
          });
        }
      }
      swiper.emit("destroy");
      Object.keys(swiper.eventsListeners).forEach((eventName) => {
        swiper.off(eventName);
      });
      if (deleteInstance !== false) {
        if (swiper.el && typeof swiper.el !== "string") {
          swiper.el.swiper = null;
        }
        deleteProps(swiper);
      }
      swiper.destroyed = true;
      return null;
    }
    static extendDefaults(newDefaults) {
      extend2(extendedDefaults, newDefaults);
    }
    static get extendedDefaults() {
      return extendedDefaults;
    }
    static get defaults() {
      return defaults2;
    }
    static installModule(mod2) {
      if (!_Swiper.prototype.__modules__) _Swiper.prototype.__modules__ = [];
      const modules = _Swiper.prototype.__modules__;
      if (typeof mod2 === "function" && modules.indexOf(mod2) < 0) {
        modules.push(mod2);
      }
    }
    static use(module2) {
      if (Array.isArray(module2)) {
        module2.forEach((m3) => _Swiper.installModule(m3));
        return _Swiper;
      }
      _Swiper.installModule(module2);
      return _Swiper;
    }
  };
  Object.keys(prototypes).forEach((prototypeGroup) => {
    Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
      Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
    });
  });
  Swiper.use([Resize, Observer]);

  // assets/scripts/config.js
  var NODE_ENV = "development";
  var IS_MOBILE = window.matchMedia("(any-pointer:coarse)").matches;
  var ENV = Object.freeze({
    // Node environment
    NAME: NODE_ENV,
    IS_PROD: NODE_ENV === "production",
    IS_DEV: NODE_ENV === "development",
    // Device
    IS_MOBILE,
    IS_DESKTOP: !IS_MOBILE,
    // Supports
    SUPPORTS_VH: "CSS" in window && "supports" in window.CSS && window.CSS.supports("height: 100svh") && window.CSS.supports("height: 100dvh") && window.CSS.supports("height: 100lvh")
  });
  var CSS_CLASS = Object.freeze({
    LOADING: "is-loading",
    FIRST_LOADED: "is-first-loaded",
    LOADED: "is-loaded",
    READY: "is-ready",
    FONTS_LOADED: "fonts-loaded",
    LAZY_CONTAINER: "c-lazy",
    LAZY_LOADED: "-lazy-loaded"
    // ...
  });
  var CUSTOM_EVENT = Object.freeze({
    RESIZE_END: "loco.resizeEnd"
    // ...
  });
  var FONT = Object.freeze({
    EAGER: [
      { family: "ABCDiatype", style: "normal", weight: 400 },
      { family: "ABCDiatype", style: "italic", weight: 400 },
      { family: "ABCDiatype", style: "normal", weight: 700 },
      { family: "ABCDiatype", style: "italic", weight: 700 },
      { family: "SuisseIntlCond", style: "normal", weight: 400 }
    ]
  });
  var BREAKPOINTS = Object.freeze({
    FROM_2XS: 340,
    TO_2XS: 339,
    FROM_XS: 500,
    TO_XS: 499,
    FROM_SM: 700,
    TO_SM: 699,
    FROM_MD: 1e3,
    TO_MD: 999,
    FROM_LG: 1200,
    TO_LG: 1199,
    FROM_XL: 1400,
    TO_XL: 1399,
    FROM_2XL: 1600,
    TO_2XL: 1599,
    FROM_3XL: 1800,
    TO_3XL: 1799,
    FROM_4XL: 2e3,
    TO_4XL: 1999,
    FROM_5XL: 2400,
    TO_5XL: 1399
  });

  // assets/scripts/utils/fonts.js
  var isFontLoadingAPIAvailable = "fonts" in document;
  function conformsToReference(font, criterion2) {
    for (const [key2, value2] of Object.entries(criterion2)) {
      switch (key2) {
        case "family": {
          if (trim(font[key2]) !== value2) {
            return false;
          }
          break;
        }
        case "weight": {
          if (font[key2] != value2) {
            return false;
          }
          break;
        }
        default: {
          if (font[key2] !== value2) {
            return false;
          }
          break;
        }
      }
    }
    return true;
  }
  function conformsToShorthand(font, criterion2) {
    const family = trim(font.family);
    if (trim(family) === criterion2) {
      return true;
    }
    if (criterion2.endsWith(trim(family)) && (criterion2.match(font.weight) || criterion2.match(font.style))) {
      return true;
    }
    return true;
  }
  function findManyByReference(search) {
    const found = [];
    for (const font of document.fonts) {
      if (conformsToReference(font, search)) {
        found.push(font);
      }
    }
    return found;
  }
  function findManyByShorthand(search) {
    const found = [];
    for (const font of document.fonts) {
      if (conformsToShorthand(font, search)) {
        found.push(font);
      }
    }
    return found;
  }
  function getMany(queries) {
    if (!Array.isArray(queries)) {
      queries = [queries];
    }
    const found = /* @__PURE__ */ new Set();
    queries.forEach((search) => {
      if (search) {
        switch (typeof search) {
          case "string":
            found.add(...findManyByShorthand(search));
            return;
          case "object":
            found.add(...findManyByReference(search));
            return;
        }
      }
      throw new TypeError("Expected font query to be font shorthand or font reference");
    });
    return [...found];
  }
  function loadFonts(fontsToLoad, debug = false) {
    return __async(this, null, function* () {
      var _a;
      if (((_a = fontsToLoad.size) != null ? _a : fontsToLoad.length) === 0) {
        throw new TypeError("Expected at least one font");
      }
      return yield loadFontsWithAPI([...fontsToLoad], debug);
    });
  }
  function loadFontFaceWithAPI(font) {
    return __async(this, null, function* () {
      return yield (font.status === "unloaded" ? font.load() : font.loaded).then(
        (font2) => font2,
        (err) => font
      );
    });
  }
  function loadFontsWithAPI(fontsToLoad, debug = false) {
    return __async(this, null, function* () {
      debug && console.group("[loadFonts:API]", fontsToLoad.length, "/", document.fonts.size);
      const fontsToBeLoaded = [];
      for (const fontToLoad of fontsToLoad) {
        if (fontToLoad instanceof FontFace) {
          if (!document.fonts.has(fontToLoad)) {
            document.fonts.add(fontToLoad);
          }
          fontsToBeLoaded.push(loadFontFaceWithAPI(fontToLoad));
        } else {
          fontsToBeLoaded.push(...getMany(fontToLoad).map((font) => loadFontFaceWithAPI(font)));
        }
      }
      debug && console.groupEnd();
      return yield Promise.all(fontsToBeLoaded);
    });
  }
  function trim(value2) {
    return value2.replace(/['"]+/g, "");
  }
  function whenReady(queries) {
    return __async(this, null, function* () {
      const fonts = getMany(queries);
      return yield Promise.all(fonts.map((font) => font.loaded));
    });
  }

  // node_modules/nanostores/clean-stores/index.js
  var clean = Symbol("clean");

  // node_modules/nanostores/atom/index.js
  var listenerQueue = [];
  var lqIndex = 0;
  var QUEUE_ITEMS_PER_LISTENER = 4;
  var epoch = 0;
  var atom = (initialValue) => {
    let listeners = [];
    let $atom = {
      get() {
        if (!$atom.lc) {
          $atom.listen(() => {
          })();
        }
        return $atom.value;
      },
      lc: 0,
      listen(listener) {
        $atom.lc = listeners.push(listener);
        return () => {
          for (let i6 = lqIndex + QUEUE_ITEMS_PER_LISTENER; i6 < listenerQueue.length; ) {
            if (listenerQueue[i6] === listener) {
              listenerQueue.splice(i6, QUEUE_ITEMS_PER_LISTENER);
            } else {
              i6 += QUEUE_ITEMS_PER_LISTENER;
            }
          }
          let index2 = listeners.indexOf(listener);
          if (~index2) {
            listeners.splice(index2, 1);
            if (!--$atom.lc) $atom.off();
          }
        };
      },
      notify(oldValue, changedKey) {
        epoch++;
        let runListenerQueue = !listenerQueue.length;
        for (let listener of listeners) {
          listenerQueue.push(
            listener,
            $atom.value,
            oldValue,
            changedKey
          );
        }
        if (runListenerQueue) {
          for (lqIndex = 0; lqIndex < listenerQueue.length; lqIndex += QUEUE_ITEMS_PER_LISTENER) {
            listenerQueue[lqIndex](
              listenerQueue[lqIndex + 1],
              listenerQueue[lqIndex + 2],
              listenerQueue[lqIndex + 3]
            );
          }
          listenerQueue.length = 0;
        }
      },
      /* It will be called on last listener unsubscribing.
         We will redefine it in onMount and onStop. */
      off() {
      },
      set(newValue) {
        let oldValue = $atom.value;
        if (oldValue !== newValue) {
          $atom.value = newValue;
          $atom.notify(oldValue);
        }
      },
      subscribe(listener) {
        let unbind = $atom.listen(listener);
        listener($atom.value);
        return unbind;
      },
      value: initialValue
    };
    if (true) {
      $atom[clean] = () => {
        listeners = [];
        $atom.lc = 0;
        $atom.off();
      };
    }
    return $atom;
  };

  // node_modules/nanostores/map/index.js
  var map = (initial = {}) => {
    let $map = atom(initial);
    $map.setKey = function(key2, value2) {
      let oldMap = $map.value;
      if (typeof value2 === "undefined" && key2 in $map.value) {
        $map.value = __spreadValues({}, $map.value);
        delete $map.value[key2];
        $map.notify(oldMap, key2);
      } else if ($map.value[key2] !== value2) {
        $map.value = __spreadProps(__spreadValues({}, $map.value), {
          [key2]: value2
        });
        $map.notify(oldMap, key2);
      }
    };
    return $map;
  };

  // assets/scripts/utils/tickers.js
  var debounce = (callback, delay3, immediate = false) => {
    let timeout = null;
    return (...args) => {
      clearTimeout(timeout);
      const later = () => {
        timeout = null;
        if (!immediate) {
          callback(...args);
        }
      };
      if (immediate && !timeout) {
        callback(...args);
      }
      timeout = setTimeout(later, delay3);
    };
  };

  // assets/scripts/stores/screen.js
  var $screen = map({
    width: window.innerWidth,
    height: window.innerHeight
  });
  var $screenDebounce = map({
    width: window.innerWidth,
    height: window.innerHeight
  });
  window.addEventListener("resize", () => {
    $screen.setKey("width", window.innerWidth);
    $screen.setKey("height", window.innerHeight);
  });
  var debouncedFunction = () => {
    $screenDebounce.setKey("width", window.innerWidth);
    $screenDebounce.setKey("height", window.innerHeight);
  };
  window.addEventListener("resize", debounce(debouncedFunction, 200));

  // node_modules/swiper/modules/mousewheel.mjs
  function Mousewheel(_ref) {
    let {
      swiper,
      extendParams,
      on,
      emit
    } = _ref;
    const window2 = getWindow();
    extendParams({
      mousewheel: {
        enabled: false,
        releaseOnEdges: false,
        invert: false,
        forceToAxis: false,
        sensitivity: 1,
        eventsTarget: "container",
        thresholdDelta: null,
        thresholdTime: null,
        noMousewheelClass: "swiper-no-mousewheel"
      }
    });
    swiper.mousewheel = {
      enabled: false
    };
    let timeout;
    let lastScrollTime = now();
    let lastEventBeforeSnap;
    const recentWheelEvents = [];
    function normalize4(e5) {
      const PIXEL_STEP = 10;
      const LINE_HEIGHT = 40;
      const PAGE_HEIGHT = 800;
      let sX = 0;
      let sY = 0;
      let pX = 0;
      let pY = 0;
      if ("detail" in e5) {
        sY = e5.detail;
      }
      if ("wheelDelta" in e5) {
        sY = -e5.wheelDelta / 120;
      }
      if ("wheelDeltaY" in e5) {
        sY = -e5.wheelDeltaY / 120;
      }
      if ("wheelDeltaX" in e5) {
        sX = -e5.wheelDeltaX / 120;
      }
      if ("axis" in e5 && e5.axis === e5.HORIZONTAL_AXIS) {
        sX = sY;
        sY = 0;
      }
      pX = sX * PIXEL_STEP;
      pY = sY * PIXEL_STEP;
      if ("deltaY" in e5) {
        pY = e5.deltaY;
      }
      if ("deltaX" in e5) {
        pX = e5.deltaX;
      }
      if (e5.shiftKey && !pX) {
        pX = pY;
        pY = 0;
      }
      if ((pX || pY) && e5.deltaMode) {
        if (e5.deltaMode === 1) {
          pX *= LINE_HEIGHT;
          pY *= LINE_HEIGHT;
        } else {
          pX *= PAGE_HEIGHT;
          pY *= PAGE_HEIGHT;
        }
      }
      if (pX && !sX) {
        sX = pX < 1 ? -1 : 1;
      }
      if (pY && !sY) {
        sY = pY < 1 ? -1 : 1;
      }
      return {
        spinX: sX,
        spinY: sY,
        pixelX: pX,
        pixelY: pY
      };
    }
    function handleMouseEnter() {
      if (!swiper.enabled) return;
      swiper.mouseEntered = true;
    }
    function handleMouseLeave() {
      if (!swiper.enabled) return;
      swiper.mouseEntered = false;
    }
    function animateSlider(newEvent) {
      if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {
        return false;
      }
      if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {
        return false;
      }
      if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {
        return true;
      }
      if (newEvent.direction < 0) {
        if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
          swiper.slideNext();
          emit("scroll", newEvent.raw);
        }
      } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
        swiper.slidePrev();
        emit("scroll", newEvent.raw);
      }
      lastScrollTime = new window2.Date().getTime();
      return false;
    }
    function releaseScroll(newEvent) {
      const params = swiper.params.mousewheel;
      if (newEvent.direction < 0) {
        if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
          return true;
        }
      } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
        return true;
      }
      return false;
    }
    function handle(event2) {
      let e5 = event2;
      let disableParentSwiper = true;
      if (!swiper.enabled) return;
      if (event2.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;
      const params = swiper.params.mousewheel;
      if (swiper.params.cssMode) {
        e5.preventDefault();
      }
      let targetEl = swiper.el;
      if (swiper.params.mousewheel.eventsTarget !== "container") {
        targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
      }
      const targetElContainsTarget = targetEl && targetEl.contains(e5.target);
      if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;
      if (e5.originalEvent) e5 = e5.originalEvent;
      let delta = 0;
      const rtlFactor = swiper.rtlTranslate ? -1 : 1;
      const data2 = normalize4(e5);
      if (params.forceToAxis) {
        if (swiper.isHorizontal()) {
          if (Math.abs(data2.pixelX) > Math.abs(data2.pixelY)) delta = -data2.pixelX * rtlFactor;
          else return true;
        } else if (Math.abs(data2.pixelY) > Math.abs(data2.pixelX)) delta = -data2.pixelY;
        else return true;
      } else {
        delta = Math.abs(data2.pixelX) > Math.abs(data2.pixelY) ? -data2.pixelX * rtlFactor : -data2.pixelY;
      }
      if (delta === 0) return true;
      if (params.invert) delta = -delta;
      let positions = swiper.getTranslate() + delta * params.sensitivity;
      if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
      if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();
      disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
      if (disableParentSwiper && swiper.params.nested) e5.stopPropagation();
      if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
        const newEvent = {
          time: now(),
          delta: Math.abs(delta),
          direction: Math.sign(delta),
          raw: event2
        };
        if (recentWheelEvents.length >= 2) {
          recentWheelEvents.shift();
        }
        const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;
        recentWheelEvents.push(newEvent);
        if (prevEvent) {
          if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
            animateSlider(newEvent);
          }
        } else {
          animateSlider(newEvent);
        }
        if (releaseScroll(newEvent)) {
          return true;
        }
      } else {
        const newEvent = {
          time: now(),
          delta: Math.abs(delta),
          direction: Math.sign(delta)
        };
        const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;
        if (!ignoreWheelEvents) {
          lastEventBeforeSnap = void 0;
          let position2 = swiper.getTranslate() + delta * params.sensitivity;
          const wasBeginning = swiper.isBeginning;
          const wasEnd = swiper.isEnd;
          if (position2 >= swiper.minTranslate()) position2 = swiper.minTranslate();
          if (position2 <= swiper.maxTranslate()) position2 = swiper.maxTranslate();
          swiper.setTransition(0);
          swiper.setTranslate(position2);
          swiper.updateProgress();
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
          if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
            swiper.updateSlidesClasses();
          }
          if (swiper.params.loop) {
            swiper.loopFix({
              direction: newEvent.direction < 0 ? "next" : "prev",
              byMousewheel: true
            });
          }
          if (swiper.params.freeMode.sticky) {
            clearTimeout(timeout);
            timeout = void 0;
            if (recentWheelEvents.length >= 15) {
              recentWheelEvents.shift();
            }
            const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;
            const firstEvent = recentWheelEvents[0];
            recentWheelEvents.push(newEvent);
            if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
              recentWheelEvents.splice(0);
            } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
              const snapToThreshold = delta > 0 ? 0.8 : 0.2;
              lastEventBeforeSnap = newEvent;
              recentWheelEvents.splice(0);
              timeout = nextTick(() => {
                if (swiper.destroyed || !swiper.params) return;
                swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);
              }, 0);
            }
            if (!timeout) {
              timeout = nextTick(() => {
                if (swiper.destroyed || !swiper.params) return;
                const snapToThreshold = 0.5;
                lastEventBeforeSnap = newEvent;
                recentWheelEvents.splice(0);
                swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);
              }, 500);
            }
          }
          if (!ignoreWheelEvents) emit("scroll", e5);
          if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();
          if (params.releaseOnEdges && (position2 === swiper.minTranslate() || position2 === swiper.maxTranslate())) {
            return true;
          }
        }
      }
      if (e5.preventDefault) e5.preventDefault();
      else e5.returnValue = false;
      return false;
    }
    function events2(method) {
      let targetEl = swiper.el;
      if (swiper.params.mousewheel.eventsTarget !== "container") {
        targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
      }
      targetEl[method]("mouseenter", handleMouseEnter);
      targetEl[method]("mouseleave", handleMouseLeave);
      targetEl[method]("wheel", handle);
    }
    function enable() {
      if (swiper.params.cssMode) {
        swiper.wrapperEl.removeEventListener("wheel", handle);
        return true;
      }
      if (swiper.mousewheel.enabled) return false;
      events2("addEventListener");
      swiper.mousewheel.enabled = true;
      return true;
    }
    function disable() {
      if (swiper.params.cssMode) {
        swiper.wrapperEl.addEventListener(event, handle);
        return true;
      }
      if (!swiper.mousewheel.enabled) return false;
      events2("removeEventListener");
      swiper.mousewheel.enabled = false;
      return true;
    }
    on("init", () => {
      if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
        disable();
      }
      if (swiper.params.mousewheel.enabled) enable();
    });
    on("destroy", () => {
      if (swiper.params.cssMode) {
        enable();
      }
      if (swiper.mousewheel.enabled) disable();
    });
    Object.assign(swiper.mousewheel, {
      enable,
      disable
    });
  }

  // node_modules/swiper/shared/create-element-if-not-defined.mjs
  function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
    if (swiper.params.createElements) {
      Object.keys(checkProps).forEach((key2) => {
        if (!params[key2] && params.auto === true) {
          let element = elementChildren(swiper.el, `.${checkProps[key2]}`)[0];
          if (!element) {
            element = createElement("div", checkProps[key2]);
            element.className = checkProps[key2];
            swiper.el.append(element);
          }
          params[key2] = element;
          originalParams[key2] = element;
        }
      });
    }
    return params;
  }

  // node_modules/swiper/modules/navigation.mjs
  function Navigation(_ref) {
    let {
      swiper,
      extendParams,
      on,
      emit
    } = _ref;
    extendParams({
      navigation: {
        nextEl: null,
        prevEl: null,
        hideOnClick: false,
        disabledClass: "swiper-button-disabled",
        hiddenClass: "swiper-button-hidden",
        lockClass: "swiper-button-lock",
        navigationDisabledClass: "swiper-navigation-disabled"
      }
    });
    swiper.navigation = {
      nextEl: null,
      prevEl: null
    };
    function getEl(el) {
      let res;
      if (el && typeof el === "string" && swiper.isElement) {
        res = swiper.el.querySelector(el) || swiper.hostEl.querySelector(el);
        if (res) return res;
      }
      if (el) {
        if (typeof el === "string") res = [...document.querySelectorAll(el)];
        if (swiper.params.uniqueNavElements && typeof el === "string" && res && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {
          res = swiper.el.querySelector(el);
        } else if (res && res.length === 1) {
          res = res[0];
        }
      }
      if (el && !res) return el;
      return res;
    }
    function toggleEl(el, disabled) {
      const params = swiper.params.navigation;
      el = makeElementsArray(el);
      el.forEach((subEl) => {
        if (subEl) {
          subEl.classList[disabled ? "add" : "remove"](...params.disabledClass.split(" "));
          if (subEl.tagName === "BUTTON") subEl.disabled = disabled;
          if (swiper.params.watchOverflow && swiper.enabled) {
            subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass);
          }
        }
      });
    }
    function update2() {
      const {
        nextEl,
        prevEl
      } = swiper.navigation;
      if (swiper.params.loop) {
        toggleEl(prevEl, false);
        toggleEl(nextEl, false);
        return;
      }
      toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);
      toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);
    }
    function onPrevClick(e5) {
      e5.preventDefault();
      if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
      swiper.slidePrev();
      emit("navigationPrev");
    }
    function onNextClick(e5) {
      e5.preventDefault();
      if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
      swiper.slideNext();
      emit("navigationNext");
    }
    function init5() {
      const params = swiper.params.navigation;
      swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
        nextEl: "swiper-button-next",
        prevEl: "swiper-button-prev"
      });
      if (!(params.nextEl || params.prevEl)) return;
      let nextEl = getEl(params.nextEl);
      let prevEl = getEl(params.prevEl);
      Object.assign(swiper.navigation, {
        nextEl,
        prevEl
      });
      nextEl = makeElementsArray(nextEl);
      prevEl = makeElementsArray(prevEl);
      const initButton = (el, dir) => {
        if (el) {
          el.addEventListener("click", dir === "next" ? onNextClick : onPrevClick);
        }
        if (!swiper.enabled && el) {
          el.classList.add(...params.lockClass.split(" "));
        }
      };
      nextEl.forEach((el) => initButton(el, "next"));
      prevEl.forEach((el) => initButton(el, "prev"));
    }
    function destroy() {
      let {
        nextEl,
        prevEl
      } = swiper.navigation;
      nextEl = makeElementsArray(nextEl);
      prevEl = makeElementsArray(prevEl);
      const destroyButton = (el, dir) => {
        el.removeEventListener("click", dir === "next" ? onNextClick : onPrevClick);
        el.classList.remove(...swiper.params.navigation.disabledClass.split(" "));
      };
      nextEl.forEach((el) => destroyButton(el, "next"));
      prevEl.forEach((el) => destroyButton(el, "prev"));
    }
    on("init", () => {
      if (swiper.params.navigation.enabled === false) {
        disable();
      } else {
        init5();
        update2();
      }
    });
    on("toEdge fromEdge lock unlock", () => {
      update2();
    });
    on("destroy", () => {
      destroy();
    });
    on("enable disable", () => {
      let {
        nextEl,
        prevEl
      } = swiper.navigation;
      nextEl = makeElementsArray(nextEl);
      prevEl = makeElementsArray(prevEl);
      if (swiper.enabled) {
        update2();
        return;
      }
      [...nextEl, ...prevEl].filter((el) => !!el).forEach((el) => el.classList.add(swiper.params.navigation.lockClass));
    });
    on("click", (_s, e5) => {
      let {
        nextEl,
        prevEl
      } = swiper.navigation;
      nextEl = makeElementsArray(nextEl);
      prevEl = makeElementsArray(prevEl);
      const targetEl = e5.target;
      let targetIsButton = prevEl.includes(targetEl) || nextEl.includes(targetEl);
      if (swiper.isElement && !targetIsButton) {
        const path = e5.path || e5.composedPath && e5.composedPath();
        if (path) {
          targetIsButton = path.find((pathEl) => nextEl.includes(pathEl) || prevEl.includes(pathEl));
        }
      }
      if (swiper.params.navigation.hideOnClick && !targetIsButton) {
        if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
        let isHidden3;
        if (nextEl.length) {
          isHidden3 = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);
        } else if (prevEl.length) {
          isHidden3 = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);
        }
        if (isHidden3 === true) {
          emit("navigationShow");
        } else {
          emit("navigationHide");
        }
        [...nextEl, ...prevEl].filter((el) => !!el).forEach((el) => el.classList.toggle(swiper.params.navigation.hiddenClass));
      }
    });
    const enable = () => {
      swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(" "));
      init5();
      update2();
    };
    const disable = () => {
      swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(" "));
      destroy();
    };
    Object.assign(swiper.navigation, {
      enable,
      disable,
      update: update2,
      init: init5,
      destroy
    });
  }

  // node_modules/swiper/shared/classes-to-selector.mjs
  function classesToSelector(classes2) {
    if (classes2 === void 0) {
      classes2 = "";
    }
    return `.${classes2.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}`;
  }

  // node_modules/swiper/modules/pagination.mjs
  function Pagination(_ref) {
    let {
      swiper,
      extendParams,
      on,
      emit
    } = _ref;
    const pfx = "swiper-pagination";
    extendParams({
      pagination: {
        el: null,
        bulletElement: "span",
        clickable: false,
        hideOnClick: false,
        renderBullet: null,
        renderProgressbar: null,
        renderFraction: null,
        renderCustom: null,
        progressbarOpposite: false,
        type: "bullets",
        // 'bullets' or 'progressbar' or 'fraction' or 'custom'
        dynamicBullets: false,
        dynamicMainBullets: 1,
        formatFractionCurrent: (number) => number,
        formatFractionTotal: (number) => number,
        bulletClass: `${pfx}-bullet`,
        bulletActiveClass: `${pfx}-bullet-active`,
        modifierClass: `${pfx}-`,
        currentClass: `${pfx}-current`,
        totalClass: `${pfx}-total`,
        hiddenClass: `${pfx}-hidden`,
        progressbarFillClass: `${pfx}-progressbar-fill`,
        progressbarOppositeClass: `${pfx}-progressbar-opposite`,
        clickableClass: `${pfx}-clickable`,
        lockClass: `${pfx}-lock`,
        horizontalClass: `${pfx}-horizontal`,
        verticalClass: `${pfx}-vertical`,
        paginationDisabledClass: `${pfx}-disabled`
      }
    });
    swiper.pagination = {
      el: null,
      bullets: []
    };
    let bulletSize;
    let dynamicBulletIndex = 0;
    function isPaginationDisabled() {
      return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;
    }
    function setSideBullets(bulletEl, position2) {
      const {
        bulletActiveClass
      } = swiper.params.pagination;
      if (!bulletEl) return;
      bulletEl = bulletEl[`${position2 === "prev" ? "previous" : "next"}ElementSibling`];
      if (bulletEl) {
        bulletEl.classList.add(`${bulletActiveClass}-${position2}`);
        bulletEl = bulletEl[`${position2 === "prev" ? "previous" : "next"}ElementSibling`];
        if (bulletEl) {
          bulletEl.classList.add(`${bulletActiveClass}-${position2}-${position2}`);
        }
      }
    }
    function getMoveDirection(prevIndex, nextIndex, length2) {
      prevIndex = prevIndex % length2;
      nextIndex = nextIndex % length2;
      if (nextIndex === prevIndex + 1) {
        return "next";
      } else if (nextIndex === prevIndex - 1) {
        return "previous";
      }
      return;
    }
    function onBulletClick(e5) {
      const bulletEl = e5.target.closest(classesToSelector(swiper.params.pagination.bulletClass));
      if (!bulletEl) {
        return;
      }
      e5.preventDefault();
      const index2 = elementIndex(bulletEl) * swiper.params.slidesPerGroup;
      if (swiper.params.loop) {
        if (swiper.realIndex === index2) return;
        const moveDirection = getMoveDirection(swiper.realIndex, index2, swiper.slides.length);
        if (moveDirection === "next") {
          swiper.slideNext();
        } else if (moveDirection === "previous") {
          swiper.slidePrev();
        } else {
          swiper.slideToLoop(index2);
        }
      } else {
        swiper.slideTo(index2);
      }
    }
    function update2() {
      const rtl = swiper.rtl;
      const params = swiper.params.pagination;
      if (isPaginationDisabled()) return;
      let el = swiper.pagination.el;
      el = makeElementsArray(el);
      let current;
      let previousIndex;
      const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
      const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
      if (swiper.params.loop) {
        previousIndex = swiper.previousRealIndex || 0;
        current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;
      } else if (typeof swiper.snapIndex !== "undefined") {
        current = swiper.snapIndex;
        previousIndex = swiper.previousSnapIndex;
      } else {
        previousIndex = swiper.previousIndex || 0;
        current = swiper.activeIndex || 0;
      }
      if (params.type === "bullets" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
        const bullets = swiper.pagination.bullets;
        let firstIndex;
        let lastIndex;
        let midIndex;
        if (params.dynamicBullets) {
          bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? "width" : "height", true);
          el.forEach((subEl) => {
            subEl.style[swiper.isHorizontal() ? "width" : "height"] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;
          });
          if (params.dynamicMainBullets > 1 && previousIndex !== void 0) {
            dynamicBulletIndex += current - (previousIndex || 0);
            if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
              dynamicBulletIndex = params.dynamicMainBullets - 1;
            } else if (dynamicBulletIndex < 0) {
              dynamicBulletIndex = 0;
            }
          }
          firstIndex = Math.max(current - dynamicBulletIndex, 0);
          lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
          midIndex = (lastIndex + firstIndex) / 2;
        }
        bullets.forEach((bulletEl) => {
          const classesToRemove = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((suffix) => `${params.bulletActiveClass}${suffix}`)].map((s4) => typeof s4 === "string" && s4.includes(" ") ? s4.split(" ") : s4).flat();
          bulletEl.classList.remove(...classesToRemove);
        });
        if (el.length > 1) {
          bullets.forEach((bullet) => {
            const bulletIndex = elementIndex(bullet);
            if (bulletIndex === current) {
              bullet.classList.add(...params.bulletActiveClass.split(" "));
            } else if (swiper.isElement) {
              bullet.setAttribute("part", "bullet");
            }
            if (params.dynamicBullets) {
              if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                bullet.classList.add(...`${params.bulletActiveClass}-main`.split(" "));
              }
              if (bulletIndex === firstIndex) {
                setSideBullets(bullet, "prev");
              }
              if (bulletIndex === lastIndex) {
                setSideBullets(bullet, "next");
              }
            }
          });
        } else {
          const bullet = bullets[current];
          if (bullet) {
            bullet.classList.add(...params.bulletActiveClass.split(" "));
          }
          if (swiper.isElement) {
            bullets.forEach((bulletEl, bulletIndex) => {
              bulletEl.setAttribute("part", bulletIndex === current ? "bullet-active" : "bullet");
            });
          }
          if (params.dynamicBullets) {
            const firstDisplayedBullet = bullets[firstIndex];
            const lastDisplayedBullet = bullets[lastIndex];
            for (let i6 = firstIndex; i6 <= lastIndex; i6 += 1) {
              if (bullets[i6]) {
                bullets[i6].classList.add(...`${params.bulletActiveClass}-main`.split(" "));
              }
            }
            setSideBullets(firstDisplayedBullet, "prev");
            setSideBullets(lastDisplayedBullet, "next");
          }
        }
        if (params.dynamicBullets) {
          const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
          const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
          const offsetProp = rtl ? "right" : "left";
          bullets.forEach((bullet) => {
            bullet.style[swiper.isHorizontal() ? offsetProp : "top"] = `${bulletsOffset}px`;
          });
        }
      }
      el.forEach((subEl, subElIndex) => {
        if (params.type === "fraction") {
          subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach((fractionEl) => {
            fractionEl.textContent = params.formatFractionCurrent(current + 1);
          });
          subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach((totalEl) => {
            totalEl.textContent = params.formatFractionTotal(total);
          });
        }
        if (params.type === "progressbar") {
          let progressbarDirection;
          if (params.progressbarOpposite) {
            progressbarDirection = swiper.isHorizontal() ? "vertical" : "horizontal";
          } else {
            progressbarDirection = swiper.isHorizontal() ? "horizontal" : "vertical";
          }
          const scale2 = (current + 1) / total;
          let scaleX = 1;
          let scaleY = 1;
          if (progressbarDirection === "horizontal") {
            scaleX = scale2;
          } else {
            scaleY = scale2;
          }
          subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach((progressEl) => {
            progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;
            progressEl.style.transitionDuration = `${swiper.params.speed}ms`;
          });
        }
        if (params.type === "custom" && params.renderCustom) {
          subEl.innerHTML = params.renderCustom(swiper, current + 1, total);
          if (subElIndex === 0) emit("paginationRender", subEl);
        } else {
          if (subElIndex === 0) emit("paginationRender", subEl);
          emit("paginationUpdate", subEl);
        }
        if (swiper.params.watchOverflow && swiper.enabled) {
          subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass);
        }
      });
    }
    function render3() {
      const params = swiper.params.pagination;
      if (isPaginationDisabled()) return;
      const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.grid && swiper.params.grid.rows > 1 ? swiper.slides.length / Math.ceil(swiper.params.grid.rows) : swiper.slides.length;
      let el = swiper.pagination.el;
      el = makeElementsArray(el);
      let paginationHTML = "";
      if (params.type === "bullets") {
        let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
        if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {
          numberOfBullets = slidesLength;
        }
        for (let i6 = 0; i6 < numberOfBullets; i6 += 1) {
          if (params.renderBullet) {
            paginationHTML += params.renderBullet.call(swiper, i6, params.bulletClass);
          } else {
            paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part="bullet"' : ""} class="${params.bulletClass}"></${params.bulletElement}>`;
          }
        }
      }
      if (params.type === "fraction") {
        if (params.renderFraction) {
          paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
        } else {
          paginationHTML = `<span class="${params.currentClass}"></span> / <span class="${params.totalClass}"></span>`;
        }
      }
      if (params.type === "progressbar") {
        if (params.renderProgressbar) {
          paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
        } else {
          paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
        }
      }
      swiper.pagination.bullets = [];
      el.forEach((subEl) => {
        if (params.type !== "custom") {
          subEl.innerHTML = paginationHTML || "";
        }
        if (params.type === "bullets") {
          swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));
        }
      });
      if (params.type !== "custom") {
        emit("paginationRender", el[0]);
      }
    }
    function init5() {
      swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
        el: "swiper-pagination"
      });
      const params = swiper.params.pagination;
      if (!params.el) return;
      let el;
      if (typeof params.el === "string" && swiper.isElement) {
        el = swiper.el.querySelector(params.el);
      }
      if (!el && typeof params.el === "string") {
        el = [...document.querySelectorAll(params.el)];
      }
      if (!el) {
        el = params.el;
      }
      if (!el || el.length === 0) return;
      if (swiper.params.uniqueNavElements && typeof params.el === "string" && Array.isArray(el) && el.length > 1) {
        el = [...swiper.el.querySelectorAll(params.el)];
        if (el.length > 1) {
          el = el.filter((subEl) => {
            if (elementParents(subEl, ".swiper")[0] !== swiper.el) return false;
            return true;
          })[0];
        }
      }
      if (Array.isArray(el) && el.length === 1) el = el[0];
      Object.assign(swiper.pagination, {
        el
      });
      el = makeElementsArray(el);
      el.forEach((subEl) => {
        if (params.type === "bullets" && params.clickable) {
          subEl.classList.add(...(params.clickableClass || "").split(" "));
        }
        subEl.classList.add(params.modifierClass + params.type);
        subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
        if (params.type === "bullets" && params.dynamicBullets) {
          subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);
          dynamicBulletIndex = 0;
          if (params.dynamicMainBullets < 1) {
            params.dynamicMainBullets = 1;
          }
        }
        if (params.type === "progressbar" && params.progressbarOpposite) {
          subEl.classList.add(params.progressbarOppositeClass);
        }
        if (params.clickable) {
          subEl.addEventListener("click", onBulletClick);
        }
        if (!swiper.enabled) {
          subEl.classList.add(params.lockClass);
        }
      });
    }
    function destroy() {
      const params = swiper.params.pagination;
      if (isPaginationDisabled()) return;
      let el = swiper.pagination.el;
      if (el) {
        el = makeElementsArray(el);
        el.forEach((subEl) => {
          subEl.classList.remove(params.hiddenClass);
          subEl.classList.remove(params.modifierClass + params.type);
          subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
          if (params.clickable) {
            subEl.classList.remove(...(params.clickableClass || "").split(" "));
            subEl.removeEventListener("click", onBulletClick);
          }
        });
      }
      if (swiper.pagination.bullets) swiper.pagination.bullets.forEach((subEl) => subEl.classList.remove(...params.bulletActiveClass.split(" ")));
    }
    on("changeDirection", () => {
      if (!swiper.pagination || !swiper.pagination.el) return;
      const params = swiper.params.pagination;
      let {
        el
      } = swiper.pagination;
      el = makeElementsArray(el);
      el.forEach((subEl) => {
        subEl.classList.remove(params.horizontalClass, params.verticalClass);
        subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
      });
    });
    on("init", () => {
      if (swiper.params.pagination.enabled === false) {
        disable();
      } else {
        init5();
        render3();
        update2();
      }
    });
    on("activeIndexChange", () => {
      if (typeof swiper.snapIndex === "undefined") {
        update2();
      }
    });
    on("snapIndexChange", () => {
      update2();
    });
    on("snapGridLengthChange", () => {
      render3();
      update2();
    });
    on("destroy", () => {
      destroy();
    });
    on("enable disable", () => {
      let {
        el
      } = swiper.pagination;
      if (el) {
        el = makeElementsArray(el);
        el.forEach((subEl) => subEl.classList[swiper.enabled ? "remove" : "add"](swiper.params.pagination.lockClass));
      }
    });
    on("lock unlock", () => {
      update2();
    });
    on("click", (_s, e5) => {
      const targetEl = e5.target;
      const el = makeElementsArray(swiper.pagination.el);
      if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {
        if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
        const isHidden3 = el[0].classList.contains(swiper.params.pagination.hiddenClass);
        if (isHidden3 === true) {
          emit("paginationShow");
        } else {
          emit("paginationHide");
        }
        el.forEach((subEl) => subEl.classList.toggle(swiper.params.pagination.hiddenClass));
      }
    });
    const enable = () => {
      swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);
      let {
        el
      } = swiper.pagination;
      if (el) {
        el = makeElementsArray(el);
        el.forEach((subEl) => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));
      }
      init5();
      render3();
      update2();
    };
    const disable = () => {
      swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);
      let {
        el
      } = swiper.pagination;
      if (el) {
        el = makeElementsArray(el);
        el.forEach((subEl) => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));
      }
      destroy();
    };
    Object.assign(swiper.pagination, {
      enable,
      disable,
      render: render3,
      update: update2,
      init: init5,
      destroy
    });
  }

  // node_modules/swiper/modules/autoplay.mjs
  function Autoplay(_ref) {
    let {
      swiper,
      extendParams,
      on,
      emit,
      params
    } = _ref;
    swiper.autoplay = {
      running: false,
      paused: false,
      timeLeft: 0
    };
    extendParams({
      autoplay: {
        enabled: false,
        delay: 3e3,
        waitForTransition: true,
        disableOnInteraction: false,
        stopOnLastSlide: false,
        reverseDirection: false,
        pauseOnMouseEnter: false
      }
    });
    let timeout;
    let raf;
    let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3e3;
    let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3e3;
    let autoplayTimeLeft;
    let autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();
    let wasPaused;
    let isTouched;
    let pausedByTouch;
    let touchStartTimeout;
    let slideChanged;
    let pausedByInteraction;
    let pausedByPointerEnter;
    function onTransitionEnd(e5) {
      if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;
      if (e5.target !== swiper.wrapperEl) return;
      swiper.wrapperEl.removeEventListener("transitionend", onTransitionEnd);
      if (pausedByPointerEnter || e5.detail && e5.detail.bySwiperTouchMove) {
        return;
      }
      resume();
    }
    const calcTimeLeft = () => {
      if (swiper.destroyed || !swiper.autoplay.running) return;
      if (swiper.autoplay.paused) {
        wasPaused = true;
      } else if (wasPaused) {
        autoplayDelayCurrent = autoplayTimeLeft;
        wasPaused = false;
      }
      const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - (/* @__PURE__ */ new Date()).getTime();
      swiper.autoplay.timeLeft = timeLeft;
      emit("autoplayTimeLeft", timeLeft, timeLeft / autoplayDelayTotal);
      raf = requestAnimationFrame(() => {
        calcTimeLeft();
      });
    };
    const getSlideDelay = () => {
      let activeSlideEl;
      if (swiper.virtual && swiper.params.virtual.enabled) {
        activeSlideEl = swiper.slides.filter((slideEl) => slideEl.classList.contains("swiper-slide-active"))[0];
      } else {
        activeSlideEl = swiper.slides[swiper.activeIndex];
      }
      if (!activeSlideEl) return void 0;
      const currentSlideDelay = parseInt(activeSlideEl.getAttribute("data-swiper-autoplay"), 10);
      return currentSlideDelay;
    };
    const run = (delayForce) => {
      if (swiper.destroyed || !swiper.autoplay.running) return;
      cancelAnimationFrame(raf);
      calcTimeLeft();
      let delay3 = typeof delayForce === "undefined" ? swiper.params.autoplay.delay : delayForce;
      autoplayDelayTotal = swiper.params.autoplay.delay;
      autoplayDelayCurrent = swiper.params.autoplay.delay;
      const currentSlideDelay = getSlideDelay();
      if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === "undefined") {
        delay3 = currentSlideDelay;
        autoplayDelayTotal = currentSlideDelay;
        autoplayDelayCurrent = currentSlideDelay;
      }
      autoplayTimeLeft = delay3;
      const speed = swiper.params.speed;
      const proceed = () => {
        if (!swiper || swiper.destroyed) return;
        if (swiper.params.autoplay.reverseDirection) {
          if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {
            swiper.slidePrev(speed, true, true);
            emit("autoplay");
          } else if (!swiper.params.autoplay.stopOnLastSlide) {
            swiper.slideTo(swiper.slides.length - 1, speed, true, true);
            emit("autoplay");
          }
        } else {
          if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {
            swiper.slideNext(speed, true, true);
            emit("autoplay");
          } else if (!swiper.params.autoplay.stopOnLastSlide) {
            swiper.slideTo(0, speed, true, true);
            emit("autoplay");
          }
        }
        if (swiper.params.cssMode) {
          autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();
          requestAnimationFrame(() => {
            run();
          });
        }
      };
      if (delay3 > 0) {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
          proceed();
        }, delay3);
      } else {
        requestAnimationFrame(() => {
          proceed();
        });
      }
      return delay3;
    };
    const start = () => {
      autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();
      swiper.autoplay.running = true;
      run();
      emit("autoplayStart");
    };
    const stop = () => {
      swiper.autoplay.running = false;
      clearTimeout(timeout);
      cancelAnimationFrame(raf);
      emit("autoplayStop");
    };
    const pause = (internal, reset) => {
      if (swiper.destroyed || !swiper.autoplay.running) return;
      clearTimeout(timeout);
      if (!internal) {
        pausedByInteraction = true;
      }
      const proceed = () => {
        emit("autoplayPause");
        if (swiper.params.autoplay.waitForTransition) {
          swiper.wrapperEl.addEventListener("transitionend", onTransitionEnd);
        } else {
          resume();
        }
      };
      swiper.autoplay.paused = true;
      if (reset) {
        if (slideChanged) {
          autoplayTimeLeft = swiper.params.autoplay.delay;
        }
        slideChanged = false;
        proceed();
        return;
      }
      const delay3 = autoplayTimeLeft || swiper.params.autoplay.delay;
      autoplayTimeLeft = delay3 - ((/* @__PURE__ */ new Date()).getTime() - autoplayStartTime);
      if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;
      if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;
      proceed();
    };
    const resume = () => {
      if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;
      autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();
      if (pausedByInteraction) {
        pausedByInteraction = false;
        run(autoplayTimeLeft);
      } else {
        run();
      }
      swiper.autoplay.paused = false;
      emit("autoplayResume");
    };
    const onVisibilityChange = () => {
      if (swiper.destroyed || !swiper.autoplay.running) return;
      const document2 = getDocument();
      if (document2.visibilityState === "hidden") {
        pausedByInteraction = true;
        pause(true);
      }
      if (document2.visibilityState === "visible") {
        resume();
      }
    };
    const onPointerEnter = (e5) => {
      if (e5.pointerType !== "mouse") return;
      pausedByInteraction = true;
      pausedByPointerEnter = true;
      if (swiper.animating || swiper.autoplay.paused) return;
      pause(true);
    };
    const onPointerLeave = (e5) => {
      if (e5.pointerType !== "mouse") return;
      pausedByPointerEnter = false;
      if (swiper.autoplay.paused) {
        resume();
      }
    };
    const attachMouseEvents = () => {
      if (swiper.params.autoplay.pauseOnMouseEnter) {
        swiper.el.addEventListener("pointerenter", onPointerEnter);
        swiper.el.addEventListener("pointerleave", onPointerLeave);
      }
    };
    const detachMouseEvents = () => {
      if (swiper.el && typeof swiper.el !== "string") {
        swiper.el.removeEventListener("pointerenter", onPointerEnter);
        swiper.el.removeEventListener("pointerleave", onPointerLeave);
      }
    };
    const attachDocumentEvents = () => {
      const document2 = getDocument();
      document2.addEventListener("visibilitychange", onVisibilityChange);
    };
    const detachDocumentEvents = () => {
      const document2 = getDocument();
      document2.removeEventListener("visibilitychange", onVisibilityChange);
    };
    on("init", () => {
      if (swiper.params.autoplay.enabled) {
        attachMouseEvents();
        attachDocumentEvents();
        start();
      }
    });
    on("destroy", () => {
      detachMouseEvents();
      detachDocumentEvents();
      if (swiper.autoplay.running) {
        stop();
      }
    });
    on("_freeModeStaticRelease", () => {
      if (pausedByTouch || pausedByInteraction) {
        resume();
      }
    });
    on("_freeModeNoMomentumRelease", () => {
      if (!swiper.params.autoplay.disableOnInteraction) {
        pause(true, true);
      } else {
        stop();
      }
    });
    on("beforeTransitionStart", (_s, speed, internal) => {
      if (swiper.destroyed || !swiper.autoplay.running) return;
      if (internal || !swiper.params.autoplay.disableOnInteraction) {
        pause(true, true);
      } else {
        stop();
      }
    });
    on("sliderFirstMove", () => {
      if (swiper.destroyed || !swiper.autoplay.running) return;
      if (swiper.params.autoplay.disableOnInteraction) {
        stop();
        return;
      }
      isTouched = true;
      pausedByTouch = false;
      pausedByInteraction = false;
      touchStartTimeout = setTimeout(() => {
        pausedByInteraction = true;
        pausedByTouch = true;
        pause(true);
      }, 200);
    });
    on("touchEnd", () => {
      if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;
      clearTimeout(touchStartTimeout);
      clearTimeout(timeout);
      if (swiper.params.autoplay.disableOnInteraction) {
        pausedByTouch = false;
        isTouched = false;
        return;
      }
      if (pausedByTouch && swiper.params.cssMode) resume();
      pausedByTouch = false;
      isTouched = false;
    });
    on("slideChange", () => {
      if (swiper.destroyed || !swiper.autoplay.running) return;
      slideChanged = true;
    });
    Object.assign(swiper.autoplay, {
      start,
      stop,
      pause,
      resume
    });
  }

  // node_modules/gsap/utils/strings.js
  var emojiExp = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;
  function getText(e5) {
    var type = e5.nodeType, result = "";
    if (type === 1 || type === 9 || type === 11) {
      if (typeof e5.textContent === "string") {
        return e5.textContent;
      } else {
        for (e5 = e5.firstChild; e5; e5 = e5.nextSibling) {
          result += getText(e5);
        }
      }
    } else if (type === 3 || type === 4) {
      return e5.nodeValue;
    }
    return result;
  }

  // node_modules/gsap/SplitText.js
  var _doc3;
  var _win3;
  var _coreInitted2;
  var gsap2;
  var _context2;
  var _toArray;
  var _stripExp = /(?:\r|\n|\t\t)/g;
  var _multipleSpacesExp = /(?:\s\s+)/g;
  var _nonBreakingSpace = String.fromCharCode(160);
  var _initCore3 = function _initCore4(core) {
    _doc3 = document;
    _win3 = window;
    gsap2 = gsap2 || core || _win3.gsap || console.warn("Please gsap.registerPlugin(SplitText)");
    if (gsap2) {
      _toArray = gsap2.utils.toArray;
      _context2 = gsap2.core.context || function() {
      };
      _coreInitted2 = 1;
    }
  };
  var _bonusValidated = 1;
  var _getComputedStyle = function _getComputedStyle2(element) {
    return _win3.getComputedStyle(element);
  };
  var _isAbsolute = function _isAbsolute2(vars) {
    return vars.position === "absolute" || vars.absolute === true;
  };
  var _findSpecialChars = function _findSpecialChars2(text2, chars) {
    var i6 = chars.length, s4;
    while (--i6 > -1) {
      s4 = chars[i6];
      if (text2.substr(0, s4.length) === s4) {
        return s4.length;
      }
    }
  };
  var _divStart = " style='position:relative;display:inline-block;'";
  var _cssClassFunc = function _cssClassFunc2(cssClass, tag) {
    if (cssClass === void 0) {
      cssClass = "";
    }
    var iterate = ~cssClass.indexOf("++"), num = 1;
    if (iterate) {
      cssClass = cssClass.split("++").join("");
    }
    return function() {
      return "<" + tag + _divStart + (cssClass ? " class='" + cssClass + (iterate ? num++ : "") + "'>" : ">");
    };
  };
  var _swapText = function _swapText2(element, oldText, newText) {
    var type = element.nodeType;
    if (type === 1 || type === 9 || type === 11) {
      for (element = element.firstChild; element; element = element.nextSibling) {
        _swapText2(element, oldText, newText);
      }
    } else if (type === 3 || type === 4) {
      element.nodeValue = element.nodeValue.split(oldText).join(newText);
    }
  };
  var _pushReversed = function _pushReversed2(a5, merge) {
    var i6 = merge.length;
    while (--i6 > -1) {
      a5.push(merge[i6]);
    }
  };
  var _isBeforeWordDelimiter = function _isBeforeWordDelimiter2(e5, root, wordDelimiter) {
    var next;
    while (e5 && e5 !== root) {
      next = e5._next || e5.nextSibling;
      if (next) {
        return next.textContent.charAt(0) === wordDelimiter;
      }
      e5 = e5.parentNode || e5._parent;
    }
  };
  var _deWordify = function _deWordify2(e5) {
    var children = _toArray(e5.childNodes), l6 = children.length, i6, child;
    for (i6 = 0; i6 < l6; i6++) {
      child = children[i6];
      if (child._isSplit) {
        _deWordify2(child);
      } else {
        if (i6 && child.previousSibling && child.previousSibling.nodeType === 3) {
          child.previousSibling.nodeValue += child.nodeType === 3 ? child.nodeValue : child.firstChild.nodeValue;
          e5.removeChild(child);
        } else if (child.nodeType !== 3) {
          e5.insertBefore(child.firstChild, child);
          e5.removeChild(child);
        }
      }
    }
  };
  var _getStyleAsNumber = function _getStyleAsNumber2(name2, computedStyle) {
    return parseFloat(computedStyle[name2]) || 0;
  };
  var _setPositionsAfterSplit = function _setPositionsAfterSplit2(element, vars, allChars, allWords, allLines, origWidth, origHeight) {
    var cs = _getComputedStyle(element), paddingLeft = _getStyleAsNumber("paddingLeft", cs), lineOffsetY = -999, borderTopAndBottom = _getStyleAsNumber("borderBottomWidth", cs) + _getStyleAsNumber("borderTopWidth", cs), borderLeftAndRight = _getStyleAsNumber("borderLeftWidth", cs) + _getStyleAsNumber("borderRightWidth", cs), padTopAndBottom = _getStyleAsNumber("paddingTop", cs) + _getStyleAsNumber("paddingBottom", cs), padLeftAndRight = _getStyleAsNumber("paddingLeft", cs) + _getStyleAsNumber("paddingRight", cs), lineThreshold = _getStyleAsNumber("fontSize", cs) * (vars.lineThreshold || 0.2), textAlign = cs.textAlign, charArray = [], wordArray = [], lineArray = [], wordDelimiter = vars.wordDelimiter || " ", tag = vars.tag ? vars.tag : vars.span ? "span" : "div", types = vars.type || vars.split || "chars,words,lines", lines = allLines && ~types.indexOf("lines") ? [] : null, words = ~types.indexOf("words"), chars = ~types.indexOf("chars"), absolute = _isAbsolute(vars), linesClass = vars.linesClass, iterateLine = ~(linesClass || "").indexOf("++"), spaceNodesToRemove = [], isFlex = cs.display === "flex", prevInlineDisplay = element.style.display, i6, j3, l6, node, nodes, isChild, curLine, addWordSpaces, style, lineNode, lineWidth, offset;
    iterateLine && (linesClass = linesClass.split("++").join(""));
    isFlex && (element.style.display = "block");
    j3 = element.getElementsByTagName("*");
    l6 = j3.length;
    nodes = [];
    for (i6 = 0; i6 < l6; i6++) {
      nodes[i6] = j3[i6];
    }
    if (lines || absolute) {
      for (i6 = 0; i6 < l6; i6++) {
        node = nodes[i6];
        isChild = node.parentNode === element;
        if (isChild || absolute || chars && !words) {
          offset = node.offsetTop;
          if (lines && isChild && Math.abs(offset - lineOffsetY) > lineThreshold && (node.nodeName !== "BR" || i6 === 0)) {
            curLine = [];
            lines.push(curLine);
            lineOffsetY = offset;
          }
          if (absolute) {
            node._x = node.offsetLeft;
            node._y = offset;
            node._w = node.offsetWidth;
            node._h = node.offsetHeight;
          }
          if (lines) {
            if (node._isSplit && isChild || !chars && isChild || words && isChild || !words && node.parentNode.parentNode === element && !node.parentNode._isSplit) {
              curLine.push(node);
              node._x -= paddingLeft;
              if (_isBeforeWordDelimiter(node, element, wordDelimiter)) {
                node._wordEnd = true;
              }
            }
            if (node.nodeName === "BR" && (node.nextSibling && node.nextSibling.nodeName === "BR" || i6 === 0)) {
              lines.push([]);
            }
          }
        }
      }
    }
    for (i6 = 0; i6 < l6; i6++) {
      node = nodes[i6];
      isChild = node.parentNode === element;
      if (node.nodeName === "BR") {
        if (lines || absolute) {
          node.parentNode && node.parentNode.removeChild(node);
          nodes.splice(i6--, 1);
          l6--;
        } else if (!words) {
          element.appendChild(node);
        }
        continue;
      }
      if (absolute) {
        style = node.style;
        if (!words && !isChild) {
          node._x += node.parentNode._x;
          node._y += node.parentNode._y;
        }
        style.left = node._x + "px";
        style.top = node._y + "px";
        style.position = "absolute";
        style.display = "block";
        style.width = node._w + 1 + "px";
        style.height = node._h + "px";
      }
      if (!words && chars) {
        if (node._isSplit) {
          node._next = j3 = node.nextSibling;
          node.parentNode.appendChild(node);
          while (j3 && j3.nodeType === 3 && j3.textContent === " ") {
            node._next = j3.nextSibling;
            node.parentNode.appendChild(j3);
            j3 = j3.nextSibling;
          }
        } else if (node.parentNode._isSplit) {
          node._parent = node.parentNode;
          if (!node.previousSibling && node.firstChild) {
            node.firstChild._isFirst = true;
          }
          if (node.nextSibling && node.nextSibling.textContent === " " && !node.nextSibling.nextSibling) {
            spaceNodesToRemove.push(node.nextSibling);
          }
          node._next = node.nextSibling && node.nextSibling._isFirst ? null : node.nextSibling;
          node.parentNode.removeChild(node);
          nodes.splice(i6--, 1);
          l6--;
        } else if (!isChild) {
          offset = !node.nextSibling && _isBeforeWordDelimiter(node.parentNode, element, wordDelimiter);
          node.parentNode._parent && node.parentNode._parent.appendChild(node);
          offset && node.parentNode.appendChild(_doc3.createTextNode(" "));
          if (tag === "span") {
            node.style.display = "inline";
          }
          charArray.push(node);
        }
      } else if (node.parentNode._isSplit && !node._isSplit && node.innerHTML !== "") {
        wordArray.push(node);
      } else if (chars && !node._isSplit) {
        if (tag === "span") {
          node.style.display = "inline";
        }
        charArray.push(node);
      }
    }
    i6 = spaceNodesToRemove.length;
    while (--i6 > -1) {
      spaceNodesToRemove[i6].parentNode.removeChild(spaceNodesToRemove[i6]);
    }
    if (lines) {
      if (absolute) {
        lineNode = _doc3.createElement(tag);
        element.appendChild(lineNode);
        lineWidth = lineNode.offsetWidth + "px";
        offset = lineNode.offsetParent === element ? 0 : element.offsetLeft;
        element.removeChild(lineNode);
      }
      style = element.style.cssText;
      element.style.cssText = "display:none;";
      while (element.firstChild) {
        element.removeChild(element.firstChild);
      }
      addWordSpaces = wordDelimiter === " " && (!absolute || !words && !chars);
      for (i6 = 0; i6 < lines.length; i6++) {
        curLine = lines[i6];
        lineNode = _doc3.createElement(tag);
        lineNode.style.cssText = "display:block;text-align:" + textAlign + ";position:" + (absolute ? "absolute;" : "relative;");
        if (linesClass) {
          lineNode.className = linesClass + (iterateLine ? i6 + 1 : "");
        }
        lineArray.push(lineNode);
        l6 = curLine.length;
        for (j3 = 0; j3 < l6; j3++) {
          if (curLine[j3].nodeName !== "BR") {
            node = curLine[j3];
            lineNode.appendChild(node);
            addWordSpaces && node._wordEnd && lineNode.appendChild(_doc3.createTextNode(" "));
            if (absolute) {
              if (j3 === 0) {
                lineNode.style.top = node._y + "px";
                lineNode.style.left = paddingLeft + offset + "px";
              }
              node.style.top = "0px";
              if (offset) {
                node.style.left = node._x - offset + "px";
              }
            }
          }
        }
        if (l6 === 0) {
          lineNode.innerHTML = "&nbsp;";
        } else if (!words && !chars) {
          _deWordify(lineNode);
          _swapText(lineNode, String.fromCharCode(160), " ");
        }
        if (absolute) {
          lineNode.style.width = lineWidth;
          lineNode.style.height = node._h + "px";
        }
        element.appendChild(lineNode);
      }
      element.style.cssText = style;
    }
    if (absolute) {
      if (origHeight > element.clientHeight) {
        element.style.height = origHeight - padTopAndBottom + "px";
        if (element.clientHeight < origHeight) {
          element.style.height = origHeight + borderTopAndBottom + "px";
        }
      }
      if (origWidth > element.clientWidth) {
        element.style.width = origWidth - padLeftAndRight + "px";
        if (element.clientWidth < origWidth) {
          element.style.width = origWidth + borderLeftAndRight + "px";
        }
      }
    }
    isFlex && (prevInlineDisplay ? element.style.display = prevInlineDisplay : element.style.removeProperty("display"));
    _pushReversed(allChars, charArray);
    words && _pushReversed(allWords, wordArray);
    _pushReversed(allLines, lineArray);
  };
  var _splitRawText = function _splitRawText2(element, vars, wordStart, charStart) {
    var tag = vars.tag ? vars.tag : vars.span ? "span" : "div", types = vars.type || vars.split || "chars,words,lines", chars = ~types.indexOf("chars"), absolute = _isAbsolute(vars), wordDelimiter = vars.wordDelimiter || " ", isWordDelimiter = function isWordDelimiter2(_char) {
      return _char === wordDelimiter || _char === _nonBreakingSpace && wordDelimiter === " ";
    }, space = wordDelimiter !== " " ? "" : absolute ? "&#173; " : " ", wordEnd = "</" + tag + ">", wordIsOpen = 1, specialChars = vars.specialChars ? typeof vars.specialChars === "function" ? vars.specialChars : _findSpecialChars : null, text2, splitText, i6, j3, l6, character, hasTagStart, testResult, container = _doc3.createElement("div"), parent2 = element.parentNode;
    parent2.insertBefore(container, element);
    container.textContent = element.nodeValue;
    parent2.removeChild(element);
    element = container;
    text2 = getText(element);
    hasTagStart = text2.indexOf("<") !== -1;
    if (vars.reduceWhiteSpace !== false) {
      text2 = text2.replace(_multipleSpacesExp, " ").replace(_stripExp, "");
    }
    if (hasTagStart) {
      text2 = text2.split("<").join("{{LT}}");
    }
    l6 = text2.length;
    splitText = (text2.charAt(0) === " " ? space : "") + wordStart();
    for (i6 = 0; i6 < l6; i6++) {
      character = text2.charAt(i6);
      if (specialChars && (testResult = specialChars(text2.substr(i6), vars.specialChars))) {
        character = text2.substr(i6, testResult || 1);
        splitText += chars && character !== " " ? charStart() + character + "</" + tag + ">" : character;
        i6 += testResult - 1;
      } else if (isWordDelimiter(character) && !isWordDelimiter(text2.charAt(i6 - 1)) && i6) {
        splitText += wordIsOpen ? wordEnd : "";
        wordIsOpen = 0;
        while (isWordDelimiter(text2.charAt(i6 + 1))) {
          splitText += space;
          i6++;
        }
        if (i6 === l6 - 1) {
          splitText += space;
        } else if (text2.charAt(i6 + 1) !== ")") {
          splitText += space + wordStart();
          wordIsOpen = 1;
        }
      } else if (character === "{" && text2.substr(i6, 6) === "{{LT}}") {
        splitText += chars ? charStart() + "{{LT}}</" + tag + ">" : "{{LT}}";
        i6 += 5;
      } else if (character.charCodeAt(0) >= 55296 && character.charCodeAt(0) <= 56319 || text2.charCodeAt(i6 + 1) >= 65024 && text2.charCodeAt(i6 + 1) <= 65039) {
        j3 = ((text2.substr(i6, 12).split(emojiExp) || [])[1] || "").length || 2;
        splitText += chars && character !== " " ? charStart() + text2.substr(i6, j3) + "</" + tag + ">" : text2.substr(i6, j3);
        i6 += j3 - 1;
      } else {
        splitText += chars && character !== " " ? charStart() + character + "</" + tag + ">" : character;
      }
    }
    element.outerHTML = splitText + (wordIsOpen ? wordEnd : "");
    hasTagStart && _swapText(parent2, "{{LT}}", "<");
  };
  var _split = function _split2(element, vars, wordStart, charStart) {
    var children = _toArray(element.childNodes), l6 = children.length, absolute = _isAbsolute(vars), i6, child;
    if (element.nodeType !== 3 || l6 > 1) {
      vars.absolute = false;
      for (i6 = 0; i6 < l6; i6++) {
        child = children[i6];
        child._next = child._isFirst = child._parent = child._wordEnd = null;
        if (child.nodeType !== 3 || /\S+/.test(child.nodeValue)) {
          if (absolute && child.nodeType !== 3 && _getComputedStyle(child).display === "inline") {
            child.style.display = "inline-block";
            child.style.position = "relative";
          }
          child._isSplit = true;
          _split2(child, vars, wordStart, charStart);
        }
      }
      vars.absolute = absolute;
      element._isSplit = true;
      return;
    }
    _splitRawText(element, vars, wordStart, charStart);
  };
  var SplitText = /* @__PURE__ */ function() {
    function SplitText2(element, vars) {
      _coreInitted2 || _initCore3();
      this.elements = _toArray(element);
      this.chars = [];
      this.words = [];
      this.lines = [];
      this._originals = [];
      this.vars = vars || {};
      _context2(this);
      _bonusValidated && this.split(vars);
    }
    var _proto = SplitText2.prototype;
    _proto.split = function split(vars) {
      this.isSplit && this.revert();
      this.vars = vars = vars || this.vars;
      this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
      var i6 = this.elements.length, tag = vars.tag ? vars.tag : vars.span ? "span" : "div", wordStart = _cssClassFunc(vars.wordsClass, tag), charStart = _cssClassFunc(vars.charsClass, tag), origHeight, origWidth, e5;
      while (--i6 > -1) {
        e5 = this.elements[i6];
        this._originals[i6] = {
          html: e5.innerHTML,
          style: e5.getAttribute("style")
        };
        origHeight = e5.clientHeight;
        origWidth = e5.clientWidth;
        _split(e5, vars, wordStart, charStart);
        _setPositionsAfterSplit(e5, vars, this.chars, this.words, this.lines, origWidth, origHeight);
      }
      this.chars.reverse();
      this.words.reverse();
      this.lines.reverse();
      this.isSplit = true;
      return this;
    };
    _proto.revert = function revert() {
      var originals = this._originals;
      if (!originals) {
        throw "revert() call wasn't scoped properly.";
      }
      this.elements.forEach(function(e5, i6) {
        e5.innerHTML = originals[i6].html;
        e5.setAttribute("style", originals[i6].style);
      });
      this.chars = [];
      this.words = [];
      this.lines = [];
      this.isSplit = false;
      return this;
    };
    SplitText2.create = function create(element, vars) {
      return new SplitText2(element, vars);
    };
    return SplitText2;
  }();
  SplitText.version = "3.12.5";
  SplitText.register = _initCore3;

  // assets/scripts/modules/Blockquote.js
  gsapWithCSS.registerPlugin(SplitText);
  var _Blockquote = class _Blockquote extends _default {
    constructor(m3) {
      super(m3);
      this.onResize = this.onResize.bind(this);
      this.onPrevClick = this.onPrevClick.bind(this);
      this.onNextClick = this.onNextClick.bind(this);
      this.$swiper = this.$("swiper")[0];
      this.$prevButton = this.$("prev")[0];
      this.$nextButton = this.$("next")[0];
      this.$contents = Array.from(this.$("content"));
      this.$items = Array.from(this.$("item"));
      this.$slides = Array.from(this.$("slide"));
      this.activeIndex = -1;
      this.prevIndex = -2;
    }
    // =============================================================================
    // Lifecycle
    // =============================================================================
    init() {
      whenReady(FONT.EAGER).then((fonts) => this.onFontsLoaded(fonts));
      this.bindEvents();
      requestAnimationFrame(() => {
        this.setCarousel();
        this.reSplit();
        this.computeMaxHeight();
      });
    }
    destroy() {
      super.destroy();
      this.unbindEvents();
    }
    // =============================================================================
    // Events
    // =============================================================================
    bindEvents() {
      this.unbindScreenListener = $screenDebounce.listen(this.onResize);
    }
    unbindEvents() {
      var _a;
      (_a = this.unbindScreenListener) == null ? void 0 : _a.call(this);
      this.destroyCustomCarousel();
      this.destroySwiper();
    }
    // =============================================================================
    // Callbacks
    // =============================================================================
    onFontsLoaded(fonts) {
      this.setCarousel();
      this.reSplit();
      this.computeMaxHeight();
    }
    onResize({ width: width2, height: height2 }) {
      this.setCarousel();
      this.reSplit();
      this.computeMaxHeight();
    }
    onPrevClick() {
      this.setActive(-1);
    }
    onNextClick() {
      this.setActive(1);
    }
    // =============================================================================
    // Methods
    // =============================================================================
    setCarousel() {
      if (window.matchMedia(`${_Blockquote.MQ_SM}`).matches && !this.swiper) {
        this.initSwiper();
        this.destroyCustomCarousel();
      } else if (!window.matchMedia(`${_Blockquote.MQ_SM}`).matches && this.swiper) {
        this.destroySwiper();
        this.initCustomCarousel();
      } else if (!window.matchMedia(`${_Blockquote.MQ_SM}`).matches) {
        this.initCustomCarousel();
      }
    }
    initSwiper() {
      this.resetSplit();
      this.swiper = new Swiper(this.$swiper, {
        modules: [Navigation],
        speed: 400,
        loop: true,
        navigation: {
          prevEl: this.$prevButton,
          nextEl: this.$nextButton
        }
      });
    }
    destroySwiper() {
      var _a;
      (_a = this.swiper) == null ? void 0 : _a.destroy(true, true);
      this.swiper = null;
    }
    initCustomCarousel() {
      var _a, _b;
      (_a = this.$prevButton) == null ? void 0 : _a.addEventListener("click", this.onPrevClick);
      (_b = this.$nextButton) == null ? void 0 : _b.addEventListener("click", this.onNextClick);
      this.activeIndex = -1;
      this.prevIndex = -2;
      this.setActive(1);
    }
    destroyCustomCarousel() {
      var _a, _b;
      (_a = this.$prevButton) == null ? void 0 : _a.removeEventListener("click", this.onPrevClick);
      (_b = this.$nextButton) == null ? void 0 : _b.removeEventListener("click", this.onNextClick);
    }
    split() {
      this.splitObject = new SplitText(this.$contents, {
        type: "words",
        tag: "span"
      });
      const wordByItems = [];
      this.splitObject.words.forEach((word, i6) => {
        this.$items.forEach(($item, itemsIndex) => {
          if ($item.contains(word)) {
            if (!wordByItems[itemsIndex]) {
              wordByItems[itemsIndex] = [];
            }
            wordByItems[itemsIndex].push(word);
          }
        });
      });
      wordByItems.forEach((words) => {
        words.forEach((word, wordIndex) => {
          word.style.setProperty("--word-index", wordIndex);
        });
      });
    }
    reSplit() {
      var _a, _b;
      if (this.swiper) return;
      (_b = (_a = this.splitObject) == null ? void 0 : _a.revert) == null ? void 0 : _b.call(_a);
      requestAnimationFrame(() => {
        this.split();
      });
    }
    resetSplit() {
      var _a, _b;
      (_b = (_a = this.splitObject) == null ? void 0 : _a.revert) == null ? void 0 : _b.call(_a);
    }
    computeMaxHeight() {
      if (this.swiper) return;
      this.el.style.setProperty("--slide-height", `auto`);
      requestAnimationFrame(() => {
        const maxHeight = Math.max(...this.$items.map(($item) => $item.offsetHeight));
        this.el.style.setProperty("--slide-height", `${maxHeight}px`);
      });
    }
    setActive(increment) {
      var _a, _b, _c;
      (_a = this.$slides[this.prevIndex]) == null ? void 0 : _a.classList.remove(_Blockquote.PREV_CLASS);
      this.activeIndex = (this.activeIndex + increment) % this.$slides.length;
      this.activeIndex = this.activeIndex < 0 ? this.$slides.length - 1 : this.activeIndex;
      this.prevIndex = this.activeIndex === 0 ? this.$slides.length - 1 : this.activeIndex - 1;
      if (this.$slides.length > 1) {
        for (const $slide of this.$slides) {
          $slide.classList.remove(_Blockquote.ACTIVE_CLASS);
        }
        (_b = this.$slides[this.activeIndex]) == null ? void 0 : _b.classList.remove(_Blockquote.PREV_CLASS);
        (_c = this.$slides[this.prevIndex]) == null ? void 0 : _c.classList.add(_Blockquote.PREV_CLASS);
      }
      requestAnimationFrame(() => {
        var _a2;
        (_a2 = this.$slides[this.activeIndex]) == null ? void 0 : _a2.classList.add(_Blockquote.ACTIVE_CLASS);
      });
    }
  };
  __publicField(_Blockquote, "MQ_SM", `(max-width: 699px)`);
  __publicField(_Blockquote, "PREV_CLASS", "is-prev");
  __publicField(_Blockquote, "ACTIVE_CLASS", "is-active");
  var Blockquote = _Blockquote;

  // assets/scripts/constants/carousel-args.js
  var CAROUSEL_DEFAULT_OPTS = ({
    modules,
    $prevButton,
    $nextButton,
    updateCallback,
    isPrefersReducedMotion = false
  }) => {
    return {
      modules,
      speed: isPrefersReducedMotion ? 0 : 400,
      effect: isPrefersReducedMotion ? "fade" : "slide",
      loop: false,
      slidesPerView: 1.1,
      spaceBetween: 10,
      navigation: {
        prevEl: $prevButton,
        nextEl: $nextButton
      },
      breakpoints: {
        700: {
          slidesPerView: 2,
          spaceBetween: 20
        },
        1e3: {
          slidesPerView: 3,
          spaceBetween: 20
        },
        1200: {
          slidesPerView: 4,
          spaceBetween: 20
        }
      },
      on: {
        init: updateCallback ? updateCallback : () => {
        },
        breakpoint: updateCallback ? updateCallback : () => {
        },
        destroy: updateCallback ? updateCallback : () => {
        }
      }
    };
  };
  var CAROUSEL_HERO_NEWS_OPTS = ({
    modules,
    $swiper,
    $prevButton,
    $nextButton,
    $pagination,
    updateCallback,
    isPrefersReducedMotion = false
  }) => {
    return {
      modules,
      speed: isPrefersReducedMotion ? 0 : 400,
      effect: isPrefersReducedMotion ? "fade" : "slide",
      loop: true,
      slidesPerView: 1,
      navigation: {
        prevEl: $prevButton,
        nextEl: $nextButton
      },
      pagination: {
        el: $pagination,
        type: "fraction",
        formatFractionCurrent: (number) => {
          return number < 10 ? `0${number}` : number;
        },
        formatFractionTotal: (number) => {
          return number < 10 ? `0${number}` : number;
        }
      },
      autoplay: isPrefersReducedMotion ? false : {
        delay: 4e3,
        disableOnInteraction: false,
        pauseOnMouseEnter: true
      },
      on: {
        init: updateCallback ? updateCallback : () => {
        },
        breakpoint: updateCallback ? updateCallback : () => {
        },
        destroy: updateCallback ? updateCallback : () => {
        },
        autoplayTimeLeft: (s4, time2, progress) => {
          $swiper.style.setProperty("--autoplay-progress", 1 - progress);
        }
      }
    };
  };

  // assets/scripts/stores/prefers-reduced-motion.js
  var motionQuery = matchMedia("(prefers-reduced-motion)");
  var $prefersReducedMotion = atom(motionQuery.matches);
  motionQuery.addEventListener("change", () => {
    if (motionQuery.matches) {
      $prefersReducedMotion.set(true);
    } else {
      $prefersReducedMotion.set(false);
    }
  });

  // assets/scripts/modules/Carousel.js
  var Carousel = class extends _default {
    constructor(m3) {
      super(m3);
      this.onUpdateTabIndex = this.onUpdateTabIndex.bind(this);
      this.onClearTabIndex = this.onClearTabIndex.bind(this);
      this.onPrefersReducedMotionChange = this.onPrefersReducedMotionChange.bind(this);
      this.play = this.play.bind(this);
      this.pause = this.pause.bind(this);
      this.$swiper = this.$("swiper")[0];
      this.$prevButton = this.$("prev")[0];
      this.$nextButton = this.$("next")[0];
      this.$pagination = this.$("pagination")[0];
      this.swiper = null;
      this.type = this.getData("type");
      this.isInview = false;
    }
    // =============================================================================
    // Lifecycle
    // =============================================================================
    init() {
      this.unbindPrefersReducedMotion = $prefersReducedMotion.subscribe(
        this.onPrefersReducedMotionChange
      );
    }
    destroy() {
      var _a;
      super.destroy();
      this.destroySwiper();
      (_a = this.unbindPrefersReducedMotion) == null ? void 0 : _a.call(this);
    }
    // =============================================================================
    // Callbacks
    // =============================================================================
    onInview({ way }) {
      if (way === "enter" && !this.isInview) {
        this.play();
        this.isInview = true;
      } else if (way === "leave" && this.isInview) {
        this.pause();
        this.isInview = false;
      }
    }
    onUpdateTabIndex(args) {
      const { slides, activeIndex } = args;
      const $currentSlide = slides[activeIndex];
      const $otherSlides = slides.filter(($slide) => $slide !== $currentSlide);
      $otherSlides.forEach(($slide) => {
        const $tabbulableElements2 = $slide.querySelectorAll(
          "a, button, input, select, textarea, [tabindex]"
        );
        $tabbulableElements2.forEach(($element) => {
          $element.setAttribute("tabindex", "-1");
          $element.removeEventListener("focus", this.pause);
          $element.removeEventListener("blur", this.play);
        });
      });
      const $tabbulableElements = $currentSlide.querySelectorAll(
        "a, button, input, select, textarea, [tabindex]"
      );
      $tabbulableElements.forEach(($element) => {
        $element.removeAttribute("tabindex");
        $element.addEventListener("focus", this.pause);
        $element.addEventListener("blur", this.play);
      });
    }
    onClearTabIndex(args) {
      const { slides } = args;
      slides.forEach(($slide) => {
        const $tabbulableElements = $slide.querySelectorAll(
          "a, button, input, select, textarea, [tabindex]"
        );
        $tabbulableElements.forEach(($element) => {
          $element.removeAttribute("tabindex");
          $element.removeEventListener("focus", this.pause);
          $element.removeEventListener("blur", this.play);
        });
      });
    }
    onPrefersReducedMotionChange() {
      this.destroySwiper();
      this.initSwiper();
    }
    // =============================================================================
    // Methods
    // =============================================================================
    initSwiper() {
      var _a;
      let argsFunction;
      let modules;
      switch (this.type) {
        case "hero-news":
          argsFunction = CAROUSEL_HERO_NEWS_OPTS;
          modules = [Navigation, Pagination, Autoplay];
          break;
        default:
          argsFunction = CAROUSEL_DEFAULT_OPTS;
          modules = [Navigation];
          break;
      }
      const args = argsFunction({
        modules,
        $swiper: this.$swiper,
        $prevButton: this.$prevButton,
        $nextButton: this.$nextButton,
        $pagination: this.$pagination,
        isPrefersReducedMotion: $prefersReducedMotion.value
      });
      this.swiper = new Swiper(this.$swiper, __spreadValues({ init: false }, args));
      (_a = this.swiper.autoplay) == null ? void 0 : _a.pause();
      this.swiper.on("slideChange", this.onUpdateTabIndex);
      this.swiper.on("init", this.onUpdateTabIndex);
      this.swiper.on("destroy", this.onClearTabIndex);
      this.swiper.init();
    }
    destroySwiper() {
      var _a;
      (_a = this.swiper) == null ? void 0 : _a.destroy(true, true);
    }
    play() {
      var _a, _b;
      !$prefersReducedMotion.value && ((_b = (_a = this.swiper) == null ? void 0 : _a.autoplay) == null ? void 0 : _b.resume());
    }
    pause() {
      var _a, _b;
      !$prefersReducedMotion.value && ((_b = (_a = this.swiper) == null ? void 0 : _a.autoplay) == null ? void 0 : _b.pause());
    }
  };
  __publicField(Carousel, "CONTROLS_CLASS", "has-slider-controls");

  // assets/scripts/utils/is.js
  var localStorageAvailable = null;
  var sessionStorageAvailable = null;
  var isLocalStorageAvailable = () => {
    return localStorageAvailable != null ? localStorageAvailable : localStorageAvailable = isStorageAvailable(window.localStorage);
  };
  var isSessionStorageAvailable = () => {
    return sessionStorageAvailable != null ? sessionStorageAvailable : sessionStorageAvailable = isStorageAvailable(window.sessionStorage);
  };
  function isStorageAvailable(storage) {
    try {
      const x3 = "__storage_test__";
      storage.setItem(x3, x3);
      storage.removeItem(x3);
      return true;
    } catch (error) {
      return error instanceof DOMException && // everything except Firefox
      (error.code === 22 || // Firefox
      error.code === 1014 || // test name field too, because code might not be present
      // everything except Firefox
      error.name === "QuotaExceededError" || // Firefox
      error.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
      storage && storage.length !== 0;
    }
  }

  // node_modules/vanilla-cookieconsent/dist/cookieconsent.esm.js
  var cookieconsent_esm_exports = {};
  __export(cookieconsent_esm_exports, {
    acceptCategory: () => Ve,
    acceptService: () => Le,
    acceptedCategory: () => Ie,
    acceptedService: () => je,
    eraseCookies: () => Pe,
    getConfig: () => Qe,
    getCookie: () => Ke,
    getUserPreferences: () => $e,
    hide: () => Re,
    hidePreferences: () => Ge,
    loadScript: () => ze,
    reset: () => Ye,
    run: () => Xe,
    setCookieData: () => qe,
    setLanguage: () => Ue,
    show: () => Oe,
    showPreferences: () => Be,
    validConsent: () => We,
    validCookie: () => Fe
  });
  var e = "opt-in";
  var t = "opt-out";
  var o = "show--consent";
  var n = "show--preferences";
  var a = "disable--interaction";
  var s = "data-category";
  var c = "div";
  var r = "button";
  var i = "aria-hidden";
  var l = "btn-group";
  var d = "click";
  var f = "data-role";
  var _ = "consentModal";
  var u = "preferencesModal";
  var p = class {
    constructor() {
      this.t = { mode: e, revision: 0, autoShow: true, lazyHtmlGeneration: true, autoClearCookies: true, manageScriptTags: true, hideFromBots: true, cookie: { name: "cc_cookie", expiresAfterDays: 182, domain: "", path: "/", sameSite: "Lax" } }, this.o = { i: {}, l: "", _: {}, u: {}, p: {}, m: [], v: false, h: null, C: null, S: null, M: "", D: true, T: false, k: false, A: false, N: false, H: [], V: false, I: true, L: [], j: false, F: "", P: false, O: [], R: [], B: [], G: [], J: false, U: false, $: false, q: [], K: [], W: [], X: {}, Y: {}, Z: {}, ee: {}, te: {}, oe: [] }, this.ne = { ae: {}, se: {} }, this.ce = {}, this.re = { ie: "cc:onFirstConsent", le: "cc:onConsent", de: "cc:onChange", fe: "cc:onModalShow", _e: "cc:onModalHide", ue: "cc:onModalReady" };
    }
  };
  var m = new p();
  var g = (e5, t4) => e5.indexOf(t4);
  var b = (e5, t4) => -1 !== g(e5, t4);
  var v = (e5) => Array.isArray(e5);
  var y = (e5) => "string" == typeof e5;
  var h = (e5) => !!e5 && "object" == typeof e5 && !v(e5);
  var C = (e5) => "function" == typeof e5;
  var w = (e5) => Object.keys(e5);
  var S = (e5) => Array.from(new Set(e5));
  var x = () => document.activeElement;
  var M = (e5) => e5.preventDefault();
  var D = (e5, t4) => e5.querySelectorAll(t4);
  var T = (e5) => e5.dispatchEvent(new Event("change"));
  var k = (e5) => {
    const t4 = document.createElement(e5);
    return e5 === r && (t4.type = e5), t4;
  };
  var E = (e5, t4, o5) => e5.setAttribute(t4, o5);
  var A = (e5, t4, o5) => {
    e5.removeAttribute(o5 ? "data-" + t4 : t4);
  };
  var N = (e5, t4, o5) => e5.getAttribute(o5 ? "data-" + t4 : t4);
  var H = (e5, t4) => e5.appendChild(t4);
  var V = (e5, t4) => e5.classList.add(t4);
  var I = (e5, t4) => V(e5, "cm__" + t4);
  var L = (e5, t4) => V(e5, "pm__" + t4);
  var j = (e5, t4) => e5.classList.remove(t4);
  var F = (e5) => {
    if ("object" != typeof e5) return e5;
    if (e5 instanceof Date) return new Date(e5.getTime());
    let t4 = Array.isArray(e5) ? [] : {};
    for (let o5 in e5) {
      let n6 = e5[o5];
      t4[o5] = F(n6);
    }
    return t4;
  };
  var P = () => {
    const e5 = {}, { O: t4, X: o5, Y: n6 } = m.o;
    for (const a5 of t4) e5[a5] = G(n6[a5], w(o5[a5]));
    return e5;
  };
  var O = (e5, t4) => dispatchEvent(new CustomEvent(e5, { detail: t4 }));
  var R = (e5, t4, o5, n6) => {
    e5.addEventListener(t4, o5), n6 && m.o.m.push({ pe: e5, me: t4, ge: o5 });
  };
  var B = () => {
    const e5 = m.t.cookie.expiresAfterDays;
    return C(e5) ? e5(m.o.F) : e5;
  };
  var G = (e5, t4) => {
    const o5 = e5 || [], n6 = t4 || [];
    return o5.filter((e6) => !b(n6, e6)).concat(n6.filter((e6) => !b(o5, e6)));
  };
  var J = (e5) => {
    m.o.R = S(e5), m.o.F = (() => {
      let e6 = "custom";
      const { R: t4, O: o5, B: n6 } = m.o, a5 = t4.length;
      return a5 === o5.length ? e6 = "all" : a5 === n6.length && (e6 = "necessary"), e6;
    })();
  };
  var U = (e5, t4, o5, n6) => {
    const a5 = "accept-", { show: s4, showPreferences: c4, hide: r6, hidePreferences: i6, acceptCategory: l6 } = t4, f3 = e5 || document, _3 = (e6) => D(f3, `[data-cc="${e6}"]`), u3 = (e6, t5) => {
      M(e6), l6(t5), i6(), r6();
    }, p3 = _3("show-preferencesModal"), g3 = _3("show-consentModal"), b3 = _3(a5 + "all"), v2 = _3(a5 + "necessary"), y3 = _3(a5 + "custom"), h2 = m.t.lazyHtmlGeneration;
    for (const e6 of p3) E(e6, "aria-haspopup", "dialog"), R(e6, d, (e7) => {
      M(e7), c4();
    }), h2 && (R(e6, "mouseenter", (e7) => {
      M(e7), m.o.N || o5(t4, n6);
    }, true), R(e6, "focus", () => {
      m.o.N || o5(t4, n6);
    }));
    for (let e6 of g3) E(e6, "aria-haspopup", "dialog"), R(e6, d, (e7) => {
      M(e7), s4(true);
    }, true);
    for (let e6 of b3) R(e6, d, (e7) => {
      u3(e7, "all");
    }, true);
    for (let e6 of y3) R(e6, d, (e7) => {
      u3(e7);
    }, true);
    for (let e6 of v2) R(e6, d, (e7) => {
      u3(e7, []);
    }, true);
  };
  var $ = (e5, t4) => {
    e5 && (t4 && (e5.tabIndex = -1), e5.focus(), t4 && e5.removeAttribute("tabindex"));
  };
  var z = (e5, t4) => {
    const o5 = (n6) => {
      n6.target.removeEventListener("transitionend", o5), "opacity" === n6.propertyName && "1" === getComputedStyle(e5).opacity && $(((e6) => 1 === e6 ? m.ne.be : m.ne.ve)(t4));
    };
    R(e5, "transitionend", o5);
  };
  var q;
  var K = (e5) => {
    clearTimeout(q), e5 ? V(m.ne.ye, a) : q = setTimeout(() => {
      j(m.ne.ye, a);
    }, 500);
  };
  var Q = ["M 19.5 4.5 L 4.5 19.5 M 4.5 4.501 L 19.5 19.5", "M 3.572 13.406 L 8.281 18.115 L 20.428 5.885", "M 21.999 6.94 L 11.639 17.18 L 2.001 6.82 "];
  var W = (e5 = 0, t4 = 1.5) => `<svg viewBox="0 0 24 24" stroke-width="${t4}"><path d="${Q[e5]}"/></svg>`;
  var X = (e5) => {
    const t4 = m.ne, o5 = m.o;
    ((e6) => {
      const n6 = e6 === t4.he, a5 = o5.i.disablePageInteraction ? t4.ye : n6 ? t4.Ce : t4.ye;
      R(a5, "keydown", (t5) => {
        if ("Tab" !== t5.key || !(n6 ? o5.k && !o5.A : o5.A)) return;
        const a6 = x(), s4 = n6 ? o5.q : o5.K;
        0 !== s4.length && (t5.shiftKey ? a6 !== s4[0] && e6.contains(a6) || (M(t5), $(s4[1])) : a6 !== s4[1] && e6.contains(a6) || (M(t5), $(s4[0])));
      }, true);
    })(e5);
  };
  var Y = ["[href]", r, "input", "details", "[tabindex]"].map((e5) => e5 + ':not([tabindex="-1"])').join(",");
  var Z = (e5) => {
    const { o: t4, ne: o5 } = m, n6 = (e6, t5) => {
      const o6 = D(e6, Y);
      t5[0] = o6[0], t5[1] = o6[o6.length - 1];
    };
    1 === e5 && t4.T && n6(o5.he, t4.q), 2 === e5 && t4.N && n6(o5.we, t4.K);
  };
  var ee = (e5, t4, o5) => {
    const { de: n6, le: a5, ie: s4, _e: c4, ue: r6, fe: i6 } = m.ce, l6 = m.re;
    if (t4) {
      const n7 = { modalName: t4 };
      return e5 === l6.fe ? C(i6) && i6(n7) : e5 === l6._e ? C(c4) && c4(n7) : (n7.modal = o5, C(r6) && r6(n7)), O(e5, n7);
    }
    const d3 = { cookie: m.o.p };
    e5 === l6.ie ? C(s4) && s4(F(d3)) : e5 === l6.le ? C(a5) && a5(F(d3)) : (d3.changedCategories = m.o.L, d3.changedServices = m.o.ee, C(n6) && n6(F(d3))), O(e5, F(d3));
  };
  var te = (e5, t4) => {
    try {
      return e5();
    } catch (e6) {
      return !t4 && console.warn("CookieConsent:", e6), false;
    }
  };
  var oe = (e5) => {
    const { Y: t4, ee: o5, O: n6, X: a5, oe: c4, p: r6, L: i6 } = m.o;
    for (const e6 of n6) {
      const n7 = o5[e6] || t4[e6] || [];
      for (const o6 of n7) {
        const n8 = a5[e6][o6];
        if (!n8) continue;
        const { onAccept: s4, onReject: c5 } = n8;
        !n8.Se && b(t4[e6], o6) ? (n8.Se = true, C(s4) && s4()) : n8.Se && !b(t4[e6], o6) && (n8.Se = false, C(c5) && c5());
      }
    }
    if (!m.t.manageScriptTags) return;
    const l6 = c4, d3 = e5 || r6.categories || [], f3 = (e6, n7) => {
      if (n7 >= e6.length) return;
      const a6 = c4[n7];
      if (a6.xe) return f3(e6, n7 + 1);
      const r7 = a6.Me, l7 = a6.De, _3 = a6.Te, u3 = b(d3, l7), p3 = !!_3 && b(t4[l7], _3);
      if (!_3 && !a6.ke && u3 || !_3 && a6.ke && !u3 && b(i6, l7) || _3 && !a6.ke && p3 || _3 && a6.ke && !p3 && b(o5[l7] || [], _3)) {
        a6.xe = true;
        const t5 = N(r7, "type", true);
        A(r7, "type", !!t5), A(r7, s);
        let o6 = N(r7, "src", true);
        o6 && A(r7, "src", true);
        const c5 = k("script");
        c5.textContent = r7.innerHTML;
        for (const { nodeName: e7 } of r7.attributes) E(c5, e7, r7[e7] || N(r7, e7));
        t5 && (c5.type = t5), o6 ? c5.src = o6 : o6 = r7.src;
        const i7 = !!o6 && (!t5 || ["text/javascript", "module"].includes(t5));
        if (i7 && (c5.onload = c5.onerror = () => {
          f3(e6, ++n7);
        }), r7.replaceWith(c5), i7) return;
      }
      f3(e6, ++n7);
    };
    f3(l6, 0);
  };
  var ne = "bottom";
  var ae = "left";
  var se = "center";
  var ce = "right";
  var re = "inline";
  var ie = "wide";
  var le = "pm--";
  var de = ["middle", "top", ne];
  var fe = [ae, se, ce];
  var _e = { box: { Ee: [ie, re], Ae: de, Ne: fe, He: ne, Ve: ce }, cloud: { Ee: [re], Ae: de, Ne: fe, He: ne, Ve: se }, bar: { Ee: [re], Ae: de.slice(1), Ne: [], He: ne, Ve: "" } };
  var ue = { box: { Ee: [], Ae: [], Ne: [], He: "", Ve: "" }, bar: { Ee: [ie], Ae: [], Ne: [ae, ce], He: "", Ve: ae } };
  var pe = (e5) => {
    const t4 = m.o.i.guiOptions, o5 = t4 && t4.consentModal, n6 = t4 && t4.preferencesModal;
    0 === e5 && me(m.ne.he, _e, o5, "cm--", "box", "cm"), 1 === e5 && me(m.ne.we, ue, n6, le, "box", "pm");
  };
  var me = (e5, t4, o5, n6, a5, s4) => {
    e5.className = s4;
    const c4 = o5 && o5.layout, r6 = o5 && o5.position, i6 = o5 && o5.flipButtons, l6 = !o5 || false !== o5.equalWeightButtons, d3 = c4 && c4.split(" ") || [], f3 = d3[0], _3 = d3[1], u3 = f3 in t4 ? f3 : a5, p3 = t4[u3], g3 = b(p3.Ee, _3) && _3, v2 = r6 && r6.split(" ") || [], y3 = v2[0], h2 = n6 === le ? v2[0] : v2[1], C3 = b(p3.Ae, y3) ? y3 : p3.He, w3 = b(p3.Ne, h2) ? h2 : p3.Ve, S3 = (t5) => {
      t5 && V(e5, n6 + t5);
    };
    S3(u3), S3(g3), S3(C3), S3(w3), i6 && S3("flip");
    const x3 = s4 + "__btn--secondary";
    if ("cm" === s4) {
      const { Ie: e6, Le: t5 } = m.ne;
      e6 && (l6 ? j(e6, x3) : V(e6, x3)), t5 && (l6 ? j(t5, x3) : V(t5, x3));
    } else {
      const { je: e6 } = m.ne;
      e6 && (l6 ? j(e6, x3) : V(e6, x3));
    }
  };
  var ge = (e5, t4) => {
    const o5 = m.o, n6 = m.ne, { hide: a5, hidePreferences: s4, acceptCategory: _3 } = e5, p3 = (e6) => {
      _3(e6), s4(), a5();
    }, g3 = o5.u && o5.u.preferencesModal;
    if (!g3) return;
    const b3 = g3.title, v2 = g3.closeIconLabel, C3 = g3.acceptAllBtn, S3 = g3.acceptNecessaryBtn, x3 = g3.savePreferencesBtn, M3 = g3.sections || [], D3 = C3 || S3 || x3;
    if (n6.Fe) n6.Pe = k(c), L(n6.Pe, "body");
    else {
      n6.Fe = k(c), V(n6.Fe, "pm-wrapper");
      const e6 = k("div");
      V(e6, "pm-overlay"), H(n6.Fe, e6), R(e6, d, s4), n6.we = k(c), V(n6.we, "pm"), E(n6.we, "role", "dialog"), E(n6.we, i, true), E(n6.we, "aria-modal", true), E(n6.we, "aria-labelledby", "pm__title"), R(n6.ye, "keydown", (e7) => {
        27 === e7.keyCode && s4();
      }, true), n6.Oe = k(c), L(n6.Oe, "header"), n6.Re = k("h2"), L(n6.Re, "title"), n6.Re.id = "pm__title", n6.Be = k(r), L(n6.Be, "close-btn"), E(n6.Be, "aria-label", g3.closeIconLabel || ""), R(n6.Be, d, s4), n6.Ge = k("span"), n6.Ge.innerHTML = W(), H(n6.Be, n6.Ge), n6.Je = k(c), L(n6.Je, "body"), n6.Ue = k(c), L(n6.Ue, "footer");
      var T3 = k(c);
      V(T3, "btns");
      var A3 = k(c), N3 = k(c);
      L(A3, l), L(N3, l), H(n6.Ue, A3), H(n6.Ue, N3), H(n6.Oe, n6.Re), H(n6.Oe, n6.Be), n6.ve = k(c), E(n6.ve, "tabIndex", -1), H(n6.we, n6.ve), H(n6.we, n6.Oe), H(n6.we, n6.Je), D3 && H(n6.we, n6.Ue), H(n6.Fe, n6.we);
    }
    let I3;
    b3 && (n6.Re.innerHTML = b3, v2 && E(n6.Be, "aria-label", v2)), M3.forEach((e6, t5) => {
      const a6 = e6.title, s5 = e6.description, l6 = e6.linkedCategory, f3 = l6 && o5.P[l6], _4 = e6.cookieTable, u3 = _4 && _4.body, p4 = _4 && _4.caption, m3 = u3 && u3.length > 0, b4 = !!f3, v3 = b4 && o5.X[l6], C4 = h(v3) && w(v3) || [], S4 = b4 && (!!s5 || !!m3 || w(v3).length > 0);
      var x4 = k(c);
      if (L(x4, "section"), S4 || s5) {
        var M4 = k(c);
        L(M4, "section-desc-wrapper");
      }
      let D4 = C4.length;
      if (S4 && D4 > 0) {
        const e7 = k(c);
        L(e7, "section-services");
        for (const t6 of C4) {
          const o6 = v3[t6], n7 = o6 && o6.label || t6, a7 = k(c), s6 = k(c), r6 = k(c), i6 = k(c);
          L(a7, "service"), L(i6, "service-title"), L(s6, "service-header"), L(r6, "service-icon");
          const d3 = be(n7, t6, f3, true, l6);
          i6.innerHTML = n7, H(s6, r6), H(s6, i6), H(a7, s6), H(a7, d3), H(e7, a7);
        }
        H(M4, e7);
      }
      if (a6) {
        var T4 = k(c), A4 = k(b4 ? r : c);
        if (L(T4, "section-title-wrapper"), L(A4, "section-title"), A4.innerHTML = a6, H(T4, A4), b4) {
          const e7 = k("span");
          e7.innerHTML = W(2, 3.5), L(e7, "section-arrow"), H(T4, e7), x4.className += "--toggle";
          const t6 = be(a6, l6, f3);
          let o6 = g3.serviceCounterLabel;
          if (D4 > 0 && y(o6)) {
            let e8 = k("span");
            L(e8, "badge"), L(e8, "service-counter"), E(e8, i, true), E(e8, "data-servicecounter", D4), o6 && (o6 = o6.split("|"), o6 = o6.length > 1 && D4 > 1 ? o6[1] : o6[0], E(e8, "data-counterlabel", o6)), e8.innerHTML = D4 + (o6 ? " " + o6 : ""), H(A4, e8);
          }
          if (S4) {
            L(x4, "section--expandable");
            var N4 = l6 + "-desc";
            E(A4, "aria-expanded", false), E(A4, "aria-controls", N4);
          }
          H(T4, t6);
        } else E(A4, "role", "heading"), E(A4, "aria-level", "3");
        H(x4, T4);
      }
      if (s5) {
        var F2 = k("p");
        L(F2, "section-desc"), F2.innerHTML = s5, H(M4, F2);
      }
      if (S4 && (E(M4, i, "true"), M4.id = N4, ((e7, t6, o6) => {
        R(A4, d, () => {
          t6.classList.contains("is-expanded") ? (j(t6, "is-expanded"), E(o6, "aria-expanded", "false"), E(e7, i, "true")) : (V(t6, "is-expanded"), E(o6, "aria-expanded", "true"), E(e7, i, "false"));
        });
      })(M4, x4, A4), m3)) {
        const e7 = k("table"), o6 = k("thead"), a7 = k("tbody");
        if (p4) {
          const t6 = k("caption");
          L(t6, "table-caption"), t6.innerHTML = p4, e7.appendChild(t6);
        }
        L(e7, "section-table"), L(o6, "table-head"), L(a7, "table-body");
        const s6 = _4.headers, r6 = w(s6), i6 = n6.$e.createDocumentFragment(), l7 = k("tr");
        for (const e8 of r6) {
          const o7 = s6[e8], n7 = k("th");
          n7.id = "cc__row-" + o7 + t5, E(n7, "scope", "col"), L(n7, "table-th"), n7.innerHTML = o7, H(i6, n7);
        }
        H(l7, i6), H(o6, l7);
        const d3 = n6.$e.createDocumentFragment();
        for (const e8 of u3) {
          const o7 = k("tr");
          L(o7, "table-tr");
          for (const n7 of r6) {
            const a8 = s6[n7], r7 = e8[n7], i7 = k("td"), l8 = k(c);
            L(i7, "table-td"), E(i7, "data-column", a8), E(i7, "headers", "cc__row-" + a8 + t5), l8.insertAdjacentHTML("beforeend", r7), H(i7, l8), H(o7, i7);
          }
          H(d3, o7);
        }
        H(a7, d3), H(e7, o6), H(e7, a7), H(M4, e7);
      }
      (S4 || s5) && H(x4, M4);
      const P3 = n6.Pe || n6.Je;
      b4 ? (I3 || (I3 = k(c), L(I3, "section-toggles")), I3.appendChild(x4)) : I3 = null, H(P3, I3 || x4);
    }), C3 && (n6.ze || (n6.ze = k(r), L(n6.ze, "btn"), E(n6.ze, f, "all"), H(A3, n6.ze), R(n6.ze, d, () => p3("all"))), n6.ze.innerHTML = C3), S3 && (n6.je || (n6.je = k(r), L(n6.je, "btn"), E(n6.je, f, "necessary"), H(A3, n6.je), R(n6.je, d, () => p3([]))), n6.je.innerHTML = S3), x3 && (n6.qe || (n6.qe = k(r), L(n6.qe, "btn"), L(n6.qe, "btn--secondary"), E(n6.qe, f, "save"), H(N3, n6.qe), R(n6.qe, d, () => p3())), n6.qe.innerHTML = x3), n6.Pe && (n6.we.replaceChild(n6.Pe, n6.Je), n6.Je = n6.Pe), pe(1), o5.N || (o5.N = true, ee(m.re.ue, u, n6.we), t4(e5), H(n6.Ce, n6.Fe), X(n6.we), setTimeout(() => V(n6.Fe, "cc--anim"), 100)), Z(2);
  };
  function be(e5, t4, o5, n6, a5) {
    const c4 = m.o, r6 = m.ne, l6 = k("label"), f3 = k("input"), _3 = k("span"), u3 = k("span"), p3 = k("span"), g3 = k("span"), v2 = k("span");
    if (g3.innerHTML = W(1, 3), v2.innerHTML = W(0, 3), f3.type = "checkbox", V(l6, "section__toggle-wrapper"), V(f3, "section__toggle"), V(g3, "toggle__icon-on"), V(v2, "toggle__icon-off"), V(_3, "toggle__icon"), V(u3, "toggle__icon-circle"), V(p3, "toggle__label"), E(_3, i, "true"), n6 ? (V(l6, "toggle-service"), E(f3, s, a5), r6.se[a5][t4] = f3) : r6.ae[t4] = f3, n6 ? ((e6) => {
      R(f3, "change", () => {
        const t5 = r6.se[e6], o6 = r6.ae[e6];
        c4.Z[e6] = [];
        for (let o7 in t5) {
          const n7 = t5[o7];
          n7.checked && c4.Z[e6].push(n7.value);
        }
        o6.checked = c4.Z[e6].length > 0;
      });
    })(a5) : ((e6) => {
      R(f3, d, () => {
        const t5 = r6.se[e6], o6 = f3.checked;
        c4.Z[e6] = [];
        for (let n7 in t5) t5[n7].checked = o6, o6 && c4.Z[e6].push(n7);
      });
    })(t4), f3.value = t4, p3.textContent = e5.replace(/<.*>.*<\/.*>/gm, ""), H(u3, v2), H(u3, g3), H(_3, u3), c4.D) (o5.readOnly || o5.enabled) && (f3.checked = true);
    else if (n6) {
      const e6 = c4.Y[a5];
      f3.checked = o5.readOnly || b(e6, t4);
    } else b(c4.R, t4) && (f3.checked = true);
    return o5.readOnly && (f3.disabled = true), H(l6, f3), H(l6, _3), H(l6, p3), l6;
  }
  var ve = () => {
    const e5 = k("span");
    return m.ne.Ke || (m.ne.Ke = e5), e5;
  };
  var ye = (e5, t4) => {
    const o5 = m.o, n6 = m.ne, { hide: a5, showPreferences: s4, acceptCategory: u3 } = e5, p3 = o5.u && o5.u.consentModal;
    if (!p3) return;
    const g3 = p3.acceptAllBtn, b3 = p3.acceptNecessaryBtn, v2 = p3.showPreferencesBtn, y3 = p3.closeIconLabel, h2 = p3.footer, C3 = p3.label, w3 = p3.title, S3 = (e6) => {
      a5(), u3(e6);
    };
    if (!n6.Qe) {
      n6.Qe = k(c), n6.he = k(c), n6.We = k(c), n6.Xe = k(c), n6.Ye = k(c), V(n6.Qe, "cm-wrapper"), V(n6.he, "cm"), I(n6.We, "body"), I(n6.Xe, "texts"), I(n6.Ye, "btns"), E(n6.he, "role", "dialog"), E(n6.he, "aria-modal", "true"), E(n6.he, i, "false"), E(n6.he, "aria-describedby", "cm__desc"), C3 ? E(n6.he, "aria-label", C3) : w3 && E(n6.he, "aria-labelledby", "cm__title");
      const e6 = "box", t5 = o5.i.guiOptions, a6 = t5 && t5.consentModal, s5 = (a6 && a6.layout || e6).split(" ")[0] === e6;
      w3 && y3 && s5 && (n6.Le || (n6.Le = k(r), n6.Le.innerHTML = W(), I(n6.Le, "btn"), I(n6.Le, "btn--close"), R(n6.Le, d, () => {
        S3([]);
      }), H(n6.We, n6.Le)), E(n6.Le, "aria-label", y3)), H(n6.We, n6.Xe), (g3 || b3 || v2) && H(n6.We, n6.Ye), n6.be = k(c), E(n6.be, "tabIndex", -1), H(n6.he, n6.be), H(n6.he, n6.We), H(n6.Qe, n6.he);
    }
    w3 && (n6.Ze || (n6.Ze = k("h2"), n6.Ze.className = n6.Ze.id = "cm__title", H(n6.Xe, n6.Ze)), n6.Ze.innerHTML = w3);
    let x3 = p3.description;
    if (x3 && (o5.V && (x3 = x3.replace("{{revisionMessage}}", o5.I ? "" : p3.revisionMessage || "")), n6.et || (n6.et = k("p"), n6.et.className = n6.et.id = "cm__desc", H(n6.Xe, n6.et)), n6.et.innerHTML = x3), g3 && (n6.tt || (n6.tt = k(r), H(n6.tt, ve()), I(n6.tt, "btn"), E(n6.tt, f, "all"), R(n6.tt, d, () => {
      S3("all");
    })), n6.tt.firstElementChild.innerHTML = g3), b3 && (n6.Ie || (n6.Ie = k(r), H(n6.Ie, ve()), I(n6.Ie, "btn"), E(n6.Ie, f, "necessary"), R(n6.Ie, d, () => {
      S3([]);
    })), n6.Ie.firstElementChild.innerHTML = b3), v2 && (n6.ot || (n6.ot = k(r), H(n6.ot, ve()), I(n6.ot, "btn"), I(n6.ot, "btn--secondary"), E(n6.ot, f, "show"), R(n6.ot, "mouseenter", () => {
      o5.N || ge(e5, t4);
    }), R(n6.ot, d, s4)), n6.ot.firstElementChild.innerHTML = v2), n6.nt || (n6.nt = k(c), I(n6.nt, l), g3 && H(n6.nt, n6.tt), b3 && H(n6.nt, n6.Ie), (g3 || b3) && H(n6.We, n6.nt), H(n6.Ye, n6.nt)), n6.ot && !n6.st && (n6.st = k(c), n6.Ie && n6.tt ? (I(n6.st, l), H(n6.st, n6.ot), H(n6.Ye, n6.st)) : (H(n6.nt, n6.ot), I(n6.nt, l + "--uneven"))), h2) {
      if (!n6.ct) {
        let e6 = k(c), t5 = k(c);
        n6.ct = k(c), I(e6, "footer"), I(t5, "links"), I(n6.ct, "link-group"), H(t5, n6.ct), H(e6, t5), H(n6.he, e6);
      }
      n6.ct.innerHTML = h2;
    }
    pe(0), o5.T || (o5.T = true, ee(m.re.ue, _, n6.he), t4(e5), H(n6.Ce, n6.Qe), X(n6.he), setTimeout(() => V(n6.Qe, "cc--anim"), 100)), Z(1), U(n6.We, e5, ge, t4);
  };
  var he = (e5) => {
    if (!y(e5)) return null;
    if (e5 in m.o._) return e5;
    let t4 = e5.slice(0, 2);
    return t4 in m.o._ ? t4 : null;
  };
  var Ce = () => m.o.l || m.o.i.language.default;
  var we = (e5) => {
    e5 && (m.o.l = e5);
  };
  var Se = (e5) => __async(void 0, null, function* () {
    const t4 = m.o;
    let o5 = he(e5) ? e5 : Ce(), n6 = t4._[o5];
    return y(n6) ? n6 = yield ((e6) => __async(void 0, null, function* () {
      try {
        const t5 = yield fetch(e6);
        return yield t5.json();
      } catch (e7) {
        return console.error(e7), false;
      }
    }))(n6) : C(n6) && (n6 = yield n6()), !!n6 && (t4.u = n6, we(o5), true);
  });
  var xe = () => {
    let e5 = m.o.i.language.rtl, t4 = m.ne.Ce;
    e5 && t4 && (v(e5) || (e5 = [e5]), b(e5, m.o.l) ? V(t4, "cc--rtl") : j(t4, "cc--rtl"));
  };
  var Me = () => {
    const e5 = m.ne;
    if (e5.Ce) return;
    e5.Ce = k(c), e5.Ce.id = "cc-main", e5.Ce.setAttribute("data-nosnippet", ""), xe();
    let t4 = m.o.i.root;
    t4 && y(t4) && (t4 = document.querySelector(t4)), (t4 || e5.$e.body).appendChild(e5.Ce);
  };
  var De = (e5) => te(() => localStorage.removeItem(e5));
  var Te = (e5, t4) => {
    if (t4 instanceof RegExp) return e5.filter((e6) => t4.test(e6));
    {
      const o5 = g(e5, t4);
      return o5 > -1 ? [e5[o5]] : [];
    }
  };
  var ke = (e5) => {
    const { hostname: t4, protocol: o5 } = location, { name: n6, path: a5, domain: s4, sameSite: c4, useLocalStorage: r6 } = m.t.cookie, i6 = e5 ? (() => {
      const e6 = m.o.S, t5 = e6 ? /* @__PURE__ */ new Date() - e6 : 0;
      return 864e5 * B() - t5;
    })() : 864e5 * B(), l6 = /* @__PURE__ */ new Date();
    l6.setTime(l6.getTime() + i6), m.o.p.expirationTime = l6.getTime();
    const d3 = JSON.stringify(m.o.p);
    let f3 = n6 + "=" + encodeURIComponent(d3) + (0 !== i6 ? "; expires=" + l6.toUTCString() : "") + "; Path=" + a5 + "; SameSite=" + c4;
    b(t4, ".") && (f3 += "; Domain=" + s4), "https:" === o5 && (f3 += "; Secure"), r6 ? ((e6, t5) => {
      te(() => localStorage.setItem(e6, t5));
    })(n6, d3) : document.cookie = f3, m.o.p;
  };
  var Ee = (e5, t4, o5) => {
    if (0 === e5.length) return;
    const n6 = o5 || m.t.cookie.domain, a5 = t4 || m.t.cookie.path, s4 = "www." === n6.slice(0, 4), c4 = s4 && n6.substring(4), r6 = (e6, t5) => {
      document.cookie = e6 + "=; path=" + a5 + (t5 ? "; domain=." + t5 : "") + "; expires=Thu, 01 Jan 1970 00:00:01 GMT;";
    };
    for (const t5 of e5) r6(t5), r6(t5, n6), s4 && r6(t5, c4);
  };
  var Ae = (e5) => {
    const t4 = e5 || m.t.cookie.name, o5 = m.t.cookie.useLocalStorage;
    return ((e6, t5) => {
      let o6;
      return o6 = te(() => JSON.parse(t5 ? e6 : decodeURIComponent(e6)), true) || {}, o6;
    })(o5 ? (n6 = t4, te(() => localStorage.getItem(n6)) || "") : Ne(t4, true), o5);
    var n6;
  };
  var Ne = (e5, t4) => {
    const o5 = document.cookie.match("(^|;)\\s*" + e5 + "\\s*=\\s*([^;]+)");
    return o5 ? t4 ? o5.pop() : e5 : "";
  };
  var He = (e5) => {
    const t4 = document.cookie.split(/;\s*/), o5 = [];
    for (const n6 of t4) {
      let t5 = n6.split("=")[0];
      e5 ? te(() => {
        e5.test(t5) && o5.push(t5);
      }) : o5.push(t5);
    }
    return o5;
  };
  var Ve = (o5, n6 = []) => {
    ((e5, t4) => {
      const { O: o6, R: n7, B: a5, N: s4, Z: c4, G: r6, X: i6 } = m.o;
      let l6 = [];
      if (e5) {
        v(e5) ? l6.push(...e5) : y(e5) && (l6 = "all" === e5 ? o6 : [e5]);
        for (const e6 of o6) c4[e6] = b(l6, e6) ? w(i6[e6]) : [];
      } else l6 = [...n7, ...r6], s4 && (l6 = (() => {
        const e6 = m.ne.ae;
        if (!e6) return [];
        let t5 = [];
        for (let o7 in e6) e6[o7].checked && t5.push(o7);
        return t5;
      })());
      l6 = l6.filter((e6) => !b(o6, e6) || !b(t4, e6)), l6.push(...a5), J(l6);
    })(o5, n6), ((e5) => {
      const t4 = m.o, { Z: o6, B: n7, Y: a5, X: s4, O: c4 } = t4, r6 = c4;
      t4.te = F(a5);
      for (const e6 of r6) {
        const c5 = s4[e6], r7 = w(c5), i6 = o6[e6] && o6[e6].length > 0, l6 = b(n7, e6);
        if (0 !== r7.length) {
          if (a5[e6] = [], l6) a5[e6].push(...r7);
          else if (i6) {
            const t5 = o6[e6];
            a5[e6].push(...t5);
          } else a5[e6] = t4.Z[e6];
          a5[e6] = S(a5[e6]);
        }
      }
    })(), (() => {
      const o6 = m.o;
      o6.L = m.t.mode === t && o6.D ? G(o6.G, o6.R) : G(o6.R, o6.p.categories);
      let n7 = o6.L.length > 0, a5 = false;
      for (const e5 of o6.O) o6.ee[e5] = G(o6.Y[e5], o6.te[e5]), o6.ee[e5].length > 0 && (a5 = true);
      const s4 = m.ne.ae;
      for (const e5 in s4) s4[e5].checked = b(o6.R, e5);
      for (const e5 of o6.O) {
        const t4 = m.ne.se[e5], n8 = o6.Y[e5];
        for (const e6 in t4) t4[e6].checked = b(n8, e6);
      }
      o6.C || (o6.C = /* @__PURE__ */ new Date()), o6.M || (o6.M = ("10000000-1000-4000-8000" + -1e11).replace(/[018]/g, (e5) => (e5 ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> e5 / 4).toString(16))), o6.p = { categories: F(o6.R), revision: m.t.revision, data: o6.h, consentTimestamp: o6.C.toISOString(), consentId: o6.M, services: F(o6.Y) };
      let c4 = false;
      const r6 = n7 || a5;
      (o6.D || r6) && (o6.D && (o6.D = false, c4 = true), o6.S = o6.S ? /* @__PURE__ */ new Date() : o6.C, o6.p.lastConsentTimestamp = o6.S.toISOString(), ke(), m.t.autoClearCookies && (c4 || r6) && ((e5) => {
        const t4 = m.o, o7 = He(), n8 = ((e6) => {
          const t5 = m.o;
          return (e6 ? t5.O : t5.L).filter((e7) => {
            const o8 = t5.P[e7];
            return !!o8 && !o8.readOnly && !!o8.autoClear;
          });
        })(e5);
        for (const e6 in t4.ee) for (const n9 of t4.ee[e6]) {
          const a6 = t4.X[e6][n9].cookies;
          if (!b(t4.Y[e6], n9) && a6) for (const e7 of a6) {
            const t5 = Te(o7, e7.name);
            Ee(t5, e7.path, e7.domain);
          }
        }
        for (const a6 of n8) {
          const n9 = t4.P[a6].autoClear, s5 = n9 && n9.cookies || [], c5 = b(t4.L, a6), r7 = !b(t4.R, a6), i6 = c5 && r7;
          if (e5 ? r7 : i6) {
            n9.reloadPage && i6 && (t4.j = true);
            for (const e6 of s5) {
              const t5 = Te(o7, e6.name);
              Ee(t5, e6.path, e6.domain);
            }
          }
        }
      })(c4), oe()), c4 && (ee(m.re.ie), ee(m.re.le), m.t.mode === e) || (r6 && ee(m.re.de), o6.j && (o6.j = false, location.reload()));
    })();
  };
  var Ie = (e5) => {
    const t4 = m.o.D ? [] : m.o.R;
    return b(t4, e5);
  };
  var Le = (e5, t4) => {
    const { O: o5, X: n6 } = m.o;
    if (!(e5 && t4 && y(t4) && b(o5, t4) && 0 !== w(n6[t4]).length)) return false;
    ((e6, t5) => {
      const o6 = m.o, { X: n7, Z: a5, N: s4 } = o6, c4 = m.ne.se[t5] || {}, r6 = m.ne.ae[t5] || {}, i6 = w(n7[t5]);
      if (a5[t5] = [], y(e6)) {
        if ("all" === e6) {
          if (a5[t5].push(...i6), s4) for (let e7 in c4) c4[e7].checked = true, T(c4[e7]);
        } else if (b(i6, e6) && a5[t5].push(e6), s4) for (let t6 in c4) c4[t6].checked = e6 === t6, T(c4[t6]);
      } else if (v(e6)) for (let o7 of i6) {
        const n8 = b(e6, o7);
        n8 && a5[t5].push(o7), s4 && (c4[o7].checked = n8, T(c4[o7]));
      }
      const l6 = 0 === a5[t5].length;
      o6.R = l6 ? o6.R.filter((e7) => e7 !== t5) : S([...o6.R, t5]), s4 && (r6.checked = !l6, T(r6));
    })(e5, t4), Ve();
  };
  var je = (e5, t4) => {
    const o5 = m.o.D ? [] : m.o.Y[t4] || [];
    return b(o5, e5);
  };
  var Fe = (e5) => "" !== Ne(e5, true);
  var Pe = (e5, t4, o5) => {
    let n6 = [];
    const a5 = (e6) => {
      if (y(e6)) {
        let t5 = Ne(e6);
        "" !== t5 && n6.push(t5);
      } else n6.push(...He(e6));
    };
    if (v(e5)) for (let t5 of e5) a5(t5);
    else a5(e5);
    Ee(n6, t4, o5);
  };
  var Oe = (e5) => {
    const { ne: t4, o: n6 } = m;
    if (!n6.k) {
      if (!n6.T) {
        if (!e5) return;
        ye(Je, Me);
      }
      n6.k = true, n6.U = x(), n6.v && K(true), z(t4.he, 1), V(t4.ye, o), E(t4.he, i, "false"), setTimeout(() => {
        $(m.ne.be);
      }, 100), ee(m.re.fe, _);
    }
  };
  var Re = () => {
    const { ne: e5, o: t4, re: n6 } = m;
    t4.k && (t4.k = false, t4.v && K(), $(e5.Ke, true), j(e5.ye, o), E(e5.he, i, "true"), $(t4.U), t4.U = null, ee(n6._e, _));
  };
  var Be = () => {
    const e5 = m.o;
    e5.A || (e5.N || ge(Je, Me), e5.A = true, e5.k ? e5.$ = x() : e5.U = x(), z(m.ne.we, 2), V(m.ne.ye, n), E(m.ne.we, i, "false"), setTimeout(() => {
      $(m.ne.ve);
    }, 100), ee(m.re.fe, u));
  };
  var Ge = () => {
    const e5 = m.o;
    e5.A && (e5.A = false, (() => {
      const e6 = We(), t4 = m.o.P, o5 = m.ne.ae, n6 = m.ne.se, a5 = (e7) => b(m.o.G, e7);
      for (const s4 in o5) {
        const c4 = !!t4[s4].readOnly;
        o5[s4].checked = c4 || (e6 ? Ie(s4) : a5(s4));
        for (const t5 in n6[s4]) n6[s4][t5].checked = c4 || (e6 ? je(t5, s4) : a5(s4));
      }
    })(), $(m.ne.Ge, true), j(m.ne.ye, n), E(m.ne.we, i, "true"), e5.k ? ($(e5.$), e5.$ = null) : ($(e5.U), e5.U = null), ee(m.re._e, u));
  };
  var Je = { show: Oe, hide: Re, showPreferences: Be, hidePreferences: Ge, acceptCategory: Ve };
  var Ue = (e5, t4) => __async(void 0, null, function* () {
    if (!he(e5)) return false;
    const o5 = m.o;
    return !(e5 === Ce() && true !== t4 || !(yield Se(e5)) || (we(e5), o5.T && ye(Je, Me), o5.N && ge(Je, Me), xe(), 0));
  });
  var $e = () => {
    const { F: e5, Y: t4 } = m.o, { accepted: o5, rejected: n6 } = (() => {
      const { D: e6, R: t5, O: o6 } = m.o;
      return { accepted: t5, rejected: e6 ? [] : o6.filter((e7) => !b(t5, e7)) };
    })();
    return F({ acceptType: e5, acceptedCategories: o5, rejectedCategories: n6, acceptedServices: t4, rejectedServices: P() });
  };
  var ze = (e5, t4) => {
    let o5 = document.querySelector('script[src="' + e5 + '"]');
    return new Promise((n6) => {
      if (o5) return n6(true);
      if (o5 = k("script"), h(t4)) for (const e6 in t4) E(o5, e6, t4[e6]);
      o5.onload = () => n6(true), o5.onerror = () => {
        o5.remove(), n6(false);
      }, o5.src = e5, H(document.head, o5);
    });
  };
  var qe = (e5) => {
    let t4, o5 = e5.value, n6 = e5.mode, a5 = false;
    const s4 = m.o;
    if ("update" === n6) {
      s4.h = t4 = Ke("data");
      const e6 = typeof t4 == typeof o5;
      if (e6 && "object" == typeof t4) {
        !t4 && (t4 = {});
        for (let e7 in o5) t4[e7] !== o5[e7] && (t4[e7] = o5[e7], a5 = true);
      } else !e6 && t4 || t4 === o5 || (t4 = o5, a5 = true);
    } else t4 = o5, a5 = true;
    return a5 && (s4.h = t4, s4.p.data = t4, ke(true)), a5;
  };
  var Ke = (e5, t4) => {
    const o5 = Ae(t4);
    return e5 ? o5[e5] : o5;
  };
  var Qe = (e5) => {
    const t4 = m.t, o5 = m.o.i;
    return e5 ? t4[e5] || o5[e5] : __spreadProps(__spreadValues(__spreadValues({}, t4), o5), { cookie: __spreadValues({}, t4.cookie) });
  };
  var We = () => !m.o.D;
  var Xe = (e5) => __async(void 0, null, function* () {
    const { o: o5, t: n6, re: a5 } = m, c4 = window;
    if (!c4._ccRun) {
      if (c4._ccRun = true, ((e6) => {
        const { ne: o6, t: n7, o: a6 } = m, c5 = n7, r7 = a6, { cookie: i7 } = c5, l6 = m.ce, d3 = e6.cookie, f3 = e6.categories, _3 = w(f3) || [], u3 = navigator, p3 = document;
        o6.$e = p3, o6.ye = p3.documentElement, i7.domain = location.hostname, r7.i = e6, r7.P = f3, r7.O = _3, r7._ = e6.language.translations, r7.v = !!e6.disablePageInteraction, l6.ie = e6.onFirstConsent, l6.le = e6.onConsent, l6.de = e6.onChange, l6._e = e6.onModalHide, l6.fe = e6.onModalShow, l6.ue = e6.onModalReady;
        const { mode: g3, autoShow: v2, lazyHtmlGeneration: y3, autoClearCookies: C3, revision: S3, manageScriptTags: x3, hideFromBots: M3 } = e6;
        g3 === t && (c5.mode = g3), "boolean" == typeof C3 && (c5.autoClearCookies = C3), "boolean" == typeof x3 && (c5.manageScriptTags = x3), "number" == typeof S3 && S3 >= 0 && (c5.revision = S3, r7.V = true), "boolean" == typeof v2 && (c5.autoShow = v2), "boolean" == typeof y3 && (c5.lazyHtmlGeneration = y3), false === M3 && (c5.hideFromBots = false), true === c5.hideFromBots && u3 && (r7.J = u3.userAgent && /bot|crawl|spider|slurp|teoma/i.test(u3.userAgent) || u3.webdriver), h(d3) && (c5.cookie = __spreadValues(__spreadValues({}, i7), d3)), c5.autoClearCookies, r7.V, c5.manageScriptTags, ((e7) => {
          const { P: t4, X: o7, Y: n8, Z: a7, B: s4 } = m.o;
          for (let c6 of e7) {
            const e8 = t4[c6], r8 = e8.services || {}, i8 = h(r8) && w(r8) || [];
            o7[c6] = {}, n8[c6] = [], a7[c6] = [], e8.readOnly && (s4.push(c6), n8[c6] = i8), m.ne.se[c6] = {};
            for (let e9 of i8) {
              const t5 = r8[e9];
              t5.Se = false, o7[c6][e9] = t5;
            }
          }
        })(_3), (() => {
          if (!m.t.manageScriptTags) return;
          const e7 = m.o, t4 = D(document, "script[" + s + "]");
          for (const o7 of t4) {
            let t5 = N(o7, s), n8 = o7.dataset.service || "", a7 = false;
            if (t5 && "!" === t5.charAt(0) && (t5 = t5.slice(1), a7 = true), "!" === n8.charAt(0) && (n8 = n8.slice(1), a7 = true), b(e7.O, t5) && (e7.oe.push({ Me: o7, xe: false, ke: a7, De: t5, Te: n8 }), n8)) {
              const o8 = e7.X[t5];
              o8[n8] || (o8[n8] = { Se: false });
            }
          }
        })(), we((() => {
          const e7 = m.o.i.language.autoDetect;
          if (e7) {
            const t4 = { browser: navigator.language, document: document.documentElement.lang }, o7 = he(t4[e7]);
            if (o7) return o7;
          }
          return Ce();
        })());
      })(e5), o5.J) return;
      (() => {
        const e6 = m.o, o6 = m.t, n7 = Ae(), { categories: a6, services: s4, consentId: c5, consentTimestamp: r7, lastConsentTimestamp: i7, data: l6, revision: d3 } = n7, f3 = v(a6);
        e6.p = n7, e6.M = c5;
        const _3 = !!c5 && y(c5);
        e6.C = r7, e6.C && (e6.C = new Date(r7)), e6.S = i7, e6.S && (e6.S = new Date(i7)), e6.h = void 0 !== l6 ? l6 : null, e6.V && _3 && d3 !== o6.revision && (e6.I = false), e6.D = !(_3 && e6.I && e6.C && e6.S && f3), o6.cookie.useLocalStorage && !e6.D && (e6.D = (/* @__PURE__ */ new Date()).getTime() > (n7.expirationTime || 0), e6.D && De(o6.cookie.name)), e6.D, (() => {
          const e7 = m.o;
          for (const o7 of e7.O) {
            const n8 = e7.P[o7];
            if (n8.readOnly || n8.enabled) {
              e7.G.push(o7);
              const n9 = e7.X[o7] || {};
              for (let a7 in n9) e7.Z[o7].push(a7), e7.i.mode === t && e7.Y[o7].push(a7);
            }
          }
        })(), e6.D ? o6.mode === t && (e6.R = [...e6.G]) : (e6.Z = __spreadValues({}, e6.Y), e6.Y = __spreadValues(__spreadValues({}, e6.Y), s4), J([...e6.B, ...a6]));
      })();
      const i6 = We();
      if (!(yield Se())) return false;
      if (U(null, r6 = Je, ge, Me), m.o.D && ye(r6, Me), m.t.lazyHtmlGeneration || ge(r6, Me), n6.autoShow && !i6 && Oe(true), i6) return oe(), ee(a5.le);
      n6.mode === t && oe(o5.G);
    }
    var r6;
  });
  var Ye = (e5) => {
    const { Ce: t4, ye: s4 } = m.ne, { name: c4, path: r6, domain: i6, useLocalStorage: l6 } = m.t.cookie;
    e5 && (l6 ? De(c4) : Pe(c4, r6, i6));
    for (const { pe: e6, me: t5, ge: o5 } of m.o.m) e6.removeEventListener(t5, o5);
    t4 && t4.remove(), s4 && s4.classList.remove(a, n, o);
    const d3 = new p();
    for (const e6 in m) m[e6] = d3[e6];
    window._ccRun = false;
  };

  // assets/scripts/modules/CookieConsent.js
  var CookieConsent_default = class extends _default {
    constructor(m3) {
      super(m3);
      this.events = {
        click: {
          hide: "hideModals",
          "show-preferences-modal": "showPreferencesModal"
        }
      };
    }
    init() {
      let settings = this.getData("config") || {};
      settings = JSON.parse(settings);
      if (!settings.categories || Object.keys(settings.categories).length === 0) {
        console.warn("[CookieConsent]", "No categories configured.");
        return;
      }
      settings.categories = this.prepareCategories(settings.categories);
      Xe(
        Object.assign(
          {
            onConsent: () => {
              this.toggleCategoryAnalytics();
              this.toggleCategoryTargeting();
            },
            onChange: ({ changedCategories }) => {
              if (changedCategories.includes("analytics")) {
                this.toggleCategoryAnalytics();
              }
              if (changedCategories.includes("targeting")) {
                this.toggleCategoryTargeting();
              }
            }
          },
          settings
        )
      );
      setTimeout(Oe, 2e3);
    }
    hideModals() {
      Ge();
      Re();
    }
    prepareCategories(categories) {
      var _a;
      for (const [categoryName, categoryData] of Object.entries(categories)) {
        if (((_a = categoryData == null ? void 0 : categoryData.autoClear) == null ? void 0 : _a.cookies) && Array.isArray(categoryData.autoClear.cookies) && categoryData.autoClear.cookies.length > 0) {
          categoryData.autoClear.cookies.map((cookie) => {
            if ((cookie == null ? void 0 : cookie.name) && typeof cookie.name === "string") {
              const found = cookie.name.match(/^\/(.+)\/([a-z]+)?$/);
              if (found) {
                cookie.name = new RegExp(found[1], found[2]);
              }
            }
            return cookie;
          });
          categories[categoryName].autoClear.cookies = categoryData.autoClear.cookies;
        }
      }
      return categories;
    }
    eraseStorageItems(cookies) {
      let localStorageKeys;
      let sessionStorageKeys;
      for (const { name: cookieName } of cookies) {
        if (isLocalStorageAvailable()) {
          localStorageKeys != null ? localStorageKeys : localStorageKeys = getAllStorageKeys(window.localStorage);
          const foundCookies = findMatchingCookies(localStorageKeys, cookieName);
          for (const foundCookie of foundCookies) {
            window.localStorage.removeItem(foundCookie);
          }
        }
        if (isSessionStorageAvailable()) {
          sessionStorageKeys != null ? sessionStorageKeys : sessionStorageKeys = getAllStorageKeys(window.sessionStorage);
          const foundCookies = findMatchingCookies(sessionStorageKeys, cookieName);
          for (const foundCookie of foundCookies) {
            window.sessionStorage.removeItem(foundCookie);
          }
        }
      }
    }
    showPreferencesModal() {
      Be();
    }
    toggleCategoryAnalytics() {
      var _a, _b, _c, _d;
      const isAccepted = cookieconsent_esm_exports == null ? void 0 : cookieconsent_esm_exports.acceptedCategory("analytics");
      (_a = window.dataLayer) == null ? void 0 : _a.push([
        "consent",
        "update",
        {
          analytics_storage: isAccepted ? "granted" : "denied"
        }
      ]);
      if (!isAccepted) {
        const cookies = (_d = (_c = (_b = Qe("categories")) == null ? void 0 : _b.analytics) == null ? void 0 : _c.autoClear) == null ? void 0 : _d.cookies;
        if (Array.isArray(cookies) && cookies.length) {
          this.eraseStorageItems(cookies);
        }
      }
    }
    toggleCategoryTargeting() {
      var _a, _b, _c, _d;
      const isAccepted = cookieconsent_esm_exports == null ? void 0 : cookieconsent_esm_exports.acceptedCategory("targeting");
      (_a = window.dataLayer) == null ? void 0 : _a.push([
        "consent",
        "update",
        {
          ad_storage: isAccepted ? "granted" : "denied"
        }
      ]);
      if (!isAccepted) {
        const cookies = (_d = (_c = (_b = Qe("categories")) == null ? void 0 : _b.targeting) == null ? void 0 : _c.autoClear) == null ? void 0 : _d.cookies;
        if (Array.isArray(cookies) && cookies.length) {
          this.eraseStorageItems(cookies);
        }
      }
    }
  };
  function findMatchingCookies(allCookies, cookieName) {
    if (cookieName instanceof RegExp) {
      return allCookies.filter((cookie) => cookieName.test(cookie));
    } else {
      const cookieIndex = allCookies.indexOf(cookieName);
      return cookieIndex > -1 ? [allCookies[cookieIndex]] : [];
    }
  }
  function getAllStorageKeys(storage, regex) {
    const cookieNames = [];
    for (const name2 of Object.keys(storage)) {
      if (regex) {
        try {
          regex.test(name2) && cookieNames.push(name2);
        } catch (e5) {
        }
      } else {
        cookieNames.push(name2);
      }
    }
    return cookieNames;
  }

  // assets/scripts/modules/CopyLink.js
  var CopyLink = class extends _default {
    constructor(m3) {
      super(m3);
      this.$button = this.el;
      this.events = {
        click: {
          button: "copyEmail"
        }
      };
    }
    // =============================================================================
    // Lifecycle
    // =============================================================================
    init() {
      if (this.$button) {
        this.$button.addEventListener("click", this.copyEmail.bind(this));
      }
    }
    destroy() {
      if (this.$button) {
        this.$button.removeEventListener("click", this.copyEmail.bind(this));
      }
    }
    copyEmail(event2) {
      return __async(this, null, function* () {
        const button = event2.currentTarget;
        const email = button.getAttribute("data-copy-link-email");
        try {
          yield navigator.clipboard.writeText(email);
          button.setAttribute("aria-live", "polite");
          button.classList.add("-is-copied");
          setTimeout(() => {
            button.classList.remove("-is-copied");
          }, 1e3);
          console.log("Email copied to clipboard");
        } catch (error) {
          console.error(error.message);
        }
      });
    }
  };
  __publicField(CopyLink, "CLASS", {
    COPIED: "-is-copied"
  });

  // assets/scripts/modules/DarkHeader.js
  var _DarkHeader = class _DarkHeader extends _default {
    constructor(m3) {
      super(m3);
    }
    // =============================================================================
    // Lifecycle
    // =============================================================================
    destroy() {
      super.destroy();
    }
    // =============================================================================
    // Callbacks
    // =============================================================================
    onInview(e5) {
      document.documentElement.classList.toggle(_DarkHeader.INVIEW_CLASS, e5.way == "enter");
    }
  };
  __publicField(_DarkHeader, "INVIEW_CLASS", "has-dark-hero-inview");
  var DarkHeader = _DarkHeader;

  // assets/scripts/utils/maths.js
  var clamp4 = (min = 0, max = 1, a5) => Math.min(max, Math.max(min, a5));
  var roundNumber = (number, precision = 2) => {
    return Number.parseFloat(number.toPrecision(precision));
  };
  var mapRange3 = (min, max, nmin, nmax, value2) => {
    return (value2 - min) / (max - min) * (nmax - nmin) + nmin;
  };

  // assets/scripts/modules/Explore.js
  var import_bezier_easing = __toESM(require_src(), 1);
  var _Explore = class _Explore extends _default {
    constructor(m3) {
      super(m3);
      this.onResize = this.onResize.bind(this);
      this.$children = this.$("children")[0];
      this.$parent = this.$("parent")[0];
      this.$ref = this.$("ref")[0];
      this.$media = this.$("media")[0];
      this.mediaMetrics = JSON.parse(this.el.dataset["mediaMetrics"]);
      this.idleRatio = 1;
      this.scale = 1;
      this.screenRatio = window.innerHeight / window.innerWidth;
      this.progress = 0;
      this.imageProgress = 0;
      this.clipX = 0;
      this.clipY = 0;
      this.globalTranslate = 0;
      this.wHeight = window.innerHeight;
      this.wWidth = this.el.offsetWidth;
    }
    // =============================================================================
    // Lifecycle
    // =============================================================================
    init() {
      this.bindEvents();
    }
    destroy() {
      super.destroy();
      this.unbindEvents();
    }
    // =============================================================================
    // Events
    // =============================================================================
    bindEvents() {
      this.unbindScreenListener = $screenDebounce.subscribe(this.onResize);
    }
    unbindEvents() {
      var _a;
      (_a = this.unbindScreenListener) == null ? void 0 : _a.call(this);
    }
    // =============================================================================
    // Callbacks
    // =============================================================================
    onResize({ width: width2, height: height2 }) {
      this.screenRatio = height2 / width2;
      this.idleRatio = this.$ref.offsetWidth / this.el.offsetWidth;
      this.wHeight = height2;
      this.wWidth = this.el.offsetWidth;
      this.coverScaleRatio = this.wHeight / (this.wWidth * (this.mediaMetrics.height / this.mediaMetrics.width));
      this.coverScaleRatio = Math.max(this.coverScaleRatio, 1);
    }
    onScrollProgress(progress) {
      this.progress = progress;
      this.imageProgress = clamp4(0, 1, mapRange3(0.1, 1, 0, 1, progress));
      this.setScale();
      this.setClip();
      this.setTranslate();
      this.applyStyles();
    }
    // =============================================================================
    // Methods
    // =============================================================================
    setScale() {
      this.scale = clamp4(
        this.idleRatio,
        this.coverScaleRatio,
        mapRange3(
          0.5,
          1,
          this.idleRatio,
          this.coverScaleRatio,
          _Explore.scaleEasing(this.imageProgress)
        )
      );
    }
    setClip() {
      const width2 = this.wWidth * this.scale;
      const height2 = width2 * (this.mediaMetrics.height / this.mediaMetrics.width);
      this.clipX = (this.wWidth - width2) / 2;
      this.clipY = (this.wHeight - height2) / 2;
    }
    setTranslate() {
      this.globalTranslate = clamp4(
        0,
        100,
        mapRange3(0, 0.5, 100, 0, _Explore.translateEasing(this.imageProgress))
      );
    }
    applyStyles() {
      this.$media.style.transform = `scale(${this.scale})`;
      this.$parent.style.clipPath = `inset(${this.clipY}px ${this.clipX}px ${this.clipY}px ${this.clipX}px)`;
      this.$children.style.transform = `translate3d(0, ${this.globalTranslate * -1}%, 0)`;
      this.$parent.style.transform = `translate3d(0, ${this.globalTranslate}%, 0)`;
    }
  };
  __publicField(_Explore, "translateEasing", (0, import_bezier_easing.default)(0.65, 1, 0.9, 1));
  __publicField(_Explore, "scaleEasing", (0, import_bezier_easing.default)(0.65, 1, 0.9, 1));
  var Explore = _Explore;

  // assets/scripts/modules/Filter.js
  var _Filter = class _Filter extends _default {
    constructor(m3) {
      super(m3);
      this.toggleDropdown = this.toggleDropdown.bind(this);
      this.handleKeyboardNavigation = this.handleKeyboardNavigation.bind(this);
      this.$filtersList = this.$("filterList")[0];
      this.$items = Array.from(this.$("item"));
      this.$dropdownTogglers = this.$("dropdownToggler");
    }
    // =============================================================================
    // Lifecycle
    // =============================================================================
    init() {
      this.$dropdownTogglers.forEach(($toggler) => {
        $toggler.addEventListener("click", this.toggleDropdown);
        $toggler.addEventListener("keydown", this.handleKeyboardNavigation);
      });
      this.scrollToActiveItem();
    }
    destroy() {
      super.destroy();
      this.$dropdownTogglers.forEach(($toggler) => {
        $toggler.removeEventListener("click", this.toggleDropdown);
        $toggler.removeEventListener("keydown", this.handleKeyboardNavigation);
      });
    }
    // =============================================================================
    // Callbacks
    // =============================================================================
    toggleDropdown(event2) {
      const $toggler = event2.currentTarget;
      const $parentLi = $toggler.closest("li");
      const $dropdown = $parentLi.querySelector(".c-filter_dropdown");
      this.$filtersList.classList.remove(_Filter.DROPDOWN_OPEN_CLASS);
      if ($parentLi.classList.contains(_Filter.DROPDOWN_ACTIVE_CLASS)) {
        $parentLi.classList.remove(_Filter.DROPDOWN_ACTIVE_CLASS);
        $toggler.setAttribute("aria-expanded", "false");
        $dropdown.setAttribute("aria-hidden", "true");
      } else {
        this.closeAllDropdowns();
        this.$filtersList.classList.add(_Filter.DROPDOWN_OPEN_CLASS);
        $parentLi.classList.add(_Filter.DROPDOWN_ACTIVE_CLASS);
        $toggler.setAttribute("aria-expanded", "true");
        $dropdown.setAttribute("aria-hidden", "false");
        const firstLink = $parentLi.querySelector(".c-filter_dropdown a");
        if (firstLink) firstLink.focus();
      }
      event2.preventDefault();
    }
    handleKeyboardNavigation(event2) {
      const $toggler = event2.currentTarget;
      const $parentLi = $toggler.closest("li");
      if (event2.key === "Enter" || event2.key === " ") {
        event2.preventDefault();
        this.toggleDropdown(event2, $toggler);
      }
      if (event2.key === "Escape" && $parentLi.classList.contains(_Filter.DROPDOWN_ACTIVE_CLASS)) {
        $parentLi.classList.remove(_Filter.DROPDOWN_ACTIVE_CLASS);
        $toggler.setAttribute("aria-expanded", "false");
        const $dropdown = $parentLi.querySelector(".c-filter_dropdown");
        $dropdown.setAttribute("aria-hidden", "true");
        $toggler.focus();
      }
    }
    // =============================================================================
    // Methods
    // =============================================================================
    closeAllDropdowns() {
      this.$dropdownTogglers.forEach(($toggler) => {
        const $parentLi = $toggler.closest("li");
        const $dropdown = $parentLi.querySelector(".c-filter_dropdown");
        if ($parentLi.classList.contains(_Filter.DROPDOWN_ACTIVE_CLASS)) {
          $parentLi.classList.remove(_Filter.DROPDOWN_ACTIVE_CLASS);
          $toggler.setAttribute("aria-expanded", "false");
          $dropdown.setAttribute("aria-hidden", "true");
        }
      });
    }
    scrollToActiveItem() {
      let cumulativeOffset = 0;
      this.metrics = this.$items.map(($link) => {
        cumulativeOffset = cumulativeOffset + $link.offsetWidth;
        return cumulativeOffset;
      });
      const findIndex = this.$items.findIndex(($item) => $item.classList.contains("is-active"));
      this.$filtersList.scrollTo({
        left: this.metrics[findIndex - 1] || 0
      });
    }
  };
  __publicField(_Filter, "DROPDOWN_ACTIVE_CLASS", "has-dropdown-active");
  __publicField(_Filter, "DROPDOWN_OPEN_CLASS", "has-dropdown-open");
  var Filter = _Filter;

  // node_modules/tabbable/dist/index.esm.js
  var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
  var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
  var NoElement = typeof Element === "undefined";
  var matches = NoElement ? function() {
  } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
  var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
    var _element$getRootNode;
    return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
  } : function(element) {
    return element === null || element === void 0 ? void 0 : element.ownerDocument;
  };
  var isInert = function isInert2(node, lookUp) {
    var _node$getAttribute;
    if (lookUp === void 0) {
      lookUp = true;
    }
    var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
    var inert = inertAtt === "" || inertAtt === "true";
    var result = inert || lookUp && node && isInert2(node.parentNode);
    return result;
  };
  var isContentEditable = function isContentEditable2(node) {
    var _node$getAttribute2;
    var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
    return attValue === "" || attValue === "true";
  };
  var getCandidates = function getCandidates2(el, includeContainer, filter) {
    if (isInert(el)) {
      return [];
    }
    var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
    if (includeContainer && matches.call(el, candidateSelector)) {
      candidates.unshift(el);
    }
    candidates = candidates.filter(filter);
    return candidates;
  };
  var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
    var candidates = [];
    var elementsToCheck = Array.from(elements);
    while (elementsToCheck.length) {
      var element = elementsToCheck.shift();
      if (isInert(element, false)) {
        continue;
      }
      if (element.tagName === "SLOT") {
        var assigned = element.assignedElements();
        var content2 = assigned.length ? assigned : element.children;
        var nestedCandidates = getCandidatesIteratively2(content2, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: nestedCandidates
          });
        }
      } else {
        var validCandidate = matches.call(element, candidateSelector);
        if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
          candidates.push(element);
        }
        var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
        typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
        var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
        if (shadowRoot && validShadowRoot) {
          var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
          if (options.flatten) {
            candidates.push.apply(candidates, _nestedCandidates);
          } else {
            candidates.push({
              scopeParent: element,
              candidates: _nestedCandidates
            });
          }
        } else {
          elementsToCheck.unshift.apply(elementsToCheck, element.children);
        }
      }
    }
    return candidates;
  };
  var hasTabIndex = function hasTabIndex2(node) {
    return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
  };
  var getTabIndex = function getTabIndex2(node) {
    if (!node) {
      throw new Error("No node provided");
    }
    if (node.tabIndex < 0) {
      if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
        return 0;
      }
    }
    return node.tabIndex;
  };
  var getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
    var tabIndex = getTabIndex(node);
    if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
      return 0;
    }
    return tabIndex;
  };
  var sortOrderedTabbables = function sortOrderedTabbables2(a5, b3) {
    return a5.tabIndex === b3.tabIndex ? a5.documentOrder - b3.documentOrder : a5.tabIndex - b3.tabIndex;
  };
  var isInput = function isInput2(node) {
    return node.tagName === "INPUT";
  };
  var isHiddenInput = function isHiddenInput2(node) {
    return isInput(node) && node.type === "hidden";
  };
  var isDetailsWithSummary = function isDetailsWithSummary2(node) {
    var r6 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
      return child.tagName === "SUMMARY";
    });
    return r6;
  };
  var getCheckedRadio = function getCheckedRadio2(nodes, form) {
    for (var i6 = 0; i6 < nodes.length; i6++) {
      if (nodes[i6].checked && nodes[i6].form === form) {
        return nodes[i6];
      }
    }
  };
  var isTabbableRadio = function isTabbableRadio2(node) {
    if (!node.name) {
      return true;
    }
    var radioScope = node.form || getRootNode(node);
    var queryRadios = function queryRadios2(name2) {
      return radioScope.querySelectorAll('input[type="radio"][name="' + name2 + '"]');
    };
    var radioSet;
    if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
      radioSet = queryRadios(window.CSS.escape(node.name));
    } else {
      try {
        radioSet = queryRadios(node.name);
      } catch (err) {
        console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
        return false;
      }
    }
    var checked = getCheckedRadio(radioSet, node.form);
    return !checked || checked === node;
  };
  var isRadio = function isRadio2(node) {
    return isInput(node) && node.type === "radio";
  };
  var isNonTabbableRadio = function isNonTabbableRadio2(node) {
    return isRadio(node) && !isTabbableRadio(node);
  };
  var isNodeAttached = function isNodeAttached2(node) {
    var _nodeRoot;
    var nodeRoot = node && getRootNode(node);
    var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
    var attached = false;
    if (nodeRoot && nodeRoot !== node) {
      var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
      attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
      while (!attached && nodeRootHost) {
        var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
        nodeRoot = getRootNode(nodeRootHost);
        nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
        attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
      }
    }
    return attached;
  };
  var isZeroArea = function isZeroArea2(node) {
    var _node$getBoundingClie = node.getBoundingClientRect(), width2 = _node$getBoundingClie.width, height2 = _node$getBoundingClie.height;
    return width2 === 0 && height2 === 0;
  };
  var isHidden = function isHidden2(node, _ref) {
    var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
    if (getComputedStyle(node).visibility === "hidden") {
      return true;
    }
    var isDirectSummary = matches.call(node, "details>summary:first-of-type");
    var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
    if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
      return true;
    }
    if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
      if (typeof getShadowRoot === "function") {
        var originalNode = node;
        while (node) {
          var parentElement = node.parentElement;
          var rootNode = getRootNode(node);
          if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
            return isZeroArea(node);
          } else if (node.assignedSlot) {
            node = node.assignedSlot;
          } else if (!parentElement && rootNode !== node.ownerDocument) {
            node = rootNode.host;
          } else {
            node = parentElement;
          }
        }
        node = originalNode;
      }
      if (isNodeAttached(node)) {
        return !node.getClientRects().length;
      }
      if (displayCheck !== "legacy-full") {
        return true;
      }
    } else if (displayCheck === "non-zero-area") {
      return isZeroArea(node);
    }
    return false;
  };
  var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
    if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
      var parentNode = node.parentElement;
      while (parentNode) {
        if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
          for (var i6 = 0; i6 < parentNode.children.length; i6++) {
            var child = parentNode.children.item(i6);
            if (child.tagName === "LEGEND") {
              return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
            }
          }
          return true;
        }
        parentNode = parentNode.parentElement;
      }
    }
    return false;
  };
  var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
    if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
    //  because we're limited in the type of selectors we can use in JSDom (see related
    //  note related to `candidateSelectors`)
    isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
    isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
      return false;
    }
    return true;
  };
  var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
    if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
      return false;
    }
    return true;
  };
  var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
    var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
    if (isNaN(tabIndex) || tabIndex >= 0) {
      return true;
    }
    return false;
  };
  var sortByOrder = function sortByOrder2(candidates) {
    var regularTabbables = [];
    var orderedTabbables = [];
    candidates.forEach(function(item, i6) {
      var isScope = !!item.scopeParent;
      var element = isScope ? item.scopeParent : item;
      var candidateTabindex = getSortOrderTabIndex(element, isScope);
      var elements = isScope ? sortByOrder2(item.candidates) : element;
      if (candidateTabindex === 0) {
        isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
      } else {
        orderedTabbables.push({
          documentOrder: i6,
          tabIndex: candidateTabindex,
          item,
          isScope,
          content: elements
        });
      }
    });
    return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
      sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
      return acc;
    }, []).concat(regularTabbables);
  };
  var tabbable = function tabbable2(container, options) {
    options = options || {};
    var candidates;
    if (options.getShadowRoot) {
      candidates = getCandidatesIteratively([container], options.includeContainer, {
        filter: isNodeMatchingSelectorTabbable.bind(null, options),
        flatten: false,
        getShadowRoot: options.getShadowRoot,
        shadowRootFilter: isValidShadowRootTabbable
      });
    } else {
      candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
    }
    return sortByOrder(candidates);
  };
  var focusable = function focusable2(container, options) {
    options = options || {};
    var candidates;
    if (options.getShadowRoot) {
      candidates = getCandidatesIteratively([container], options.includeContainer, {
        filter: isNodeMatchingSelectorFocusable.bind(null, options),
        flatten: true,
        getShadowRoot: options.getShadowRoot
      });
    } else {
      candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
    }
    return candidates;
  };
  var isTabbable = function isTabbable2(node, options) {
    options = options || {};
    if (!node) {
      throw new Error("No node provided");
    }
    if (matches.call(node, candidateSelector) === false) {
      return false;
    }
    return isNodeMatchingSelectorTabbable(options, node);
  };
  var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
  var isFocusable = function isFocusable2(node, options) {
    options = options || {};
    if (!node) {
      throw new Error("No node provided");
    }
    if (matches.call(node, focusableCandidateSelector) === false) {
      return false;
    }
    return isNodeMatchingSelectorFocusable(options, node);
  };

  // node_modules/focus-trap/dist/focus-trap.esm.js
  function _arrayLikeToArray2(r6, a5) {
    (null == a5 || a5 > r6.length) && (a5 = r6.length);
    for (var e5 = 0, n6 = Array(a5); e5 < a5; e5++) n6[e5] = r6[e5];
    return n6;
  }
  function _arrayWithoutHoles2(r6) {
    if (Array.isArray(r6)) return _arrayLikeToArray2(r6);
  }
  function _defineProperty2(e5, r6, t4) {
    return (r6 = _toPropertyKey(r6)) in e5 ? Object.defineProperty(e5, r6, {
      value: t4,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e5[r6] = t4, e5;
  }
  function _iterableToArray2(r6) {
    if ("undefined" != typeof Symbol && null != r6[Symbol.iterator] || null != r6["@@iterator"]) return Array.from(r6);
  }
  function _nonIterableSpread2() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function ownKeys(e5, r6) {
    var t4 = Object.keys(e5);
    if (Object.getOwnPropertySymbols) {
      var o5 = Object.getOwnPropertySymbols(e5);
      r6 && (o5 = o5.filter(function(r7) {
        return Object.getOwnPropertyDescriptor(e5, r7).enumerable;
      })), t4.push.apply(t4, o5);
    }
    return t4;
  }
  function _objectSpread2(e5) {
    for (var r6 = 1; r6 < arguments.length; r6++) {
      var t4 = null != arguments[r6] ? arguments[r6] : {};
      r6 % 2 ? ownKeys(Object(t4), true).forEach(function(r7) {
        _defineProperty2(e5, r7, t4[r7]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t4)) : ownKeys(Object(t4)).forEach(function(r7) {
        Object.defineProperty(e5, r7, Object.getOwnPropertyDescriptor(t4, r7));
      });
    }
    return e5;
  }
  function _toConsumableArray2(r6) {
    return _arrayWithoutHoles2(r6) || _iterableToArray2(r6) || _unsupportedIterableToArray2(r6) || _nonIterableSpread2();
  }
  function _toPrimitive(t4, r6) {
    if ("object" != typeof t4 || !t4) return t4;
    var e5 = t4[Symbol.toPrimitive];
    if (void 0 !== e5) {
      var i6 = e5.call(t4, r6 || "default");
      if ("object" != typeof i6) return i6;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r6 ? String : Number)(t4);
  }
  function _toPropertyKey(t4) {
    var i6 = _toPrimitive(t4, "string");
    return "symbol" == typeof i6 ? i6 : i6 + "";
  }
  function _unsupportedIterableToArray2(r6, a5) {
    if (r6) {
      if ("string" == typeof r6) return _arrayLikeToArray2(r6, a5);
      var t4 = {}.toString.call(r6).slice(8, -1);
      return "Object" === t4 && r6.constructor && (t4 = r6.constructor.name), "Map" === t4 || "Set" === t4 ? Array.from(r6) : "Arguments" === t4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t4) ? _arrayLikeToArray2(r6, a5) : void 0;
    }
  }
  var activeFocusTraps = {
    activateTrap: function activateTrap(trapStack, trap) {
      if (trapStack.length > 0) {
        var activeTrap = trapStack[trapStack.length - 1];
        if (activeTrap !== trap) {
          activeTrap.pause();
        }
      }
      var trapIndex = trapStack.indexOf(trap);
      if (trapIndex === -1) {
        trapStack.push(trap);
      } else {
        trapStack.splice(trapIndex, 1);
        trapStack.push(trap);
      }
    },
    deactivateTrap: function deactivateTrap(trapStack, trap) {
      var trapIndex = trapStack.indexOf(trap);
      if (trapIndex !== -1) {
        trapStack.splice(trapIndex, 1);
      }
      if (trapStack.length > 0) {
        trapStack[trapStack.length - 1].unpause();
      }
    }
  };
  var isSelectableInput = function isSelectableInput2(node) {
    return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
  };
  var isEscapeEvent = function isEscapeEvent2(e5) {
    return (e5 === null || e5 === void 0 ? void 0 : e5.key) === "Escape" || (e5 === null || e5 === void 0 ? void 0 : e5.key) === "Esc" || (e5 === null || e5 === void 0 ? void 0 : e5.keyCode) === 27;
  };
  var isTabEvent = function isTabEvent2(e5) {
    return (e5 === null || e5 === void 0 ? void 0 : e5.key) === "Tab" || (e5 === null || e5 === void 0 ? void 0 : e5.keyCode) === 9;
  };
  var isKeyForward = function isKeyForward2(e5) {
    return isTabEvent(e5) && !e5.shiftKey;
  };
  var isKeyBackward = function isKeyBackward2(e5) {
    return isTabEvent(e5) && e5.shiftKey;
  };
  var delay = function delay2(fn) {
    return setTimeout(fn, 0);
  };
  var valueOrHandler = function valueOrHandler2(value2) {
    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      params[_key - 1] = arguments[_key];
    }
    return typeof value2 === "function" ? value2.apply(void 0, params) : value2;
  };
  var getActualTarget = function getActualTarget2(event2) {
    return event2.target.shadowRoot && typeof event2.composedPath === "function" ? event2.composedPath()[0] : event2.target;
  };
  var internalTrapStack = [];
  var createFocusTrap = function createFocusTrap2(elements, userOptions) {
    var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
    var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
    var config3 = _objectSpread2({
      returnFocusOnDeactivate: true,
      escapeDeactivates: true,
      delayInitialFocus: true,
      isKeyForward,
      isKeyBackward
    }, userOptions);
    var state = {
      // containers given to createFocusTrap()
      // @type {Array<HTMLElement>}
      containers: [],
      // list of objects identifying tabbable nodes in `containers` in the trap
      // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
      //  is active, but the trap should never get to a state where there isn't at least one group
      //  with at least one tabbable node in it (that would lead to an error condition that would
      //  result in an error being thrown)
      // @type {Array<{
      //   container: HTMLElement,
      //   tabbableNodes: Array<HTMLElement>, // empty if none
      //   focusableNodes: Array<HTMLElement>, // empty if none
      //   posTabIndexesFound: boolean,
      //   firstTabbableNode: HTMLElement|undefined,
      //   lastTabbableNode: HTMLElement|undefined,
      //   firstDomTabbableNode: HTMLElement|undefined,
      //   lastDomTabbableNode: HTMLElement|undefined,
      //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
      // }>}
      containerGroups: [],
      // same order/length as `containers` list
      // references to objects in `containerGroups`, but only those that actually have
      //  tabbable nodes in them
      // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
      //  the same length
      tabbableGroups: [],
      nodeFocusedBeforeActivation: null,
      mostRecentlyFocusedNode: null,
      active: false,
      paused: false,
      // timer ID for when delayInitialFocus is true and initial focus in this trap
      //  has been delayed during activation
      delayInitialFocusTimer: void 0,
      // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
      recentNavEvent: void 0
    };
    var trap;
    var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config3[configOptionName || optionName];
    };
    var findContainerIndex = function findContainerIndex2(element, event2) {
      var composedPath = typeof (event2 === null || event2 === void 0 ? void 0 : event2.composedPath) === "function" ? event2.composedPath() : void 0;
      return state.containerGroups.findIndex(function(_ref) {
        var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
        return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
        //  web components if the `tabbableOptions.getShadowRoot` option was used for
        //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
        //  look inside web components even if open)
        (composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function(node) {
          return node === element;
        });
      });
    };
    var getNodeForOption = function getNodeForOption2(optionName) {
      var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref2$hasFallback = _ref2.hasFallback, hasFallback = _ref2$hasFallback === void 0 ? false : _ref2$hasFallback, _ref2$params = _ref2.params, params = _ref2$params === void 0 ? [] : _ref2$params;
      var optionValue = config3[optionName];
      if (typeof optionValue === "function") {
        optionValue = optionValue.apply(void 0, _toConsumableArray2(params));
      }
      if (optionValue === true) {
        optionValue = void 0;
      }
      if (!optionValue) {
        if (optionValue === void 0 || optionValue === false) {
          return optionValue;
        }
        throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
      }
      var node = optionValue;
      if (typeof optionValue === "string") {
        try {
          node = doc.querySelector(optionValue);
        } catch (err) {
          throw new Error("`".concat(optionName, '` appears to be an invalid selector; error="').concat(err.message, '"'));
        }
        if (!node) {
          if (!hasFallback) {
            throw new Error("`".concat(optionName, "` as selector refers to no known node"));
          }
        }
      }
      return node;
    };
    var getInitialFocusNode = function getInitialFocusNode2() {
      var node = getNodeForOption("initialFocus", {
        hasFallback: true
      });
      if (node === false) {
        return false;
      }
      if (node === void 0 || node && !isFocusable(node, config3.tabbableOptions)) {
        if (findContainerIndex(doc.activeElement) >= 0) {
          node = doc.activeElement;
        } else {
          var firstTabbableGroup = state.tabbableGroups[0];
          var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
          node = firstTabbableNode || getNodeForOption("fallbackFocus");
        }
      } else if (node === null) {
        node = getNodeForOption("fallbackFocus");
      }
      if (!node) {
        throw new Error("Your focus-trap needs to have at least one focusable element");
      }
      return node;
    };
    var updateTabbableNodes = function updateTabbableNodes2() {
      state.containerGroups = state.containers.map(function(container) {
        var tabbableNodes = tabbable(container, config3.tabbableOptions);
        var focusableNodes = focusable(container, config3.tabbableOptions);
        var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
        var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
        var firstDomTabbableNode = focusableNodes.find(function(node) {
          return isTabbable(node);
        });
        var lastDomTabbableNode = focusableNodes.slice().reverse().find(function(node) {
          return isTabbable(node);
        });
        var posTabIndexesFound = !!tabbableNodes.find(function(node) {
          return getTabIndex(node) > 0;
        });
        return {
          container,
          tabbableNodes,
          focusableNodes,
          /** True if at least one node with positive `tabindex` was found in this container. */
          posTabIndexesFound,
          /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
          firstTabbableNode,
          /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
          lastTabbableNode,
          // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
          //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
          //  because that API doesn't work with Shadow DOM as well as it should (@see
          //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
          //  to address an edge case related to positive tabindex support, this seems like a much easier,
          //  "close enough most of the time" alternative for positive tabindexes which should generally
          //  be avoided anyway...
          /** First tabbable node in container, __DOM__ order; `undefined` if none. */
          firstDomTabbableNode,
          /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
          lastDomTabbableNode,
          /**
           * Finds the __tabbable__ node that follows the given node in the specified direction,
           *  in this container, if any.
           * @param {HTMLElement} node
           * @param {boolean} [forward] True if going in forward tab order; false if going
           *  in reverse.
           * @returns {HTMLElement|undefined} The next tabbable node, if any.
           */
          nextTabbableNode: function nextTabbableNode(node) {
            var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
            var nodeIdx = tabbableNodes.indexOf(node);
            if (nodeIdx < 0) {
              if (forward) {
                return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function(el) {
                  return isTabbable(el);
                });
              }
              return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function(el) {
                return isTabbable(el);
              });
            }
            return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
          }
        };
      });
      state.tabbableGroups = state.containerGroups.filter(function(group) {
        return group.tabbableNodes.length > 0;
      });
      if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
        throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
      }
      if (state.containerGroups.find(function(g3) {
        return g3.posTabIndexesFound;
      }) && state.containerGroups.length > 1) {
        throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
      }
    };
    var _getActiveElement = function getActiveElement(el) {
      var activeElement = el.activeElement;
      if (!activeElement) {
        return;
      }
      if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {
        return _getActiveElement(activeElement.shadowRoot);
      }
      return activeElement;
    };
    var _tryFocus = function tryFocus(node) {
      if (node === false) {
        return;
      }
      if (node === _getActiveElement(document)) {
        return;
      }
      if (!node || !node.focus) {
        _tryFocus(getInitialFocusNode());
        return;
      }
      node.focus({
        preventScroll: !!config3.preventScroll
      });
      state.mostRecentlyFocusedNode = node;
      if (isSelectableInput(node)) {
        node.select();
      }
    };
    var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
      var node = getNodeForOption("setReturnFocus", {
        params: [previousActiveElement]
      });
      return node ? node : node === false ? false : previousActiveElement;
    };
    var findNextNavNode = function findNextNavNode2(_ref3) {
      var target = _ref3.target, event2 = _ref3.event, _ref3$isBackward = _ref3.isBackward, isBackward = _ref3$isBackward === void 0 ? false : _ref3$isBackward;
      target = target || getActualTarget(event2);
      updateTabbableNodes();
      var destinationNode = null;
      if (state.tabbableGroups.length > 0) {
        var containerIndex = findContainerIndex(target, event2);
        var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
        if (containerIndex < 0) {
          if (isBackward) {
            destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
          } else {
            destinationNode = state.tabbableGroups[0].firstTabbableNode;
          }
        } else if (isBackward) {
          var startOfGroupIndex = state.tabbableGroups.findIndex(function(_ref4) {
            var firstTabbableNode = _ref4.firstTabbableNode;
            return target === firstTabbableNode;
          });
          if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config3.tabbableOptions) && !isTabbable(target, config3.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
            startOfGroupIndex = containerIndex;
          }
          if (startOfGroupIndex >= 0) {
            var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
            var destinationGroup = state.tabbableGroups[destinationGroupIndex];
            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
          } else if (!isTabEvent(event2)) {
            destinationNode = containerGroup.nextTabbableNode(target, false);
          }
        } else {
          var lastOfGroupIndex = state.tabbableGroups.findIndex(function(_ref5) {
            var lastTabbableNode = _ref5.lastTabbableNode;
            return target === lastTabbableNode;
          });
          if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config3.tabbableOptions) && !isTabbable(target, config3.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
            lastOfGroupIndex = containerIndex;
          }
          if (lastOfGroupIndex >= 0) {
            var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
            var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
            destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
          } else if (!isTabEvent(event2)) {
            destinationNode = containerGroup.nextTabbableNode(target);
          }
        }
      } else {
        destinationNode = getNodeForOption("fallbackFocus");
      }
      return destinationNode;
    };
    var checkPointerDown = function checkPointerDown2(e5) {
      var target = getActualTarget(e5);
      if (findContainerIndex(target, e5) >= 0) {
        return;
      }
      if (valueOrHandler(config3.clickOutsideDeactivates, e5)) {
        trap.deactivate({
          // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
          //  which will result in the outside click setting focus to the node
          //  that was clicked (and if not focusable, to "nothing"); by setting
          //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
          //  on activation (or the configured `setReturnFocus` node), whether the
          //  outside click was on a focusable node or not
          returnFocus: config3.returnFocusOnDeactivate
        });
        return;
      }
      if (valueOrHandler(config3.allowOutsideClick, e5)) {
        return;
      }
      e5.preventDefault();
    };
    var checkFocusIn = function checkFocusIn2(event2) {
      var target = getActualTarget(event2);
      var targetContained = findContainerIndex(target, event2) >= 0;
      if (targetContained || target instanceof Document) {
        if (targetContained) {
          state.mostRecentlyFocusedNode = target;
        }
      } else {
        event2.stopImmediatePropagation();
        var nextNode;
        var navAcrossContainers = true;
        if (state.mostRecentlyFocusedNode) {
          if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {
            var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);
            var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;
            if (tabbableNodes.length > 0) {
              var mruTabIdx = tabbableNodes.findIndex(function(node) {
                return node === state.mostRecentlyFocusedNode;
              });
              if (mruTabIdx >= 0) {
                if (config3.isKeyForward(state.recentNavEvent)) {
                  if (mruTabIdx + 1 < tabbableNodes.length) {
                    nextNode = tabbableNodes[mruTabIdx + 1];
                    navAcrossContainers = false;
                  }
                } else {
                  if (mruTabIdx - 1 >= 0) {
                    nextNode = tabbableNodes[mruTabIdx - 1];
                    navAcrossContainers = false;
                  }
                }
              }
            }
          } else {
            if (!state.containerGroups.some(function(g3) {
              return g3.tabbableNodes.some(function(n6) {
                return getTabIndex(n6) > 0;
              });
            })) {
              navAcrossContainers = false;
            }
          }
        } else {
          navAcrossContainers = false;
        }
        if (navAcrossContainers) {
          nextNode = findNextNavNode({
            // move FROM the MRU node, not event-related node (which will be the node that is
            //  outside the trap causing the focus escape we're trying to fix)
            target: state.mostRecentlyFocusedNode,
            isBackward: config3.isKeyBackward(state.recentNavEvent)
          });
        }
        if (nextNode) {
          _tryFocus(nextNode);
        } else {
          _tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
        }
      }
      state.recentNavEvent = void 0;
    };
    var checkKeyNav = function checkKeyNav2(event2) {
      var isBackward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      state.recentNavEvent = event2;
      var destinationNode = findNextNavNode({
        event: event2,
        isBackward
      });
      if (destinationNode) {
        if (isTabEvent(event2)) {
          event2.preventDefault();
        }
        _tryFocus(destinationNode);
      }
    };
    var checkTabKey = function checkTabKey2(event2) {
      if (config3.isKeyForward(event2) || config3.isKeyBackward(event2)) {
        checkKeyNav(event2, config3.isKeyBackward(event2));
      }
    };
    var checkEscapeKey = function checkEscapeKey2(event2) {
      if (isEscapeEvent(event2) && valueOrHandler(config3.escapeDeactivates, event2) !== false) {
        event2.preventDefault();
        trap.deactivate();
      }
    };
    var checkClick = function checkClick2(e5) {
      var target = getActualTarget(e5);
      if (findContainerIndex(target, e5) >= 0) {
        return;
      }
      if (valueOrHandler(config3.clickOutsideDeactivates, e5)) {
        return;
      }
      if (valueOrHandler(config3.allowOutsideClick, e5)) {
        return;
      }
      e5.preventDefault();
      e5.stopImmediatePropagation();
    };
    var addListeners = function addListeners2() {
      if (!state.active) {
        return;
      }
      activeFocusTraps.activateTrap(trapStack, trap);
      state.delayInitialFocusTimer = config3.delayInitialFocus ? delay(function() {
        _tryFocus(getInitialFocusNode());
      }) : _tryFocus(getInitialFocusNode());
      doc.addEventListener("focusin", checkFocusIn, true);
      doc.addEventListener("mousedown", checkPointerDown, {
        capture: true,
        passive: false
      });
      doc.addEventListener("touchstart", checkPointerDown, {
        capture: true,
        passive: false
      });
      doc.addEventListener("click", checkClick, {
        capture: true,
        passive: false
      });
      doc.addEventListener("keydown", checkTabKey, {
        capture: true,
        passive: false
      });
      doc.addEventListener("keydown", checkEscapeKey);
      return trap;
    };
    var removeListeners = function removeListeners2() {
      if (!state.active) {
        return;
      }
      doc.removeEventListener("focusin", checkFocusIn, true);
      doc.removeEventListener("mousedown", checkPointerDown, true);
      doc.removeEventListener("touchstart", checkPointerDown, true);
      doc.removeEventListener("click", checkClick, true);
      doc.removeEventListener("keydown", checkTabKey, true);
      doc.removeEventListener("keydown", checkEscapeKey);
      return trap;
    };
    var checkDomRemoval = function checkDomRemoval2(mutations) {
      var isFocusedNodeRemoved = mutations.some(function(mutation) {
        var removedNodes = Array.from(mutation.removedNodes);
        return removedNodes.some(function(node) {
          return node === state.mostRecentlyFocusedNode;
        });
      });
      if (isFocusedNodeRemoved) {
        _tryFocus(getInitialFocusNode());
      }
    };
    var mutationObserver = typeof window !== "undefined" && "MutationObserver" in window ? new MutationObserver(checkDomRemoval) : void 0;
    var updateObservedNodes = function updateObservedNodes2() {
      if (!mutationObserver) {
        return;
      }
      mutationObserver.disconnect();
      if (state.active && !state.paused) {
        state.containers.map(function(container) {
          mutationObserver.observe(container, {
            subtree: true,
            childList: true
          });
        });
      }
    };
    trap = {
      get active() {
        return state.active;
      },
      get paused() {
        return state.paused;
      },
      activate: function activate(activateOptions) {
        if (state.active) {
          return this;
        }
        var onActivate = getOption(activateOptions, "onActivate");
        var onPostActivate = getOption(activateOptions, "onPostActivate");
        var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
        if (!checkCanFocusTrap) {
          updateTabbableNodes();
        }
        state.active = true;
        state.paused = false;
        state.nodeFocusedBeforeActivation = doc.activeElement;
        onActivate === null || onActivate === void 0 || onActivate();
        var finishActivation = function finishActivation2() {
          if (checkCanFocusTrap) {
            updateTabbableNodes();
          }
          addListeners();
          updateObservedNodes();
          onPostActivate === null || onPostActivate === void 0 || onPostActivate();
        };
        if (checkCanFocusTrap) {
          checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
          return this;
        }
        finishActivation();
        return this;
      },
      deactivate: function deactivate(deactivateOptions) {
        if (!state.active) {
          return this;
        }
        var options = _objectSpread2({
          onDeactivate: config3.onDeactivate,
          onPostDeactivate: config3.onPostDeactivate,
          checkCanReturnFocus: config3.checkCanReturnFocus
        }, deactivateOptions);
        clearTimeout(state.delayInitialFocusTimer);
        state.delayInitialFocusTimer = void 0;
        removeListeners();
        state.active = false;
        state.paused = false;
        updateObservedNodes();
        activeFocusTraps.deactivateTrap(trapStack, trap);
        var onDeactivate = getOption(options, "onDeactivate");
        var onPostDeactivate = getOption(options, "onPostDeactivate");
        var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
        var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
        onDeactivate === null || onDeactivate === void 0 || onDeactivate();
        var finishDeactivation = function finishDeactivation2() {
          delay(function() {
            if (returnFocus) {
              _tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
            }
            onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();
          });
        };
        if (returnFocus && checkCanReturnFocus) {
          checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
          return this;
        }
        finishDeactivation();
        return this;
      },
      pause: function pause(pauseOptions) {
        if (state.paused || !state.active) {
          return this;
        }
        var onPause = getOption(pauseOptions, "onPause");
        var onPostPause = getOption(pauseOptions, "onPostPause");
        state.paused = true;
        onPause === null || onPause === void 0 || onPause();
        removeListeners();
        updateObservedNodes();
        onPostPause === null || onPostPause === void 0 || onPostPause();
        return this;
      },
      unpause: function unpause(unpauseOptions) {
        if (!state.paused || !state.active) {
          return this;
        }
        var onUnpause = getOption(unpauseOptions, "onUnpause");
        var onPostUnpause = getOption(unpauseOptions, "onPostUnpause");
        state.paused = false;
        onUnpause === null || onUnpause === void 0 || onUnpause();
        updateTabbableNodes();
        addListeners();
        updateObservedNodes();
        onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();
        return this;
      },
      updateContainerElements: function updateContainerElements(containerElements) {
        var elementsAsArray = [].concat(containerElements).filter(Boolean);
        state.containers = elementsAsArray.map(function(element) {
          return typeof element === "string" ? doc.querySelector(element) : element;
        });
        if (state.active) {
          updateTabbableNodes();
        }
        updateObservedNodes();
        return this;
      }
    };
    trap.updateContainerElements(elements);
    return trap;
  };

  // assets/scripts/stores/state.js
  var $hasMenuOpen = atom(false);
  var $hasPlayerOpen = map({
    state: false,
    id: null
  });
  var $hasGalleryOpen = map({
    state: false,
    id: null
  });
  var $isAutoplayable = atom(true);

  // assets/scripts/utils/events.js
  var delegateEvent = ($element, eventType, selector3, handler, options = null) => {
    options = typeof options === "boolean" ? { capture: options } : __spreadValues({}, options);
    let controller;
    if (options.signal == null) {
      controller = new AbortController();
      options.signal = controller.signal;
    }
    $element.addEventListener(
      eventType,
      (event2) => event2.target.matches(selector3) && handler(event2),
      options
    );
    return controller;
  };

  // assets/scripts/modules/Gallery.js
  var _Gallery = class _Gallery extends _default {
    constructor(m3) {
      super(m3);
      this.onResize = this.onResize.bind(this);
      this.onGalleryOpenChange = this.onGalleryOpenChange.bind(this);
      this.onOpen = this.onOpen.bind(this);
      this.onClose = this.onClose.bind(this);
      this.onActivate = this.onActivate.bind(this);
      this.onPostActivate = this.onPostActivate.bind(this);
      this.onDeactivate = this.onDeactivate.bind(this);
      this.onPostDeactivate = this.onPostDeactivate.bind(this);
      this.onPrefersReducedMotionChange = this.onPrefersReducedMotionChange.bind(this);
      this.$close = this.$("close")[0];
      this.$top = this.$("top")[0];
      this.$bottom = this.$("bottom")[0];
      this.$prev = this.$("prev")[0];
      this.$next = this.$("next")[0];
      this.$swiper = this.$("swiper")[0];
      this.$pagination = this.$("pagination")[0];
      this.$slides = Array.from(this.$("slide"));
      this.galleryId = this.el.dataset.galleryId;
      this.focusTrap = createFocusTrap(this.el, {
        onActivate: this.onActivate,
        onPostActivate: this.onPostActivate,
        onDeactivate: this.onDeactivate,
        onPostDeactivate: this.onPostDeactivate,
        clickOutsideDeactivates: true
      });
    }
    // //////////
    // Lifecycle
    // //////////
    init() {
      this.bindEvents();
      this.unbindPrefersReducedMotion = $prefersReducedMotion.subscribe(
        this.onPrefersReducedMotionChange
      );
    }
    destroy() {
      var _a;
      this.unbindEvents();
      this.destroySwiper();
      (_a = this.unbindPrefersReducedMotion) == null ? void 0 : _a.call(this);
      super.destroy();
    }
    // //////////
    // Events
    // //////////
    bindEvents() {
      var _a;
      this.unbindOpenEvent = delegateEvent(document.body, "click", _Gallery.SELECTOR, this.onOpen);
      this.unbindGalleryOpenListener = $hasGalleryOpen.listen(this.onGalleryOpenChange);
      (_a = this.$close) == null ? void 0 : _a.addEventListener("click", this.onClose);
      this.unbindScreenListener = $screenDebounce.subscribe(this.onResize);
    }
    unbindEvents() {
      var _a, _b, _c, _d, _e2;
      (_b = (_a = this.unbindOpenEvent).abort) == null ? void 0 : _b.call(_a);
      (_c = this.unbindGalleryOpenListener) == null ? void 0 : _c.call(this);
      (_d = this.$close) == null ? void 0 : _d.addEventListener("click", this.onClose);
      (_e2 = this.unbindScreenListener) == null ? void 0 : _e2.call(this);
    }
    // //////////
    // Callbacks
    // //////////
    onActivate() {
      this.el.setAttribute("aria-hidden", false);
    }
    onPostActivate() {
      var _a;
      (_a = this.$triggerCta) == null ? void 0 : _a.setAttribute("aria-expanded", true);
    }
    onDeactivate() {
      this.el.classList.remove(_Gallery.CLASS.ACTIVE);
      document.documentElement.classList.remove(_Gallery.CLASS.GLOBAL_ACTIVE);
      $hasGalleryOpen.set({
        state: false,
        id: null
      });
      this.el.setAttribute("aria-hidden", true);
    }
    onPostDeactivate() {
      var _a;
      (_a = this.$triggerCta) == null ? void 0 : _a.setAttribute("aria-expanded", false);
    }
    onGalleryOpenChange(hasGalleryOpen) {
      if (hasGalleryOpen.state && hasGalleryOpen.id === this.galleryId) {
        this.el.classList.add(_Gallery.CLASS.ACTIVE);
        document.documentElement.classList.add(_Gallery.CLASS.GLOBAL_ACTIVE);
        this.swiper.setProgress(0, 0);
        requestAnimationFrame(() => {
          var _a, _b;
          (_b = (_a = this.focusTrap) == null ? void 0 : _a.activate) == null ? void 0 : _b.call(_a);
        });
      }
    }
    onOpen(e5) {
      var _a, _b;
      this.$triggerCta = e5 == null ? void 0 : e5.target;
      const galleryId = (_b = (_a = this.$triggerCta) == null ? void 0 : _a.dataset) == null ? void 0 : _b.galleryId;
      this.open(galleryId);
    }
    onClose() {
      this.close();
    }
    onResize({ width: width2, height: height2 }) {
      this.setMetrics();
    }
    onPrefersReducedMotionChange() {
      this.destroySwiper();
      this.initSwiper();
      requestAnimationFrame(() => {
        this.setMetrics();
      });
    }
    // //////////
    // Methods
    // //////////
    // Modal
    open(galleryId) {
      if ($hasGalleryOpen.value.state) return;
      $hasGalleryOpen.set({
        state: true,
        id: galleryId
      });
    }
    close() {
      var _a, _b;
      if (!$hasGalleryOpen.value.state) return;
      this.$triggerCta = null;
      (_b = (_a = this.focusTrap) == null ? void 0 : _a.deactivate) == null ? void 0 : _b.call(_a);
    }
    // Swiper
    initSwiper() {
      var _a;
      const args = {
        modules: [Navigation, Pagination, Mousewheel],
        speed: $prefersReducedMotion.value ? 100 : 400,
        effect: $prefersReducedMotion.value ? "fade" : "slide",
        loop: true,
        slidesPerView: "auto",
        spaceBetween: 20,
        mousewheel: {
          enenabled: true
        },
        navigation: {
          prevEl: this.$prev,
          nextEl: this.$next
        },
        pagination: {
          el: this.$pagination,
          type: "fraction",
          formatFractionCurrent: (number) => {
            return String(number).padStart(2, "0");
          },
          formatFractionTotal: (number) => {
            return String(number).padStart(2, "0");
          },
          renderFraction: (currentClass, totalClass) => {
            return `<span class="${currentClass}"></span>&nbsp;<span><span>/</span>&nbsp;<span class="${totalClass}"></span></span>`;
          }
        }
      };
      this.swiper = new Swiper(this.$swiper, args);
      (_a = this.swiper.autoplay) == null ? void 0 : _a.pause();
    }
    destroySwiper() {
      var _a;
      (_a = this.swiper) == null ? void 0 : _a.destroy(true, true);
    }
    // Others
    setMetrics() {
      this.el.style.setProperty("--gallery-top-height", this.$top.offsetHeight + "px");
      this.el.style.setProperty("--gallery-bottom-height", this.$bottom.offsetHeight + "px");
      requestAnimationFrame(() => {
        var _a;
        (_a = this.swiper) == null ? void 0 : _a.update();
      });
    }
  };
  __publicField(_Gallery, "CLASS", {
    ACTIVE: "is-active",
    GLOBAL_ACTIVE: "has-gallery-open"
  });
  __publicField(_Gallery, "SELECTOR", "[data-gallery-open]");
  var Gallery = _Gallery;

  // assets/scripts/modules/HeroWords.js
  gsapWithCSS.registerPlugin(SplitText);
  var _HeroWords = class _HeroWords extends _default {
    constructor(m3) {
      super(m3);
      this.onResize = this.onResize.bind(this);
      this.onUpdate = this.onUpdate.bind(this);
      this.reSplit = this.reSplit.bind(this);
      this.$items = Array.from(this.$("item"));
      this.$ref = this.el.previousElementSibling;
      this.activeIndex = 0;
      this.prevIndex = -1;
      this.interval = null;
      this.isFirstSplitting = false;
      this.wWidth = -1;
    }
    // =============================================================================
    // Lifecycle
    // =============================================================================
    init() {
      whenReady(FONT.EAGER).then((fonts) => this.onFontsLoaded(fonts));
      this.bindEvents();
      requestAnimationFrame(() => {
        this.setReferenceHeight();
        this.reSplit();
      });
    }
    destroy() {
      super.destroy();
      this.unbindEvents();
    }
    // =============================================================================
    // Events
    // =============================================================================
    bindEvents() {
      this.unbindScreenListener = $screenDebounce.listen(this.onResize);
    }
    unbindEvents() {
      var _a, _b;
      (_a = this.unbindScreenListener) == null ? void 0 : _a.call(this);
      (_b = this.interval) == null ? void 0 : _b.kill();
    }
    // =============================================================================
    // Callbacks
    // =============================================================================
    onFontsLoaded(fonts) {
      this.setReferenceHeight();
      this.reSplit();
    }
    onResize({ width: width2, height: height2 }) {
      if (this.wWidth === width2) return;
      this.wWidth = width2;
      requestAnimationFrame(() => {
        this.setReferenceHeight();
        this.reSplit();
      });
    }
    onUpdate() {
      this.interval = gsapWithCSS.delayedCall(_HeroWords.INTERVAL, this.onUpdate);
      this.update();
    }
    // =============================================================================
    // Methods
    // =============================================================================
    setReferenceHeight() {
      const maxHeight = Math.max(...this.$items.map(($item) => $item.offsetHeight));
      this.$ref.style.height = `${maxHeight}px`;
    }
    split() {
      this.splitObject = new SplitText(this.$items, {
        type: "words",
        tag: "span"
      });
      const wordByItems = [];
      this.splitObject.words.forEach((word, i6) => {
        this.$items.forEach(($item, itemsIndex) => {
          if ($item.contains(word)) {
            if (!wordByItems[itemsIndex]) {
              wordByItems[itemsIndex] = [];
            }
            wordByItems[itemsIndex].push(word);
          }
        });
      });
      wordByItems.forEach((words) => {
        words.forEach((word, wordIndex) => {
          word.style.setProperty("--word-index", wordIndex);
        });
      });
    }
    reSplit() {
      var _a, _b;
      (_b = (_a = this.splitObject) == null ? void 0 : _a.revert) == null ? void 0 : _b.call(_a);
      requestAnimationFrame(() => {
        this.split();
        if (!this.isFirstSplitting) {
          this.isFirstSplitting = true;
          this.onUpdate();
        }
      });
    }
    update() {
      var _a, _b, _c, _d, _e2;
      (_a = this.$items[this.prevIndex]) == null ? void 0 : _a.classList.remove("is-prev");
      this.prevIndex = this.activeIndex;
      this.activeIndex = (this.activeIndex + 1) % this.$items.length;
      (_b = this.$items[this.prevIndex]) == null ? void 0 : _b.classList.remove("is-active");
      (_c = this.$items[this.activeIndex]) == null ? void 0 : _c.classList.remove("is-prev");
      (_d = this.$items[this.prevIndex]) == null ? void 0 : _d.classList.add("is-prev");
      (_e2 = this.$items[this.activeIndex]) == null ? void 0 : _e2.classList.add("is-active");
    }
  };
  __publicField(_HeroWords, "INTERVAL", 3);
  var HeroWords = _HeroWords;

  // assets/scripts/utils/dom.js
  var $html = document.documentElement;
  var $body = document.body;

  // node_modules/delegate-it/delegate.js
  var ledger = /* @__PURE__ */ new WeakMap();
  function editLedger(wanted, baseElement, callback, setup) {
    var _a, _b;
    if (!wanted && !ledger.has(baseElement)) {
      return false;
    }
    const elementMap = (_a = ledger.get(baseElement)) != null ? _a : /* @__PURE__ */ new WeakMap();
    ledger.set(baseElement, elementMap);
    const setups = (_b = elementMap.get(callback)) != null ? _b : /* @__PURE__ */ new Set();
    elementMap.set(callback, setups);
    const existed = setups.has(setup);
    if (wanted) {
      setups.add(setup);
    } else {
      setups.delete(setup);
    }
    return existed && wanted;
  }
  function safeClosest(event2, selector3) {
    let target = event2.target;
    if (target instanceof Text) {
      target = target.parentElement;
    }
    if (target instanceof Element && event2.currentTarget instanceof Element) {
      const closest = target.closest(selector3);
      if (closest && event2.currentTarget.contains(closest)) {
        return closest;
      }
    }
  }
  function delegate(selector3, type, callback, options = {}) {
    const { signal, base = document } = options;
    if (signal == null ? void 0 : signal.aborted) {
      return;
    }
    const _a = options, { once } = _a, nativeListenerOptions = __objRest(_a, ["once"]);
    const baseElement = base instanceof Document ? base.documentElement : base;
    const capture = Boolean(typeof options === "object" ? options.capture : options);
    const listenerFunction = (event2) => {
      const delegateTarget = safeClosest(event2, String(selector3));
      if (delegateTarget) {
        const delegateEvent2 = Object.assign(event2, { delegateTarget });
        callback.call(baseElement, delegateEvent2);
        if (once) {
          baseElement.removeEventListener(type, listenerFunction, nativeListenerOptions);
          editLedger(false, baseElement, callback, setup);
        }
      }
    };
    const setup = JSON.stringify({ selector: selector3, type, capture });
    const isAlreadyListening = editLedger(true, baseElement, callback, setup);
    if (!isAlreadyListening) {
      baseElement.addEventListener(type, listenerFunction, nativeListenerOptions);
    }
    signal == null ? void 0 : signal.addEventListener("abort", () => {
      editLedger(false, baseElement, callback, setup);
    });
  }
  var delegate_default = delegate;

  // node_modules/swup/dist/Swup.modern.js
  function i2() {
    return i2 = Object.assign ? Object.assign.bind() : function(t4) {
      for (var e5 = 1; e5 < arguments.length; e5++) {
        var i6 = arguments[e5];
        for (var s4 in i6) ({}).hasOwnProperty.call(i6, s4) && (t4[s4] = i6[s4]);
      }
      return t4;
    }, i2.apply(null, arguments);
  }
  var s2 = (t4, e5) => String(t4).toLowerCase().replace(/[\s/_.]+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+|-+$/g, "") || e5 || "";
  var n2 = ({ hash: t4 } = {}) => window.location.pathname + window.location.search + (t4 ? window.location.hash : "");
  var o2 = (t4, e5 = {}) => {
    const s4 = i2({ url: t4 = t4 || n2({ hash: true }), random: Math.random(), source: "swup" }, e5);
    window.history.pushState(s4, "", t4);
  };
  var r2 = (t4 = null, e5 = {}) => {
    t4 = t4 || n2({ hash: true });
    const s4 = i2({}, window.history.state || {}, { url: t4, random: Math.random(), source: "swup" }, e5);
    window.history.replaceState(s4, "", t4);
  };
  var a2 = (e5, s4, n6, o5) => {
    const r6 = new AbortController();
    return o5 = i2({}, o5, { signal: r6.signal }), delegate_default(e5, s4, n6, o5), { destroy: () => r6.abort() };
  };
  var l2 = class _l extends URL {
    constructor(t4, e5 = document.baseURI) {
      super(t4.toString(), e5), Object.setPrototypeOf(this, _l.prototype);
    }
    get url() {
      return this.pathname + this.search;
    }
    static fromElement(t4) {
      const e5 = t4.getAttribute("href") || t4.getAttribute("xlink:href") || "";
      return new _l(e5);
    }
    static fromUrl(t4) {
      return new _l(t4);
    }
  };
  var c2 = class extends Error {
    constructor(t4, e5) {
      super(t4), this.url = void 0, this.status = void 0, this.aborted = void 0, this.timedOut = void 0, this.name = "FetchError", this.url = e5.url, this.status = e5.status, this.aborted = e5.aborted || false, this.timedOut = e5.timedOut || false;
    }
  };
  function u2(_0) {
    return __async(this, arguments, function* (t4, e5 = {}) {
      var s4;
      t4 = l2.fromUrl(t4).url;
      const { visit: n6 = this.visit } = e5, o5 = i2({}, this.options.requestHeaders, e5.headers), r6 = null != (s4 = e5.timeout) ? s4 : this.options.timeout, a5 = new AbortController(), { signal: h2 } = a5;
      e5 = i2({}, e5, { headers: o5, signal: h2 });
      let u3, d3 = false, p3 = null;
      r6 && r6 > 0 && (p3 = setTimeout(() => {
        d3 = true, a5.abort("timeout");
      }, r6));
      try {
        u3 = yield this.hooks.call("fetch:request", n6, { url: t4, options: e5 }, (t5, { url: e6, options: i6 }) => fetch(e6, i6)), p3 && clearTimeout(p3);
      } catch (e6) {
        if (d3) throw this.hooks.call("fetch:timeout", n6, { url: t4 }), new c2(`Request timed out: ${t4}`, { url: t4, timedOut: d3 });
        if ("AbortError" === (null == e6 ? void 0 : e6.name) || h2.aborted) throw new c2(`Request aborted: ${t4}`, { url: t4, aborted: true });
        throw e6;
      }
      const { status: m3, url: w3 } = u3, f3 = yield u3.text();
      if (500 === m3) throw this.hooks.call("fetch:error", n6, { status: m3, response: u3, url: w3 }), new c2(`Server error: ${w3}`, { status: m3, url: w3 });
      if (!f3) throw new c2(`Empty response: ${w3}`, { status: m3, url: w3 });
      const { url: g3 } = l2.fromUrl(w3), v2 = { url: g3, html: f3 };
      return !n6.cache.write || e5.method && "GET" !== e5.method || t4 !== g3 || this.cache.set(v2.url, v2), v2;
    });
  }
  var d2 = class {
    constructor(t4) {
      this.swup = void 0, this.pages = /* @__PURE__ */ new Map(), this.swup = t4;
    }
    get size() {
      return this.pages.size;
    }
    get all() {
      const t4 = /* @__PURE__ */ new Map();
      return this.pages.forEach((e5, s4) => {
        t4.set(s4, i2({}, e5));
      }), t4;
    }
    has(t4) {
      return this.pages.has(this.resolve(t4));
    }
    get(t4) {
      const e5 = this.pages.get(this.resolve(t4));
      return e5 ? i2({}, e5) : e5;
    }
    set(t4, e5) {
      e5 = i2({}, e5, { url: t4 = this.resolve(t4) }), this.pages.set(t4, e5), this.swup.hooks.callSync("cache:set", void 0, { page: e5 });
    }
    update(t4, e5) {
      t4 = this.resolve(t4);
      const s4 = i2({}, this.get(t4), e5, { url: t4 });
      this.pages.set(t4, s4);
    }
    delete(t4) {
      this.pages.delete(this.resolve(t4));
    }
    clear() {
      this.pages.clear(), this.swup.hooks.callSync("cache:clear", void 0, void 0);
    }
    prune(t4) {
      this.pages.forEach((e5, i6) => {
        t4(i6, e5) && this.delete(i6);
      });
    }
    resolve(t4) {
      const { url: e5 } = l2.fromUrl(t4);
      return this.swup.resolveUrl(e5);
    }
  };
  var p2 = (t4, e5 = document) => e5.querySelector(t4);
  var m2 = (t4, e5 = document) => Array.from(e5.querySelectorAll(t4));
  var w2 = () => new Promise((t4) => {
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        t4();
      });
    });
  });
  function f2(t4) {
    return !!t4 && ("object" == typeof t4 || "function" == typeof t4) && "function" == typeof t4.then;
  }
  function g2(t4, e5 = []) {
    return new Promise((i6, s4) => {
      const n6 = t4(...e5);
      f2(n6) ? n6.then(i6, s4) : i6(n6);
    });
  }
  function y2(t4, e5) {
    const i6 = null == t4 ? void 0 : t4.closest(`[${e5}]`);
    return null != i6 && i6.hasAttribute(e5) ? (null == i6 ? void 0 : i6.getAttribute(e5)) || true : void 0;
  }
  var k2 = class {
    constructor(t4) {
      this.swup = void 0, this.swupClasses = ["to-", "is-changing", "is-rendering", "is-popstate", "is-animating", "is-leaving"], this.swup = t4;
    }
    get selectors() {
      const { scope: t4 } = this.swup.visit.animation;
      return "containers" === t4 ? this.swup.visit.containers : "html" === t4 ? ["html"] : Array.isArray(t4) ? t4 : [];
    }
    get selector() {
      return this.selectors.join(",");
    }
    get targets() {
      return this.selector.trim() ? m2(this.selector) : [];
    }
    add(...t4) {
      this.targets.forEach((e5) => e5.classList.add(...t4));
    }
    remove(...t4) {
      this.targets.forEach((e5) => e5.classList.remove(...t4));
    }
    clear() {
      this.targets.forEach((t4) => {
        const e5 = t4.className.split(" ").filter((t5) => this.isSwupClass(t5));
        t4.classList.remove(...e5);
      });
    }
    isSwupClass(t4) {
      return this.swupClasses.some((e5) => t4.startsWith(e5));
    }
  };
  var b2 = class {
    constructor(t4, e5) {
      this.id = void 0, this.state = void 0, this.from = void 0, this.to = void 0, this.containers = void 0, this.animation = void 0, this.trigger = void 0, this.cache = void 0, this.history = void 0, this.scroll = void 0, this.meta = void 0;
      const { to: i6, from: s4, hash: n6, el: o5, event: r6 } = e5;
      this.id = Math.random(), this.state = 1, this.from = { url: null != s4 ? s4 : t4.location.url, hash: t4.location.hash }, this.to = { url: i6, hash: n6 }, this.containers = t4.options.containers, this.animation = { animate: true, wait: false, name: void 0, native: t4.options.native, scope: t4.options.animationScope, selector: t4.options.animationSelector }, this.trigger = { el: o5, event: r6 }, this.cache = { read: t4.options.cache, write: t4.options.cache }, this.history = { action: "push", popstate: false, direction: void 0 }, this.scroll = { reset: true, target: void 0 }, this.meta = {};
    }
    advance(t4) {
      this.state < t4 && (this.state = t4);
    }
    abort() {
      this.state = 8;
    }
    get done() {
      return this.state >= 7;
    }
  };
  function S2(t4) {
    return new b2(this, t4);
  }
  var E2 = class {
    constructor(t4) {
      this.swup = void 0, this.registry = /* @__PURE__ */ new Map(), this.hooks = ["animation:out:start", "animation:out:await", "animation:out:end", "animation:in:start", "animation:in:await", "animation:in:end", "animation:skip", "cache:clear", "cache:set", "content:replace", "content:scroll", "enable", "disable", "fetch:request", "fetch:error", "fetch:timeout", "history:popstate", "link:click", "link:self", "link:anchor", "link:newtab", "page:load", "page:view", "scroll:top", "scroll:anchor", "visit:start", "visit:transition", "visit:abort", "visit:end"], this.swup = t4, this.init();
    }
    init() {
      this.hooks.forEach((t4) => this.create(t4));
    }
    create(t4) {
      this.registry.has(t4) || this.registry.set(t4, /* @__PURE__ */ new Map());
    }
    exists(t4) {
      return this.registry.has(t4);
    }
    get(t4) {
      const e5 = this.registry.get(t4);
      if (e5) return e5;
      console.error(`Unknown hook '${t4}'`);
    }
    clear() {
      this.registry.forEach((t4) => t4.clear());
    }
    on(t4, e5, s4 = {}) {
      const n6 = this.get(t4);
      if (!n6) return console.warn(`Hook '${t4}' not found.`), () => {
      };
      const o5 = i2({}, s4, { id: n6.size + 1, hook: t4, handler: e5 });
      return n6.set(e5, o5), () => this.off(t4, e5);
    }
    before(t4, e5, s4 = {}) {
      return this.on(t4, e5, i2({}, s4, { before: true }));
    }
    replace(t4, e5, s4 = {}) {
      return this.on(t4, e5, i2({}, s4, { replace: true }));
    }
    once(t4, e5, s4 = {}) {
      return this.on(t4, e5, i2({}, s4, { once: true }));
    }
    off(t4, e5) {
      const i6 = this.get(t4);
      i6 && e5 ? i6.delete(e5) || console.warn(`Handler for hook '${t4}' not found.`) : i6 && i6.clear();
    }
    call(t4, e5, i6, s4) {
      return __async(this, null, function* () {
        const [n6, o5, r6] = this.parseCallArgs(t4, e5, i6, s4), { before: a5, handler: l6, after: h2 } = this.getHandlers(t4, r6);
        yield this.run(a5, n6, o5);
        const [c4] = yield this.run(l6, n6, o5, true);
        return yield this.run(h2, n6, o5), this.dispatchDomEvent(t4, n6, o5), c4;
      });
    }
    callSync(t4, e5, i6, s4) {
      const [n6, o5, r6] = this.parseCallArgs(t4, e5, i6, s4), { before: a5, handler: l6, after: h2 } = this.getHandlers(t4, r6);
      this.runSync(a5, n6, o5);
      const [c4] = this.runSync(l6, n6, o5, true);
      return this.runSync(h2, n6, o5), this.dispatchDomEvent(t4, n6, o5), c4;
    }
    parseCallArgs(t4, e5, i6, s4) {
      return e5 instanceof b2 || "object" != typeof e5 && "function" != typeof i6 ? [e5, i6, s4] : [void 0, e5, i6];
    }
    run(_0) {
      return __async(this, arguments, function* (t4, e5 = this.swup.visit, i6, s4 = false) {
        const n6 = [];
        for (const { hook: o5, handler: r6, defaultHandler: a5, once: l6 } of t4) if (null == e5 || !e5.done) {
          l6 && this.off(o5, r6);
          try {
            const t5 = yield g2(r6, [e5, i6, a5]);
            n6.push(t5);
          } catch (t5) {
            if (s4) throw t5;
            console.error(`Error in hook '${o5}':`, t5);
          }
        }
        return n6;
      });
    }
    runSync(t4, e5 = this.swup.visit, i6, s4 = false) {
      const n6 = [];
      for (const { hook: o5, handler: r6, defaultHandler: a5, once: l6 } of t4) if (null == e5 || !e5.done) {
        l6 && this.off(o5, r6);
        try {
          const t5 = r6(e5, i6, a5);
          n6.push(t5), f2(t5) && console.warn(`Swup will not await Promises in handler for synchronous hook '${o5}'.`);
        } catch (t5) {
          if (s4) throw t5;
          console.error(`Error in hook '${o5}':`, t5);
        }
      }
      return n6;
    }
    getHandlers(t4, e5) {
      const i6 = this.get(t4);
      if (!i6) return { found: false, before: [], handler: [], after: [], replaced: false };
      const s4 = Array.from(i6.values()), n6 = this.sortRegistrations, o5 = s4.filter(({ before: t5, replace: e6 }) => t5 && !e6).sort(n6), r6 = s4.filter(({ replace: t5 }) => t5).filter((t5) => true).sort(n6), a5 = s4.filter(({ before: t5, replace: e6 }) => !t5 && !e6).sort(n6), l6 = r6.length > 0;
      let h2 = [];
      if (e5 && (h2 = [{ id: 0, hook: t4, handler: e5 }], l6)) {
        const i7 = r6.length - 1, { handler: s5, once: n7 } = r6[i7], o6 = (t5) => {
          const i8 = r6[t5 - 1];
          return i8 ? (e6, s6) => i8.handler(e6, s6, o6(t5 - 1)) : e5;
        };
        h2 = [{ id: 0, hook: t4, once: n7, handler: s5, defaultHandler: o6(i7) }];
      }
      return { found: true, before: o5, handler: h2, after: a5, replaced: l6 };
    }
    sortRegistrations(t4, e5) {
      var i6, s4;
      return (null != (i6 = t4.priority) ? i6 : 0) - (null != (s4 = e5.priority) ? s4 : 0) || t4.id - e5.id || 0;
    }
    dispatchDomEvent(t4, e5, i6) {
      if (null != e5 && e5.done) return;
      const s4 = { hook: t4, args: i6, visit: e5 || this.swup.visit };
      document.dispatchEvent(new CustomEvent("swup:any", { detail: s4, bubbles: true })), document.dispatchEvent(new CustomEvent(`swup:${t4}`, { detail: s4, bubbles: true }));
    }
    parseName(t4) {
      const [e5, ...s4] = t4.split(".");
      return [e5, s4.reduce((t5, e6) => i2({}, t5, { [e6]: true }), {})];
    }
  };
  var C2 = (t4) => {
    if (t4 && "#" === t4.charAt(0) && (t4 = t4.substring(1)), !t4) return null;
    const e5 = decodeURIComponent(t4);
    let i6 = document.getElementById(t4) || document.getElementById(e5) || p2(`a[name='${CSS.escape(t4)}']`) || p2(`a[name='${CSS.escape(e5)}']`);
    return i6 || "top" !== t4 || (i6 = document.body), i6;
  };
  var U2 = "transition";
  var P2 = "animation";
  function $2(_0) {
    return __async(this, arguments, function* ({ selector: t4, elements: e5 }) {
      if (false === t4 && !e5) return;
      let i6 = [];
      if (e5) i6 = Array.from(e5);
      else if (t4 && (i6 = m2(t4, document.body), !i6.length)) return void console.warn(`[swup] No elements found matching animationSelector \`${t4}\``);
      const s4 = i6.map((t5) => function(t6) {
        const { type: e6, timeout: i7, propCount: s5 } = function(t7) {
          const e7 = window.getComputedStyle(t7), i8 = x2(e7, `${U2}Delay`), s6 = x2(e7, `${U2}Duration`), n6 = A2(i8, s6), o5 = x2(e7, `${P2}Delay`), r6 = x2(e7, `${P2}Duration`), a5 = A2(o5, r6), l6 = Math.max(n6, a5), h2 = l6 > 0 ? n6 > a5 ? U2 : P2 : null;
          return { type: h2, timeout: l6, propCount: h2 ? h2 === U2 ? s6.length : r6.length : 0 };
        }(t6);
        return !(!e6 || !i7) && new Promise((n6) => {
          const o5 = `${e6}end`, r6 = performance.now();
          let a5 = 0;
          const l6 = () => {
            t6.removeEventListener(o5, h2), n6();
          }, h2 = (e7) => {
            e7.target === t6 && ((performance.now() - r6) / 1e3 < e7.elapsedTime || ++a5 >= s5 && l6());
          };
          setTimeout(() => {
            a5 < s5 && l6();
          }, i7 + 1), t6.addEventListener(o5, h2);
        });
      }(t5));
      s4.filter(Boolean).length > 0 ? yield Promise.all(s4) : t4 && console.warn(`[swup] No CSS animation duration defined on elements matching \`${t4}\``);
    });
  }
  function x2(t4, e5) {
    return (t4[e5] || "").split(", ");
  }
  function A2(t4, e5) {
    for (; t4.length < e5.length; ) t4 = t4.concat(t4);
    return Math.max(...e5.map((e6, i6) => H2(e6) + H2(t4[i6])));
  }
  function H2(t4) {
    return 1e3 * parseFloat(t4);
  }
  function V2(t4, e5 = {}, s4 = {}) {
    if ("string" != typeof t4) throw new Error("swup.navigate() requires a URL parameter");
    if (this.shouldIgnoreVisit(t4, { el: s4.el, event: s4.event })) return void window.location.assign(t4);
    const { url: n6, hash: o5 } = l2.fromUrl(t4), r6 = this.createVisit(i2({}, s4, { to: n6, hash: o5 }));
    this.performNavigation(r6, e5);
  }
  function I2(_0) {
    return __async(this, arguments, function* (t4, e5 = {}) {
      if (this.navigating) {
        if (this.visit.state >= 6) return t4.state = 2, void (this.onVisitEnd = () => this.performNavigation(t4, e5));
        yield this.hooks.call("visit:abort", this.visit, void 0), delete this.visit.to.document, this.visit.state = 8;
      }
      this.navigating = true, this.visit = t4;
      const { el: i6 } = t4.trigger;
      e5.referrer = e5.referrer || this.location.url, false === e5.animate && (t4.animation.animate = false), t4.animation.animate || this.classes.clear();
      const n6 = e5.history || y2(i6, "data-swup-history");
      "string" == typeof n6 && ["push", "replace"].includes(n6) && (t4.history.action = n6);
      const a5 = e5.animation || y2(i6, "data-swup-animation");
      var h2, c4;
      "string" == typeof a5 && (t4.animation.name = a5), t4.meta = e5.meta || {}, "object" == typeof e5.cache ? (t4.cache.read = null != (h2 = e5.cache.read) ? h2 : t4.cache.read, t4.cache.write = null != (c4 = e5.cache.write) ? c4 : t4.cache.write) : void 0 !== e5.cache && (t4.cache = { read: !!e5.cache, write: !!e5.cache }), delete e5.cache;
      try {
        yield this.hooks.call("visit:start", t4, void 0), t4.state = 3;
        const i7 = this.hooks.call("page:load", t4, { options: e5 }, (t5, e6) => __async(this, null, function* () {
          let i8;
          return t5.cache.read && (i8 = this.cache.get(t5.to.url)), e6.page = i8 || (yield this.fetchPage(t5.to.url, e6.options)), e6.cache = !!i8, e6.page;
        }));
        i7.then(({ html: e6 }) => {
          t4.advance(5), t4.to.html = e6, t4.to.document = new DOMParser().parseFromString(e6, "text/html");
        });
        const n7 = t4.to.url + t4.to.hash;
        if (t4.history.popstate || ("replace" === t4.history.action || t4.to.url === this.location.url ? r2(n7) : (this.currentHistoryIndex++, o2(n7, { index: this.currentHistoryIndex }))), this.location = l2.fromUrl(n7), t4.history.popstate && this.classes.add("is-popstate"), t4.animation.name && this.classes.add(`to-${s2(t4.animation.name)}`), t4.animation.wait && (yield i7), t4.done) return;
        if (yield this.hooks.call("visit:transition", t4, void 0, () => __async(this, null, function* () {
          if (!t4.animation.animate) return yield this.hooks.call("animation:skip", void 0), void (yield this.renderPage(t4, yield i7));
          t4.advance(4), yield this.animatePageOut(t4), t4.animation.native && document.startViewTransition ? yield document.startViewTransition(() => __async(this, null, function* () {
            return yield this.renderPage(t4, yield i7);
          })).finished : yield this.renderPage(t4, yield i7), yield this.animatePageIn(t4);
        })), t4.done) return;
        yield this.hooks.call("visit:end", t4, void 0, () => this.classes.clear()), t4.state = 7, this.navigating = false, this.onVisitEnd && (this.onVisitEnd(), this.onVisitEnd = void 0);
      } catch (e6) {
        if (!e6 || null != e6 && e6.aborted) return void (t4.state = 8);
        t4.state = 9, console.error(e6), this.options.skipPopStateHandling = () => (window.location.assign(t4.to.url + t4.to.hash), true), window.history.back();
      } finally {
        delete t4.to.document;
      }
    });
  }
  var L2 = function(t4) {
    return __async(this, null, function* () {
      yield this.hooks.call("animation:out:start", t4, void 0, () => {
        this.classes.add("is-changing", "is-animating", "is-leaving");
      }), yield this.hooks.call("animation:out:await", t4, { skip: false }, (t5, { skip: e5 }) => {
        if (!e5) return this.awaitAnimations({ selector: t5.animation.selector });
      }), yield this.hooks.call("animation:out:end", t4, void 0);
    });
  };
  var q2 = function(t4) {
    var e5;
    const i6 = t4.to.document;
    if (!i6) return false;
    const s4 = (null == (e5 = i6.querySelector("title")) ? void 0 : e5.innerText) || "";
    document.title = s4;
    const n6 = m2('[data-swup-persist]:not([data-swup-persist=""])'), o5 = t4.containers.map((t5) => {
      const e6 = document.querySelector(t5), s5 = i6.querySelector(t5);
      return e6 && s5 ? (e6.replaceWith(s5.cloneNode(true)), true) : (e6 || console.warn(`[swup] Container missing in current document: ${t5}`), s5 || console.warn(`[swup] Container missing in incoming document: ${t5}`), false);
    }).filter(Boolean);
    return n6.forEach((t5) => {
      const e6 = t5.getAttribute("data-swup-persist"), i7 = p2(`[data-swup-persist="${e6}"]`);
      i7 && i7 !== t5 && i7.replaceWith(t5);
    }), o5.length === t4.containers.length;
  };
  var R2 = function(t4) {
    const e5 = { behavior: "auto" }, { target: s4, reset: n6 } = t4.scroll, o5 = null != s4 ? s4 : t4.to.hash;
    let r6 = false;
    return o5 && (r6 = this.hooks.callSync("scroll:anchor", t4, { hash: o5, options: e5 }, (t5, { hash: e6, options: i6 }) => {
      const s5 = this.getAnchorElement(e6);
      return s5 && s5.scrollIntoView(i6), !!s5;
    })), n6 && !r6 && (r6 = this.hooks.callSync("scroll:top", t4, { options: e5 }, (t5, { options: e6 }) => (window.scrollTo(i2({ top: 0, left: 0 }, e6)), true))), r6;
  };
  var T2 = function(t4) {
    return __async(this, null, function* () {
      if (t4.done) return;
      const e5 = this.hooks.call("animation:in:await", t4, { skip: false }, (t5, { skip: e6 }) => {
        if (!e6) return this.awaitAnimations({ selector: t5.animation.selector });
      });
      yield w2(), yield this.hooks.call("animation:in:start", t4, void 0, () => {
        this.classes.remove("is-animating");
      }), yield e5, yield this.hooks.call("animation:in:end", t4, void 0);
    });
  };
  var N2 = function(t4, e5) {
    return __async(this, null, function* () {
      if (t4.done) return;
      t4.advance(6);
      const { url: i6 } = e5;
      this.isSameResolvedUrl(n2(), i6) || (r2(i6), this.location = l2.fromUrl(i6), t4.to.url = this.location.url, t4.to.hash = this.location.hash), yield this.hooks.call("content:replace", t4, { page: e5 }, (t5, {}) => {
        if (this.classes.remove("is-leaving"), t5.animation.animate && this.classes.add("is-rendering"), !this.replaceContent(t5)) throw new Error("[swup] Container mismatch, aborting");
        t5.animation.animate && (this.classes.add("is-changing", "is-animating", "is-rendering"), t5.animation.name && this.classes.add(`to-${s2(t5.animation.name)}`));
      }), yield this.hooks.call("content:scroll", t4, void 0, () => this.scrollToContent(t4)), yield this.hooks.call("page:view", t4, { url: this.location.url, title: document.title });
    });
  };
  var O2 = function(t4) {
    var e5;
    if (e5 = t4, Boolean(null == e5 ? void 0 : e5.isSwupPlugin)) {
      if (t4.swup = this, !t4._checkRequirements || t4._checkRequirements()) return t4._beforeMount && t4._beforeMount(), t4.mount(), this.plugins.push(t4), this.plugins;
    } else console.error("Not a swup plugin instance", t4);
  };
  function D2(t4) {
    const e5 = this.findPlugin(t4);
    if (e5) return e5.unmount(), e5._afterUnmount && e5._afterUnmount(), this.plugins = this.plugins.filter((t5) => t5 !== e5), this.plugins;
    console.error("No such plugin", e5);
  }
  function M2(t4) {
    return this.plugins.find((e5) => e5 === t4 || e5.name === t4 || e5.name === `Swup${String(t4)}`);
  }
  function W2(t4) {
    if ("function" != typeof this.options.resolveUrl) return console.warn("[swup] options.resolveUrl expects a callback function."), t4;
    const e5 = this.options.resolveUrl(t4);
    return e5 && "string" == typeof e5 ? e5.startsWith("//") || e5.startsWith("http") ? (console.warn("[swup] options.resolveUrl needs to return a relative url"), t4) : e5 : (console.warn("[swup] options.resolveUrl needs to return a url"), t4);
  }
  function B2(t4, e5) {
    return this.resolveUrl(t4) === this.resolveUrl(e5);
  }
  var j2 = { animateHistoryBrowsing: false, animationSelector: '[class*="transition-"]', animationScope: "html", cache: true, containers: ["#swup"], hooks: {}, ignoreVisit: (t4, { el: e5 } = {}) => !(null == e5 || !e5.closest("[data-no-swup]")), linkSelector: "a[href]", linkToSelf: "scroll", native: false, plugins: [], resolveUrl: (t4) => t4, requestHeaders: { "X-Requested-With": "swup", Accept: "text/html, application/xhtml+xml" }, skipPopStateHandling: (t4) => {
    var e5;
    return "swup" !== (null == (e5 = t4.state) ? void 0 : e5.source);
  }, timeout: 0 };
  var _2 = class {
    get currentPageUrl() {
      return this.location.url;
    }
    constructor(t4 = {}) {
      var e5, s4;
      this.version = "4.8.1", this.options = void 0, this.defaults = j2, this.plugins = [], this.visit = void 0, this.cache = void 0, this.hooks = void 0, this.classes = void 0, this.location = l2.fromUrl(window.location.href), this.currentHistoryIndex = void 0, this.clickDelegate = void 0, this.navigating = false, this.onVisitEnd = void 0, this.use = O2, this.unuse = D2, this.findPlugin = M2, this.log = () => {
      }, this.navigate = V2, this.performNavigation = I2, this.createVisit = S2, this.delegateEvent = a2, this.fetchPage = u2, this.awaitAnimations = $2, this.renderPage = N2, this.replaceContent = q2, this.animatePageIn = T2, this.animatePageOut = L2, this.scrollToContent = R2, this.getAnchorElement = C2, this.getCurrentUrl = n2, this.resolveUrl = W2, this.isSameResolvedUrl = B2, this.options = i2({}, this.defaults, t4), this.handleLinkClick = this.handleLinkClick.bind(this), this.handlePopState = this.handlePopState.bind(this), this.cache = new d2(this), this.classes = new k2(this), this.hooks = new E2(this), this.visit = this.createVisit({ to: "" }), this.currentHistoryIndex = null != (e5 = null == (s4 = window.history.state) ? void 0 : s4.index) ? e5 : 1, this.enable();
    }
    enable() {
      return __async(this, null, function* () {
        var t4;
        const { linkSelector: e5 } = this.options;
        this.clickDelegate = this.delegateEvent(e5, "click", this.handleLinkClick), window.addEventListener("popstate", this.handlePopState), this.options.animateHistoryBrowsing && (window.history.scrollRestoration = "manual"), this.options.native = this.options.native && !!document.startViewTransition, this.options.plugins.forEach((t5) => this.use(t5));
        for (const [t5, e6] of Object.entries(this.options.hooks)) {
          const [i6, s4] = this.hooks.parseName(t5);
          this.hooks.on(i6, e6, s4);
        }
        "swup" !== (null == (t4 = window.history.state) ? void 0 : t4.source) && r2(null, { index: this.currentHistoryIndex }), yield w2(), yield this.hooks.call("enable", void 0, void 0, () => {
          const t5 = document.documentElement;
          t5.classList.add("swup-enabled"), t5.classList.toggle("swup-native", this.options.native);
        });
      });
    }
    destroy() {
      return __async(this, null, function* () {
        this.clickDelegate.destroy(), window.removeEventListener("popstate", this.handlePopState), this.cache.clear(), this.options.plugins.forEach((t4) => this.unuse(t4)), yield this.hooks.call("disable", void 0, void 0, () => {
          const t4 = document.documentElement;
          t4.classList.remove("swup-enabled"), t4.classList.remove("swup-native");
        }), this.hooks.clear();
      });
    }
    shouldIgnoreVisit(t4, { el: e5, event: i6 } = {}) {
      const { origin: s4, url: n6, hash: o5 } = l2.fromUrl(t4);
      return s4 !== window.location.origin || !(!e5 || !this.triggerWillOpenNewWindow(e5)) || !!this.options.ignoreVisit(n6 + o5, { el: e5, event: i6 });
    }
    handleLinkClick(t4) {
      const e5 = t4.delegateTarget, { href: i6, url: s4, hash: n6 } = l2.fromElement(e5);
      if (this.shouldIgnoreVisit(i6, { el: e5, event: t4 })) return;
      if (this.navigating && s4 === this.visit.to.url) return void t4.preventDefault();
      const o5 = this.createVisit({ to: s4, hash: n6, el: e5, event: t4 });
      t4.metaKey || t4.ctrlKey || t4.shiftKey || t4.altKey ? this.hooks.callSync("link:newtab", o5, { href: i6 }) : 0 === t4.button && this.hooks.callSync("link:click", o5, { el: e5, event: t4 }, () => {
        var e6;
        const i7 = null != (e6 = o5.from.url) ? e6 : "";
        t4.preventDefault(), s4 && s4 !== i7 ? this.isSameResolvedUrl(s4, i7) || this.performNavigation(o5) : n6 ? this.hooks.callSync("link:anchor", o5, { hash: n6 }, () => {
          r2(s4 + n6), this.scrollToContent(o5);
        }) : this.hooks.callSync("link:self", o5, void 0, () => {
          "navigate" === this.options.linkToSelf ? this.performNavigation(o5) : (r2(s4), this.scrollToContent(o5));
        });
      });
    }
    handlePopState(t4) {
      var e5, i6, s4, o5;
      const r6 = null != (e5 = null == (i6 = t4.state) ? void 0 : i6.url) ? e5 : window.location.href;
      if (this.options.skipPopStateHandling(t4)) return;
      if (this.isSameResolvedUrl(n2(), this.location.url)) return;
      const { url: a5, hash: h2 } = l2.fromUrl(r6), c4 = this.createVisit({ to: a5, hash: h2, event: t4 });
      c4.history.popstate = true;
      const u3 = null != (s4 = null == (o5 = t4.state) ? void 0 : o5.index) ? s4 : 0;
      u3 && u3 !== this.currentHistoryIndex && (c4.history.direction = u3 - this.currentHistoryIndex > 0 ? "forwards" : "backwards", this.currentHistoryIndex = u3), c4.animation.animate = false, c4.scroll.reset = false, c4.scroll.target = false, this.options.animateHistoryBrowsing && (c4.animation.animate = true, c4.scroll.reset = true), this.hooks.callSync("history:popstate", c4, { event: t4 }, () => {
        this.performNavigation(c4);
      });
    }
    triggerWillOpenNewWindow(t4) {
      return !!t4.matches('[download], [target="_blank"]');
    }
  };

  // node_modules/@swup/plugin/dist/index.modern.js
  function r3() {
    return r3 = Object.assign ? Object.assign.bind() : function(r6) {
      for (var n6 = 1; n6 < arguments.length; n6++) {
        var e5 = arguments[n6];
        for (var t4 in e5) Object.prototype.hasOwnProperty.call(e5, t4) && (r6[t4] = e5[t4]);
      }
      return r6;
    }, r3.apply(this, arguments);
  }
  var n3 = (r6) => String(r6).split(".").map((r7) => String(parseInt(r7 || "0", 10))).concat(["0", "0"]).slice(0, 3).join(".");
  var e2 = class {
    constructor() {
      this.isSwupPlugin = true, this.swup = void 0, this.version = void 0, this.requires = {}, this.handlersToUnregister = [];
    }
    mount() {
    }
    unmount() {
      this.handlersToUnregister.forEach((r6) => r6()), this.handlersToUnregister = [];
    }
    _beforeMount() {
      if (!this.name) throw new Error("You must define a name of plugin when creating a class.");
    }
    _afterUnmount() {
    }
    _checkRequirements() {
      return "object" != typeof this.requires || Object.entries(this.requires).forEach(([r6, e5]) => {
        if (!function(r7, e6, t4) {
          const s4 = function(r8, n6) {
            var e7;
            if ("swup" === r8) return null != (e7 = n6.version) ? e7 : "";
            {
              var t5;
              const e8 = n6.findPlugin(r8);
              return null != (t5 = null == e8 ? void 0 : e8.version) ? t5 : "";
            }
          }(r7, t4);
          return !!s4 && ((r8, e7) => e7.every((e8) => {
            const [, t5, s5] = e8.match(/^([\D]+)?(.*)$/) || [];
            var o5, i6;
            return ((r9, n6) => {
              const e9 = { "": (r10) => 0 === r10, ">": (r10) => r10 > 0, ">=": (r10) => r10 >= 0, "<": (r10) => r10 < 0, "<=": (r10) => r10 <= 0 };
              return (e9[n6] || e9[""])(r9);
            })((i6 = s5, o5 = n3(o5 = r8), i6 = n3(i6), o5.localeCompare(i6, void 0, { numeric: true })), t5 || ">=");
          }))(s4, e6);
        }(r6, e5 = Array.isArray(e5) ? e5 : [e5], this.swup)) {
          const n6 = `${r6} ${e5.join(", ")}`;
          throw new Error(`Plugin version mismatch: ${this.name} requires ${n6}`);
        }
      }), true;
    }
    on(r6, n6, e5 = {}) {
      var t4;
      n6 = !(t4 = n6).name.startsWith("bound ") || t4.hasOwnProperty("prototype") ? n6.bind(this) : n6;
      const s4 = this.swup.hooks.on(r6, n6, e5);
      return this.handlersToUnregister.push(s4), s4;
    }
    once(n6, e5, t4 = {}) {
      return this.on(n6, e5, r3({}, t4, { once: true }));
    }
    before(n6, e5, t4 = {}) {
      return this.on(n6, e5, r3({}, t4, { before: true }));
    }
    replace(n6, e5, t4 = {}) {
      return this.on(n6, e5, r3({}, t4, { replace: true }));
    }
    off(r6, n6) {
      return this.swup.hooks.off(r6, n6);
    }
  };

  // node_modules/@swup/preload-plugin/dist/index.modern.js
  function r4() {
    return r4 = Object.assign ? Object.assign.bind() : function(e5) {
      for (var t4 = 1; t4 < arguments.length; t4++) {
        var s4 = arguments[t4];
        for (var r6 in s4) Object.prototype.hasOwnProperty.call(s4, r6) && (e5[r6] = s4[r6]);
      }
      return e5;
    }, r4.apply(this, arguments);
  }
  function o3() {
    return window.matchMedia("(hover: hover)").matches;
  }
  function i3(e5) {
    return !!e5 && (e5 instanceof HTMLAnchorElement || e5 instanceof SVGAElement);
  }
  var n4 = window.requestIdleCallback || ((e5) => setTimeout(e5, 1));
  var a3 = ["preloadVisibleLinks"];
  var l3 = class extends e2 {
    constructor(e5 = {}) {
      var s4;
      super(), s4 = this, this.name = "SwupPreloadPlugin", this.requires = { swup: ">=4.5" }, this.defaults = { throttle: 5, preloadInitialPage: true, preloadHoveredLinks: true, preloadVisibleLinks: { enabled: false, threshold: 0.2, delay: 500, containers: ["body"], ignore: () => false } }, this.options = void 0, this.queue = void 0, this.preloadObserver = void 0, this.preloadPromises = /* @__PURE__ */ new Map(), this.mouseEnterDelegate = void 0, this.touchStartDelegate = void 0, this.focusDelegate = void 0, this.onPageLoad = (e6, t4, s5) => {
        const { url: r6 } = e6.to;
        return r6 && this.preloadPromises.has(r6) ? this.preloadPromises.get(r6) : s5(e6, t4);
      }, this.onMouseEnter = function(e6) {
        return __async(this, null, function* () {
          if (e6.target !== e6.delegateTarget) return;
          if (!o3()) return;
          const r6 = e6.delegateTarget;
          if (!i3(r6)) return;
          const { url: n7, hash: a5 } = l2.fromElement(r6), l7 = s4.swup.createVisit({ to: n7, hash: a5, el: r6, event: e6 });
          s4.swup.hooks.callSync("link:hover", l7, { el: r6, event: e6 }), s4.preload(r6, { priority: true });
        });
      }, this.onTouchStart = (e6) => {
        if (o3()) return;
        const t4 = e6.delegateTarget;
        i3(t4) && this.preload(t4, { priority: true });
      }, this.onFocus = (e6) => {
        const t4 = e6.delegateTarget;
        i3(t4) && this.preload(t4, { priority: true });
      };
      const { preloadVisibleLinks: n6 } = e5, l6 = function(e6, t4) {
        if (null == e6) return {};
        var s5, r6, o5 = {}, i6 = Object.keys(e6);
        for (r6 = 0; r6 < i6.length; r6++) t4.indexOf(s5 = i6[r6]) >= 0 || (o5[s5] = e6[s5]);
        return o5;
      }(e5, a3);
      this.options = r4({}, this.defaults, l6), "object" == typeof n6 ? this.options.preloadVisibleLinks = r4({}, this.options.preloadVisibleLinks, { enabled: true }, n6) : this.options.preloadVisibleLinks.enabled = Boolean(n6), this.preload = this.preload.bind(this), this.queue = /* @__PURE__ */ function(e6 = 1) {
        const t4 = [], s5 = [];
        let r6 = 0, o5 = 0;
        function i6() {
          o5 < e6 && r6 > 0 && ((s5.shift() || t4.shift() || (() => {
          }))(), r6--, o5++);
        }
        return { add: function(e7, o6 = false) {
          if (e7.__queued) {
            if (!o6) return;
            {
              const s6 = t4.indexOf(e7);
              if (s6 >= 0) {
                const e8 = t4.splice(s6, 1);
                r6 -= e8.length;
              }
            }
          }
          e7.__queued = true, (o6 ? s5 : t4).push(e7), r6++, r6 <= 1 && i6();
        }, next: function() {
          o5--, i6();
        } };
      }(this.options.throttle);
    }
    mount() {
      const e5 = this.swup;
      e5.options.cache ? (e5.hooks.create("page:preload"), e5.hooks.create("link:hover"), e5.preload = this.preload, e5.preloadLinks = this.preloadLinks, this.replace("page:load", this.onPageLoad), this.preloadLinks(), this.on("page:view", () => this.preloadLinks()), this.options.preloadVisibleLinks.enabled && (this.preloadVisibleLinks(), this.on("page:view", () => this.preloadVisibleLinks())), this.options.preloadHoveredLinks && this.preloadLinksOnAttention(), this.options.preloadInitialPage && this.preload(n2())) : console.warn("SwupPreloadPlugin: swup cache needs to be enabled for preloading");
    }
    unmount() {
      var e5, t4, s4;
      this.swup.preload = void 0, this.swup.preloadLinks = void 0, this.preloadPromises.clear(), null == (e5 = this.mouseEnterDelegate) || e5.destroy(), null == (t4 = this.touchStartDelegate) || t4.destroy(), null == (s4 = this.focusDelegate) || s4.destroy(), this.stopPreloadingVisibleLinks();
    }
    preload(_0) {
      return __async(this, arguments, function* (e5, s4 = {}) {
        var r6;
        let o5, n6;
        const a5 = null != (r6 = s4.priority) && r6;
        if (Array.isArray(e5)) return Promise.all(e5.map((e6) => this.preload(e6)));
        if (i3(e5)) n6 = e5, { href: o5 } = l2.fromElement(e5);
        else {
          if ("string" != typeof e5) return;
          o5 = e5;
        }
        if (!o5) return;
        if (this.preloadPromises.has(o5)) return this.preloadPromises.get(o5);
        if (!this.shouldPreload(o5, { el: n6 })) return;
        const l6 = new Promise((e6) => {
          this.queue.add(() => {
            this.performPreload(o5).catch(() => {
            }).then((t4) => e6(t4)).finally(() => {
              this.queue.next(), this.preloadPromises.delete(o5);
            });
          }, a5);
        });
        return this.preloadPromises.set(o5, l6), l6;
      });
    }
    preloadLinks() {
      n4(() => {
        Array.from(document.querySelectorAll("a[data-swup-preload], [data-swup-preload-all] a")).forEach((e5) => this.preload(e5));
      });
    }
    preloadLinksOnAttention() {
      const { swup: e5 } = this, { linkSelector: t4 } = e5.options, s4 = { passive: true, capture: true };
      this.mouseEnterDelegate = e5.delegateEvent(t4, "mouseenter", this.onMouseEnter, s4), this.touchStartDelegate = e5.delegateEvent(t4, "touchstart", this.onTouchStart, s4), this.focusDelegate = e5.delegateEvent(t4, "focus", this.onFocus, s4);
    }
    preloadVisibleLinks() {
      if (this.preloadObserver) return void this.preloadObserver.update();
      const { threshold: e5, delay: s4, containers: r6 } = this.options.preloadVisibleLinks;
      this.preloadObserver = function({ threshold: e6, delay: s5, containers: r7, callback: o5, filter: i6 }) {
        const a5 = /* @__PURE__ */ new Map(), l6 = new IntersectionObserver((e7) => {
          e7.forEach((e8) => {
            e8.isIntersecting ? h2(e8.target) : d3(e8.target);
          });
        }, { threshold: e6 }), h2 = (e7) => {
          var r8;
          const { href: i7 } = l2.fromElement(e7), n6 = null != (r8 = a5.get(i7)) ? r8 : /* @__PURE__ */ new Set();
          a5.set(i7, n6), n6.add(e7), setTimeout(() => {
            const t4 = a5.get(i7);
            null != t4 && t4.size && (o5(e7), l6.unobserve(e7), t4.delete(e7));
          }, s5);
        }, d3 = (e7) => {
          var s6;
          const { href: r8 } = l2.fromElement(e7);
          null == (s6 = a5.get(r8)) || s6.delete(e7);
        }, u3 = () => {
          n4(() => {
            const e7 = r7.map((e8) => `${e8} a[*|href]`).join(", ");
            Array.from(document.querySelectorAll(e7)).filter((e8) => i6(e8)).forEach((e8) => l6.observe(e8));
          });
        };
        return { start: () => u3(), stop: () => l6.disconnect(), update: () => (a5.clear(), u3()) };
      }({ threshold: e5, delay: s4, containers: r6, callback: (e6) => this.preload(e6), filter: (e6) => {
        if (this.options.preloadVisibleLinks.ignore(e6)) return false;
        if (!e6.matches(this.swup.options.linkSelector)) return false;
        const { href: s5 } = l2.fromElement(e6);
        return this.shouldPreload(s5, { el: e6 });
      } }), this.preloadObserver.start();
    }
    stopPreloadingVisibleLinks() {
      this.preloadObserver && this.preloadObserver.stop();
    }
    shouldPreload(e5, { el: r6 } = {}) {
      const { url: o5, href: i6 } = l2.fromUrl(e5);
      return !(!function() {
        if (navigator.connection) {
          var e6;
          if (navigator.connection.saveData) return false;
          if (null != (e6 = navigator.connection.effectiveType) && e6.endsWith("2g")) return false;
        }
        return true;
      }() || this.swup.cache.has(o5) || this.preloadPromises.has(o5) || this.swup.shouldIgnoreVisit(i6, { el: r6 }) || r6 && this.swup.resolveUrl(o5) === this.swup.resolveUrl(n2()));
    }
    performPreload(e5) {
      return __async(this, null, function* () {
        var s4 = this;
        const { url: r6 } = l2.fromUrl(e5), o5 = this.swup.createVisit({ to: r6 }), i6 = yield this.swup.hooks.call("page:preload", o5, { url: r6 }, function(t4, r7) {
          return __async(this, null, function* () {
            return r7.page = yield s4.swup.fetchPage(e5, { visit: t4 }), r7.page;
          });
        });
        return i6;
      });
    }
  };

  // assets/scripts/utils/string.js
  var toDash = (str) => str.split(/(?=[A-Z])/).join("-").toLowerCase();

  // assets/scripts/utils/swup/SwupModularPlugin.js
  var SwupModularPlugin = class extends e2 {
    /**
     * Executed each time an instance of this plugin is created.
     * Can be used for things that don't rely on access to the swup instance.
     */
    constructor(options = {}) {
      super();
      __publicField(this, "name", "SwupModularPlugin");
      /* Version requirements */
      __publicField(this, "requires", { swup: ">=4" });
      /* Default options */
      __publicField(this, "defaults", {
        modularInstance: false
      });
      this.options = __spreadValues(__spreadValues({}, this.defaults), options);
    }
    /**
     * Executed when swup is initialized with this plugin.
     * You can use this.swup here to access the swup instance.
     */
    mount() {
      this.swup.hooks.before("content:replace", (visit) => {
        var _a, _b;
        for (let container of visit.containers) {
          const oldContainer = (_a = this.options.modularInstance) == null ? void 0 : _a.el.querySelector(container);
          (_b = this.options.modularInstance) == null ? void 0 : _b.call("destroy", oldContainer, "app");
        }
      });
      this.swup.hooks.on("content:replace", (visit) => {
        var _a, _b;
        this.updateDocumentAttributes(visit);
        for (let container of visit.containers) {
          const newContainer = (_a = this.options.modularInstance) == null ? void 0 : _a.el.querySelector(container);
          (_b = this.options.modularInstance) == null ? void 0 : _b.call("update", newContainer, "app");
        }
      });
    }
    updateDocumentAttributes(visit) {
      if (visit.fragmentVisit) return;
      const parser = new DOMParser();
      const nextDOM = parser.parseFromString(visit.to.html, "text/html");
      const newDataset = Object.assign({}, nextDOM.querySelector("html").dataset);
      Object.entries(newDataset).forEach(([key2, val2]) => {
        $html.setAttribute(`data-${toDash(key2)}`, val2);
      });
    }
    /**
     * Executed when a swup instance with this plugin is disabled.
     * You can use this.swup here to access the swup instance.
     * Make sure to undo any DOM changes and remove event listeners here.
     */
    unmount() {
    }
  };

  // assets/scripts/utils/swup/SwupLSPlugin.js
  var SwupLSPlugin = class extends e2 {
    /**
     * Executed each time an instance of this plugin is created.
     * Can be used for things that don't rely on access to the swup instance.
     */
    constructor(options = {}) {
      super();
      __publicField(this, "name", "SwupLSPlugin");
      /* Version requirements */
      __publicField(this, "requires", { swup: ">=4" });
      /* Default options */
      __publicField(this, "defaults", {
        modularInstance: false
      });
      this.options = __spreadValues(__spreadValues({}, this.defaults), options);
    }
    /**
     * Executed when swup is initialized with this plugin.
     * You can use this.swup here to access the swup instance.
     */
    mount() {
      this.beforeContentReplace = this.beforeContentReplace.bind(this);
      this.onContentReplace = this.onContentReplace.bind(this);
      this.swup.hooks.before("content:replace", this.beforeContentReplace);
      this.swup.hooks.on("content:replace", this.onContentReplace);
    }
    beforeContentReplace(visit) {
      var _a, _b;
      if (visit.fragmentVisit) {
        for (let container of visit.fragmentVisit.containers) {
          const oldContainer = (_a = this.options.modularInstance) == null ? void 0 : _a.el.querySelector(container);
          (_b = this.options.modularInstance) == null ? void 0 : _b.call("removeScrollElements", oldContainer, "Scroll");
        }
      }
    }
    onContentReplace(visit) {
      var _a, _b;
      if (visit.fragmentVisit) {
        for (let container of visit.fragmentVisit.containers) {
          const newContainer = (_a = this.options.modularInstance) == null ? void 0 : _a.el.querySelector(container);
          (_b = this.options.modularInstance) == null ? void 0 : _b.call("addScrollElements", newContainer, "Scroll");
        }
      }
    }
    /**
     * Executed when a swup instance with this plugin is disabled.
     * You can use this.swup here to access the swup instance.
     * Make sure to undo any DOM changes and remove event listeners here.
     */
    unmount() {
      this.swup.hooks.off("content:replace", this.beforeContentReplace);
      this.swup.hooks.off("content:replace", this.onContentReplace);
    }
  };

  // node_modules/scrl/dist/index.modern.js
  function t2() {
    return t2 = Object.assign ? Object.assign.bind() : function(t4) {
      for (var i6 = 1; i6 < arguments.length; i6++) {
        var o5 = arguments[i6];
        for (var s4 in o5) Object.prototype.hasOwnProperty.call(o5, s4) && (t4[s4] = o5[s4]);
      }
      return t4;
    }, t2.apply(this, arguments);
  }
  var i4 = class {
    constructor(i6) {
      this._raf = null, this._positionY = 0, this._velocityY = 0, this._targetPositionY = 0, this._targetPositionYWithOffset = 0, this._direction = 0, this.scrollTo = (t4) => {
        if (t4 && t4.nodeType) this._targetPositionY = Math.round(t4.getBoundingClientRect().top + window.pageYOffset);
        else {
          if (parseInt(this._targetPositionY) !== this._targetPositionY) return void console.error("Argument must be a number or an element.");
          this._targetPositionY = Math.round(t4);
        }
        this._targetPositionY > document.documentElement.scrollHeight - window.innerHeight && (this._targetPositionY = document.documentElement.scrollHeight - window.innerHeight), this._positionY = document.body.scrollTop || document.documentElement.scrollTop, this._direction = this._positionY > this._targetPositionY ? -1 : 1, this._targetPositionYWithOffset = this._targetPositionY + this._direction, this._velocityY = 0, this._positionY !== this._targetPositionY ? (this.options.onStart(), this._animate()) : this.options.onAlreadyAtPositions();
      }, this._animate = () => {
        this._update(), this._render(), 1 === this._direction && this._targetPositionY > this._positionY || -1 === this._direction && this._targetPositionY < this._positionY ? (this._raf = requestAnimationFrame(this._animate), this.options.onTick()) : (this._positionY = this._targetPositionY, this._render(), this._raf = null, this.options.onTick(), this.options.onEnd());
      }, this._update = () => {
        const t4 = this._targetPositionYWithOffset - this._positionY;
        return this._velocityY += t4 * this.options.acceleration, this._velocityY *= this.options.friction, this._positionY += this._velocityY, Math.abs(t4);
      }, this._render = () => {
        window.scrollTo(0, this._positionY);
      }, this.options = t2({}, { onAlreadyAtPositions: () => {
      }, onCancel: () => {
      }, onEnd: () => {
      }, onStart: () => {
      }, onTick: () => {
      }, friction: 0.7, acceleration: 0.04 }, i6), i6 && i6.friction && (this.options.friction = 1 - i6.friction), window.addEventListener("mousewheel", (t4) => {
        this._raf && (this.options.onCancel(), cancelAnimationFrame(this._raf), this._raf = null);
      }, { passive: true });
    }
  };

  // node_modules/@swup/scroll-plugin/dist/index.modern.js
  function e3() {
    return e3 = Object.assign ? Object.assign.bind() : function(t4) {
      for (var o5 = 1; o5 < arguments.length; o5++) {
        var s4 = arguments[o5];
        for (var e5 in s4) Object.prototype.hasOwnProperty.call(s4, e5) && (t4[e5] = s4[e5]);
      }
      return t4;
    }, e3.apply(this, arguments);
  }
  var l4 = class extends e2 {
    constructor(t4 = {}) {
      super(), this.name = "SwupScrollPlugin", this.requires = { swup: ">=4.2.0" }, this.scrl = void 0, this.defaults = { doScrollingRightAway: false, animateScroll: { betweenPages: true, samePageWithHash: true, samePage: true }, scrollFriction: 0.3, scrollAcceleration: 0.04, getAnchorElement: void 0, offset: 0, scrollContainers: "[data-swup-scroll-container]", shouldResetScrollPosition: () => true, markScrollTarget: false }, this.options = void 0, this.cachedScrollPositions = {}, this.previousScrollRestoration = void 0, this.currentCacheKey = void 0, this.getAnchorElement = (t5 = "") => "function" == typeof this.options.getAnchorElement ? this.options.getAnchorElement(t5) : this.swup.getAnchorElement(t5), this.getOffset = (t5) => t5 ? "function" == typeof this.options.offset ? parseInt(String(this.options.offset(t5)), 10) : parseInt(String(this.options.offset), 10) : 0, this.onBeforeLinkToSelf = (t5) => {
        t5.scroll.animate = this.shouldAnimate("samePage");
      }, this.handleScrollToTop = (t5) => {
        var o5, s4;
        return null == (o5 = (s4 = this.swup).scrollTo) || o5.call(s4, 0, t5.scroll.animate), true;
      }, this.onBeforeLinkToAnchor = (t5) => {
        t5.scroll.animate = this.shouldAnimate("samePageWithHash");
      }, this.handleScrollToAnchor = (t5, { hash: o5 }) => this.maybeScrollToAnchor(o5, t5.scroll.animate), this.onBeforeVisitStart = (t5) => {
        t5.scroll.scrolledToContent = false, t5.scroll.animate = this.shouldAnimate("betweenPages");
      }, this.onVisitStart = (t5) => {
        var o5;
        this.cacheScrollPositions(t5.from.url), this.maybeResetScrollPositions(t5);
        const s4 = null != (o5 = t5.scroll.target) ? o5 : t5.to.hash;
        t5.scroll.animate && this.options.doScrollingRightAway && !s4 && this.doScrollingBetweenPages(t5);
      }, this.handleScrollToContent = (t5) => {
        t5.scroll.scrolledToContent || this.doScrollingBetweenPages(t5), this.restoreScrollContainers(t5.to.url);
      }, this.doScrollingBetweenPages = (t5) => {
        var o5, s4;
        if (t5.history.popstate && !t5.animation.animate) return;
        const e5 = null != (o5 = t5.scroll.target) ? o5 : t5.to.hash;
        if (e5 && this.maybeScrollToAnchor(e5, t5.scroll.animate)) return;
        if (!t5.scroll.reset) return;
        const l6 = this.getCachedScrollPositions(t5.to.url), r6 = (null == l6 || null == (s4 = l6.window) ? void 0 : s4.top) || 0;
        requestAnimationFrame(() => {
          var o6, s5;
          return null == (o6 = (s5 = this.swup).scrollTo) ? void 0 : o6.call(s5, r6, t5.scroll.animate);
        }), t5.scroll.scrolledToContent = true;
      }, this.maybeResetScrollPositions = (t5) => {
        const { popstate: o5 } = t5.history, { url: s4 } = t5.to, { el: e5 } = t5.trigger;
        o5 || e5 && !this.options.shouldResetScrollPosition(e5) || this.resetScrollPositions(s4);
      }, this.options = e3({}, this.defaults, t4);
    }
    mount() {
      const t4 = this.swup;
      t4.hooks.create("scroll:start"), t4.hooks.create("scroll:end");
      const o5 = this.swup.createVisit({ to: this.swup.currentPageUrl });
      this.scrl = new i4({ onStart: () => t4.hooks.callSync("scroll:start", o5, void 0), onEnd: () => t4.hooks.callSync("scroll:end", o5, void 0), onCancel: () => t4.hooks.callSync("scroll:end", o5, void 0), friction: this.options.scrollFriction, acceleration: this.options.scrollAcceleration }), t4.scrollTo = (s4, e5 = true) => {
        e5 ? this.scrl.scrollTo(s4) : (t4.hooks.callSync("scroll:start", o5, void 0), window.scrollTo(0, s4), t4.hooks.callSync("scroll:end", o5, void 0));
      }, this.previousScrollRestoration = window.history.scrollRestoration, t4.options.animateHistoryBrowsing && (window.history.scrollRestoration = "manual"), this.updateScrollTarget = this.updateScrollTarget.bind(this), this.options.markScrollTarget && (window.addEventListener("popstate", this.updateScrollTarget), window.addEventListener("hashchange", this.updateScrollTarget), this.on("page:view", this.updateScrollTarget), this.on("link:anchor", this.updateScrollTarget), this.on("link:self", this.updateScrollTarget), this.updateScrollTarget()), this.before("visit:start", this.onBeforeVisitStart, { priority: -1 }), this.on("visit:start", this.onVisitStart, { priority: 1 }), this.replace("content:scroll", this.handleScrollToContent), this.before("link:self", this.onBeforeLinkToSelf, { priority: -1 }), this.replace("scroll:top", this.handleScrollToTop), this.before("link:anchor", this.onBeforeLinkToAnchor, { priority: -1 }), this.replace("scroll:anchor", this.handleScrollToAnchor);
    }
    unmount() {
      super.unmount(), this.previousScrollRestoration && (window.history.scrollRestoration = this.previousScrollRestoration), window.removeEventListener("popstate", this.updateScrollTarget), window.removeEventListener("hashchange", this.updateScrollTarget), this.cachedScrollPositions = {}, delete this.swup.scrollTo, delete this.scrl;
    }
    shouldAnimate(t4) {
      return "boolean" == typeof this.options.animateScroll ? this.options.animateScroll : this.options.animateScroll[t4];
    }
    maybeScrollToAnchor(t4, o5 = false) {
      var s4, e5;
      if (!t4) return false;
      const l6 = this.getAnchorElement(t4);
      if (!l6) return console.warn(`Anchor target ${t4} not found`), false;
      if (!(l6 instanceof Element)) return console.warn(`Anchor target ${t4} is not a DOM node`), false;
      const { top: r6 } = l6.getBoundingClientRect(), i6 = r6 + window.scrollY - this.getOffset(l6);
      return null == (s4 = (e5 = this.swup).scrollTo) || s4.call(e5, i6, o5), true;
    }
    cacheScrollPositions(t4) {
      const s4 = this.swup.resolveUrl(t4), e5 = m2(this.options.scrollContainers).map((t5) => ({ top: t5.scrollTop, left: t5.scrollLeft })), l6 = { window: { top: window.scrollY, left: window.scrollX }, containers: e5 };
      this.cachedScrollPositions[s4] = l6;
    }
    resetScrollPositions(t4) {
      const o5 = this.swup.resolveUrl(t4);
      delete this.cachedScrollPositions[o5];
    }
    getCachedScrollPositions(t4) {
      const o5 = this.swup.resolveUrl(t4);
      return this.cachedScrollPositions[o5];
    }
    restoreScrollContainers(t4) {
      const s4 = this.getCachedScrollPositions(t4);
      s4 && 0 !== s4.containers.length && m2(this.options.scrollContainers).forEach((t5, o5) => {
        const e5 = s4.containers[o5];
        null != e5 && (t5.scrollTop = e5.top, t5.scrollLeft = e5.left);
      });
    }
    updateScrollTarget() {
      var t4;
      const { hash: o5 } = window.location, s4 = document.querySelector("[data-swup-scroll-target]");
      let e5 = this.getAnchorElement(o5);
      e5 instanceof HTMLBodyElement && (e5 = null), s4 !== e5 && (null == s4 || s4.removeAttribute("data-swup-scroll-target"), null == (t4 = e5) || t4.setAttribute("data-swup-scroll-target", ""));
    }
  };

  // assets/scripts/modules/Load.js
  var Load_default = class extends _default {
    constructor(m3) {
      super(m3);
      this.onVisitStart = this.onVisitStart.bind(this);
      this.onVisitEnd = this.onVisitEnd.bind(this);
      this.beforeContentReplace = this.beforeContentReplace.bind(this);
      this.onContentReplace = this.onContentReplace.bind(this);
      this.onAnimationInStartBind = this.onAnimationInStart.bind(this);
      this.onAnimationOutStartBind = this.onAnimationOutStart.bind(this);
      this.onLinkAnchorBind = this.onLinkAnchor.bind(this);
      this.load = null;
    }
    init() {
      this.load = new _2({
        containers: ["[data-load-container]"],
        animateHistoryBrowsing: true,
        linkToSelf: "navigate",
        // cache: false,
        plugins: [
          new SwupLSPlugin({ modularInstance: this }),
          new SwupModularPlugin({ modularInstance: this }),
          new l3({}),
          new l4({
            animateScroll: window.matchMedia("(prefers-reduced-motion: reduce)").matches ? false : {
              betweenPages: true,
              samePageWithHash: true,
              samePage: true
            }
          })
        ]
      });
      this.load.hooks.on("visit:start", this.onVisitStart);
      this.load.hooks.on("visit:end", this.onVisitEnd);
      this.load.hooks.before("content:replace", this.beforeContentReplace);
      this.load.hooks.on("content:replace", this.onContentReplace);
      this.load.hooks.on("animation:in:start", this.onAnimationInStartBind);
      this.load.hooks.on("animation:out:start", this.onAnimationOutStartBind);
      this.load.hooks.on("link:anchor", this.onLinkAnchorBind);
      const hash = window.location.hash;
      if (hash && document.querySelector(hash)) {
        requestAnimationFrame(() => {
          this.call("scrollTo", { target: hash, options: { offset: -100 } }, "Scroll");
        });
      }
    }
    replaceUrl(url) {
      this.load.navigate(url, { history: "replace", animate: false });
    }
    goTo(url, options = {}) {
      this.load.navigate(url, {
        history: options.history || "push",
        animate: options.animate !== void 0 ? options.animate : true,
        scroll: options.scroll || true
      });
    }
    // ==========================================================================
    // HOOKS
    // ==========================================================================
    onVisitStart(visit) {
      $html.classList.remove("has-dark-hero-inview");
      $html.classList.remove("has-project-anchors-inview");
    }
    onVisitEnd(visit) {
      window.dispatchEvent(new CustomEvent(CUSTOM_EVENT.VISIT_END, { detail: visit }));
      this.call("close", null, "Menu");
      const currentLang = document.documentElement.lang;
      const $langSwitcherRef = document.querySelector("[data-lang-switcher-ref]");
      const $allLangSwitcher = document.querySelectorAll("[data-lang-switcher]");
      $allLangSwitcher.forEach(($langSwitcher) => {
        $langSwitcher.href = $langSwitcherRef.href;
      });
      const $menuLinks = document.querySelectorAll("[data-menu-link]");
      $menuLinks.forEach(($menuLink) => {
        const $parent = $menuLink.parentElement;
        const urlTarget = visit.to.url;
        if ($menuLink.href.includes(urlTarget) && urlTarget !== `/${currentLang}` && !$menuLink.href.includes("#")) {
          $parent.classList.add("is-active");
        } else {
          $parent.classList.remove("is-active");
        }
      });
    }
    onLinkAnchor(visit) {
      this.call("close", null, "Menu");
    }
    beforeContentReplace(visit) {
      return __async(this, null, function* () {
      });
    }
    onContentReplace(visit) {
      if (visit.to.url !== visit.from.url) {
        window.scrollTo({
          top: 50,
          left: 0,
          behavior: "instant"
        });
      }
    }
    onAnimationOutStart(visit) {
      $html.classList.remove(CSS_CLASS.READY);
    }
    onAnimationInStart(visit) {
      $html.classList.add(CSS_CLASS.READY);
    }
  };

  // assets/scripts/constants/project-loadmore.js
  var loadProject = ($template, data2) => {
    const $clone = $template.content.cloneNode(true);
    const $root = $clone.querySelector("[data-template='root']");
    const $image = $clone.querySelector("[data-template='image']");
    const $title = $clone.querySelector("[data-template='title']");
    const $stats = $clone.querySelector("[data-template='stats']");
    const $statItem = $clone.querySelector("[data-template='stat']");
    const $tags = $clone.querySelector("[data-template='tags']");
    const $tagItem = $clone.querySelector("[data-template='tag']");
    const $linkWrapper = $clone.querySelector("[data-template='link']");
    const $arrow = $clone.querySelector("[data-template='arrow']");
    if (data2.image.src) {
      const $imageEl = $image.querySelector("img");
      $imageEl.src = data2.image.src;
      $imageEl.alt = data2.image.alt;
      $imageEl.width = data2.image.width;
      $imageEl.height = data2.image.height;
    } else {
      $image.remove();
    }
    $title.innerHTML = data2.title;
    $statItem.remove();
    data2.stats.forEach((stat) => {
      const $stat = $statItem.cloneNode(true);
      const $label = $stat.querySelector("[data-template='label']");
      const $value = $stat.querySelector("[data-template='value']");
      $label.innerHTML = stat.label;
      $value.innerHTML = stat.value;
      $stats.appendChild($stat);
    });
    $tagItem.remove();
    data2.tags.forEach((tag) => {
      const $tag = $tagItem.cloneNode(true);
      const $label = $tag.querySelector("[data-template='label']");
      $label.innerHTML = tag;
      $tags.appendChild($tag);
    });
    $linkWrapper.replaceChildren();
    if (data2.cta && data2.cta.url) {
      const $link = document.createElement("a");
      $link.className = "c-tile-project_link";
      $link.href = data2.cta.url;
      if (data2.cta.isExternal) {
        $link.target = "_blank";
        $link.rel = "noopener noreferrer";
      } else {
        $link.target = "_self";
      }
      const span = document.createElement("span");
      span.className = "u-screen-reader-text";
      span.setAttribute("data-template", "label");
      span.textContent = data2.title;
      $link.appendChild(span);
      $linkWrapper.appendChild($link);
    } else {
      const $a11Title = document.createElement("span");
      $a11Title.className = "u-screen-reader-text";
      $a11Title.textContent = data2.title;
      $linkWrapper.appendChild($a11Title);
      $root.classList.remove("-link");
      $arrow.remove();
    }
    return $clone;
  };
  var project_loadmore_default = loadProject;

  // assets/scripts/constants/news-loadmore.js
  var loadNews = ($template, data2) => {
    var _a;
    const $clone = $template.content.cloneNode(true);
    const $root = $clone.querySelector("[data-template='root']");
    const $image = $clone.querySelector("[data-template='image']");
    const $title = $clone.querySelector("[data-template='title']");
    const $tags = $clone.querySelector("[data-template='tags']");
    const $tagItem = $clone.querySelector("[data-template='tag']");
    const $date = $clone.querySelectorAll("[data-template='date']");
    const $linkWrapper = $clone.querySelector("[data-template='link']");
    const $foot = $clone.querySelector("[data-template='foot']");
    const $label = $clone.querySelector("[data-template='label']");
    if (data2.image.src) {
      const $imageEl = $image.querySelector("img");
      $imageEl.src = data2.image.src;
      $imageEl.alt = data2.image.alt;
      $imageEl.width = data2.image.width;
      $imageEl.height = data2.image.height;
    } else {
      $image.remove();
    }
    $title.innerHTML = data2.title;
    $tagItem.remove();
    data2.categories.forEach((category) => {
      var _a2;
      const $tag = $tagItem.cloneNode(true);
      $tag.innerHTML = (_a2 = category.label) != null ? _a2 : category.name;
      $tags.appendChild($tag);
    });
    $date.forEach(($dateEl) => {
      $dateEl.innerHTML = data2.date;
      $dateEl.datetime = data2.date;
    });
    $linkWrapper.replaceChildren();
    if (data2.cta && data2.cta.url) {
      const $link = document.createElement("a");
      $link.className = "c-tile-news_link";
      $link.href = data2.cta.url;
      $label.innerHTML = (_a = data2.cta.label) != null ? _a : data2.title;
      if (data2.cta.isExternal) {
        $link.target = "_blank";
        $link.rel = "noopener noreferrer";
      } else {
        $link.target = "_self";
      }
      const span = document.createElement("span");
      span.className = "u-screen-reader-text";
      span.setAttribute("data-template", "label");
      span.textContent = data2.title;
      $link.appendChild(span);
      $linkWrapper.appendChild($link);
      if (data2.cta.isExternal) {
        $foot.innerHTML = $foot.innerHTML.replace(/arrow-right/g, "arrow-external");
      }
    } else {
      const $a11Title = document.createElement("span");
      $a11Title.className = "u-screen-reader-text";
      $a11Title.textContent = data2.title;
      $linkWrapper.appendChild($a11Title);
      $root.classList.remove("-link");
    }
    return $clone;
  };
  var news_loadmore_default = loadNews;

  // assets/scripts/modules/Loadmore.js
  var _Loadmore = class _Loadmore extends _default {
    constructor(m3) {
      super(m3);
      this.onFetch = this.onFetch.bind(this);
      this.$list = this.$("list")[0];
      this.$template = this.$("template")[0];
      this.$skeleton = this.$("skeleton")[0];
      this.apiRoute = location.origin + this.getData("api");
      this.total = parseInt(this.getData("total"));
      this.currentPage = parseInt(this.getData("current"));
      this.isLoading = false;
      this.type = this.getData("type");
      this.complete = false;
      this.way = null;
      this.animation = null;
      this.nextUrl = this.getData("next");
      switch (this.type) {
        case "project":
          this.fillFunction = project_loadmore_default;
          break;
        case "article":
          this.fillFunction = news_loadmore_default;
          break;
      }
    }
    // =============================================================================
    // Lifecycle
    // =============================================================================
    init() {
    }
    destroy() {
      super.destroy();
    }
    // =============================================================================
    // Callbacks
    // =============================================================================
    onTrigger({ way }) {
      this.way = way;
      this.load();
    }
    onFetch(json, url) {
      const $items = [];
      this.currentPage = json.pagination.currentPage;
      this.isLoading = false;
      if (this.currentPage === this.total) {
        this.destroy();
        this.complete = true;
      }
      gsapWithCSS.delayedCall(_Loadmore.waitingDuration / 1e3, () => {
        const $animatedItems = [];
        for (let index2 = 0; index2 < json.items.length; index2++) {
          const itemData = json.items[index2];
          $items.push(this.fillFunction(this.$template, itemData));
        }
        $items.forEach(($item) => {
          this.call("addScrollElements", $item, "Scroll");
          $item.firstElementChild.style.opacity = 0;
          $animatedItems.push($item.firstElementChild);
          this.$list.appendChild($item);
        });
        this.el.classList.remove("is-loading-more");
        this.animation && this.animation.kill();
        this.$skeleton.style = "";
        gsapWithCSS.fromTo(
          $animatedItems,
          {
            opacity: 0,
            y: 40,
            scale: 1.025
          },
          {
            opacity: 1,
            y: 0,
            scale: 1,
            stagger: 0.1,
            duration: 0.3,
            onComplete: () => {
              if (this.way === "leave" && json.pagination.remainingItems > 0) {
                this.load();
              }
            }
          }
        );
      });
    }
    // =============================================================================
    // Methods
    // =============================================================================
    getFetchUrl() {
      const url = new URL(this.apiRoute);
      url.searchParams.delete("page");
      const params = {
        page: this.currentPage + 1
      };
      const addSearchParams = (url2, params2 = {}) => new URL(
        `${url2.origin}${url2.pathname}?${new URLSearchParams([
          ...Array.from(url2.searchParams.entries()),
          ...Object.entries(params2)
        ])}`
      );
      const { href } = addSearchParams(url, params);
      return href;
    }
    fetchJson(url, callback) {
      return __async(this, null, function* () {
        this.controller = new AbortController();
        const signal = this.controller.signal;
        try {
          const response = yield fetch(url, { signal });
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          } else {
            const json = yield response.json();
            callback(json, url);
          }
        } catch (error) {
          if (error.name === "AbortError") {
            console.log(`Fetch request was aborted for ${url}`);
            callback(null);
          } else {
            console.error("Fetch error: ", error);
            callback(null);
            requestAnimationFrame(() => {
              this.isLoading = false;
              this.el.classList.remove("is-loading-more");
              this.animation && this.animation.kill();
              this.$skeleton.style = "";
            });
          }
        }
      });
    }
    load() {
      if (this.way === "leave" && !this.isLoading && !this.complete) {
        this.isLoading = true;
        this.el.classList.add("is-loading-more");
        this.animation && this.animation.kill();
        requestAnimationFrame(() => {
          this.animation = gsapWithCSS.to(this.$skeleton, {
            autoAlpha: 1,
            display: "block",
            duration: _Loadmore.waitingDuration / 1e3 * 0.3
          });
          this.fetchJson(this.getFetchUrl(), this.onFetch);
        });
      }
    }
  };
  __publicField(_Loadmore, "waitingDuration", 1200);
  var Loadmore = _Loadmore;

  // node_modules/@googlemaps/js-api-loader/dist/index.mjs
  function __awaiter(thisArg, _arguments, P3, generator) {
    function adopt(value2) {
      return value2 instanceof P3 ? value2 : new P3(function(resolve) {
        resolve(value2);
      });
    }
    return new (P3 || (P3 = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e5) {
          reject(e5);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e5) {
          reject(e5);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function getDefaultExportFromCjs(x3) {
    return x3 && x3.__esModule && Object.prototype.hasOwnProperty.call(x3, "default") ? x3["default"] : x3;
  }
  var fastDeepEqual = function equal(a5, b3) {
    if (a5 === b3) return true;
    if (a5 && b3 && typeof a5 == "object" && typeof b3 == "object") {
      if (a5.constructor !== b3.constructor) return false;
      var length2, i6, keys;
      if (Array.isArray(a5)) {
        length2 = a5.length;
        if (length2 != b3.length) return false;
        for (i6 = length2; i6-- !== 0; )
          if (!equal(a5[i6], b3[i6])) return false;
        return true;
      }
      if (a5.constructor === RegExp) return a5.source === b3.source && a5.flags === b3.flags;
      if (a5.valueOf !== Object.prototype.valueOf) return a5.valueOf() === b3.valueOf();
      if (a5.toString !== Object.prototype.toString) return a5.toString() === b3.toString();
      keys = Object.keys(a5);
      length2 = keys.length;
      if (length2 !== Object.keys(b3).length) return false;
      for (i6 = length2; i6-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b3, keys[i6])) return false;
      for (i6 = length2; i6-- !== 0; ) {
        var key2 = keys[i6];
        if (!equal(a5[key2], b3[key2])) return false;
      }
      return true;
    }
    return a5 !== a5 && b3 !== b3;
  };
  var isEqual = /* @__PURE__ */ getDefaultExportFromCjs(fastDeepEqual);
  var DEFAULT_ID = "__googleMapsScriptId";
  var LoaderStatus;
  (function(LoaderStatus2) {
    LoaderStatus2[LoaderStatus2["INITIALIZED"] = 0] = "INITIALIZED";
    LoaderStatus2[LoaderStatus2["LOADING"] = 1] = "LOADING";
    LoaderStatus2[LoaderStatus2["SUCCESS"] = 2] = "SUCCESS";
    LoaderStatus2[LoaderStatus2["FAILURE"] = 3] = "FAILURE";
  })(LoaderStatus || (LoaderStatus = {}));
  var Loader = class _Loader {
    /**
     * Creates an instance of Loader using [[LoaderOptions]]. No defaults are set
     * using this library, instead the defaults are set by the Google Maps
     * JavaScript API server.
     *
     * ```
     * const loader = Loader({apiKey, version: 'weekly', libraries: ['places']});
     * ```
     */
    constructor({ apiKey, authReferrerPolicy, channel, client, id = DEFAULT_ID, language, libraries = [], mapIds, nonce, region, retries = 3, url = "https://maps.googleapis.com/maps/api/js", version }) {
      this.callbacks = [];
      this.done = false;
      this.loading = false;
      this.errors = [];
      this.apiKey = apiKey;
      this.authReferrerPolicy = authReferrerPolicy;
      this.channel = channel;
      this.client = client;
      this.id = id || DEFAULT_ID;
      this.language = language;
      this.libraries = libraries;
      this.mapIds = mapIds;
      this.nonce = nonce;
      this.region = region;
      this.retries = retries;
      this.url = url;
      this.version = version;
      if (_Loader.instance) {
        if (!isEqual(this.options, _Loader.instance.options)) {
          throw new Error(`Loader must not be called again with different options. ${JSON.stringify(this.options)} !== ${JSON.stringify(_Loader.instance.options)}`);
        }
        return _Loader.instance;
      }
      _Loader.instance = this;
    }
    get options() {
      return {
        version: this.version,
        apiKey: this.apiKey,
        channel: this.channel,
        client: this.client,
        id: this.id,
        libraries: this.libraries,
        language: this.language,
        region: this.region,
        mapIds: this.mapIds,
        nonce: this.nonce,
        url: this.url,
        authReferrerPolicy: this.authReferrerPolicy
      };
    }
    get status() {
      if (this.errors.length) {
        return LoaderStatus.FAILURE;
      }
      if (this.done) {
        return LoaderStatus.SUCCESS;
      }
      if (this.loading) {
        return LoaderStatus.LOADING;
      }
      return LoaderStatus.INITIALIZED;
    }
    get failed() {
      return this.done && !this.loading && this.errors.length >= this.retries + 1;
    }
    /**
     * CreateUrl returns the Google Maps JavaScript API script url given the [[LoaderOptions]].
     *
     * @ignore
     * @deprecated
     */
    createUrl() {
      let url = this.url;
      url += `?callback=__googleMapsCallback&loading=async`;
      if (this.apiKey) {
        url += `&key=${this.apiKey}`;
      }
      if (this.channel) {
        url += `&channel=${this.channel}`;
      }
      if (this.client) {
        url += `&client=${this.client}`;
      }
      if (this.libraries.length > 0) {
        url += `&libraries=${this.libraries.join(",")}`;
      }
      if (this.language) {
        url += `&language=${this.language}`;
      }
      if (this.region) {
        url += `&region=${this.region}`;
      }
      if (this.version) {
        url += `&v=${this.version}`;
      }
      if (this.mapIds) {
        url += `&map_ids=${this.mapIds.join(",")}`;
      }
      if (this.authReferrerPolicy) {
        url += `&auth_referrer_policy=${this.authReferrerPolicy}`;
      }
      return url;
    }
    deleteScript() {
      const script = document.getElementById(this.id);
      if (script) {
        script.remove();
      }
    }
    /**
     * Load the Google Maps JavaScript API script and return a Promise.
     * @deprecated, use importLibrary() instead.
     */
    load() {
      return this.loadPromise();
    }
    /**
     * Load the Google Maps JavaScript API script and return a Promise.
     *
     * @ignore
     * @deprecated, use importLibrary() instead.
     */
    loadPromise() {
      return new Promise((resolve, reject) => {
        this.loadCallback((err) => {
          if (!err) {
            resolve(window.google);
          } else {
            reject(err.error);
          }
        });
      });
    }
    importLibrary(name2) {
      this.execute();
      return google.maps.importLibrary(name2);
    }
    /**
     * Load the Google Maps JavaScript API script with a callback.
     * @deprecated, use importLibrary() instead.
     */
    loadCallback(fn) {
      this.callbacks.push(fn);
      this.execute();
    }
    /**
     * Set the script on document.
     */
    setScript() {
      var _a, _b;
      if (document.getElementById(this.id)) {
        this.callback();
        return;
      }
      const params = {
        key: this.apiKey,
        channel: this.channel,
        client: this.client,
        libraries: this.libraries.length && this.libraries,
        v: this.version,
        mapIds: this.mapIds,
        language: this.language,
        region: this.region,
        authReferrerPolicy: this.authReferrerPolicy
      };
      Object.keys(params).forEach(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (key2) => !params[key2] && delete params[key2]
      );
      if (!((_b = (_a = window === null || window === void 0 ? void 0 : window.google) === null || _a === void 0 ? void 0 : _a.maps) === null || _b === void 0 ? void 0 : _b.importLibrary)) {
        ((g3) => {
          let h2, a5, k3, p3 = "The Google Maps JavaScript API", c4 = "google", l6 = "importLibrary", q3 = "__ib__", m3 = document, b3 = window;
          b3 = b3[c4] || (b3[c4] = {});
          const d3 = b3.maps || (b3.maps = {}), r6 = /* @__PURE__ */ new Set(), e5 = new URLSearchParams(), u3 = () => (
            // @ts-ignore
            h2 || (h2 = new Promise((f3, n6) => __awaiter(this, void 0, void 0, function* () {
              var _a2;
              yield a5 = m3.createElement("script");
              a5.id = this.id;
              e5.set("libraries", [...r6] + "");
              for (k3 in g3)
                e5.set(k3.replace(/[A-Z]/g, (t4) => "_" + t4[0].toLowerCase()), g3[k3]);
              e5.set("callback", c4 + ".maps." + q3);
              a5.src = this.url + `?` + e5;
              d3[q3] = f3;
              a5.onerror = () => h2 = n6(Error(p3 + " could not load."));
              a5.nonce = this.nonce || ((_a2 = m3.querySelector("script[nonce]")) === null || _a2 === void 0 ? void 0 : _a2.nonce) || "";
              m3.head.append(a5);
            })))
          );
          d3[l6] ? console.warn(p3 + " only loads once. Ignoring:", g3) : d3[l6] = (f3, ...n6) => r6.add(f3) && u3().then(() => d3[l6](f3, ...n6));
        })(params);
      }
      const libraryPromises = this.libraries.map((library) => this.importLibrary(library));
      if (!libraryPromises.length) {
        libraryPromises.push(this.importLibrary("core"));
      }
      Promise.all(libraryPromises).then(() => this.callback(), (error) => {
        const event2 = new ErrorEvent("error", { error });
        this.loadErrorCallback(event2);
      });
    }
    /**
     * Reset the loader state.
     */
    reset() {
      this.deleteScript();
      this.done = false;
      this.loading = false;
      this.errors = [];
      this.onerrorEvent = null;
    }
    resetIfRetryingFailed() {
      if (this.failed) {
        this.reset();
      }
    }
    loadErrorCallback(e5) {
      this.errors.push(e5);
      if (this.errors.length <= this.retries) {
        const delay3 = this.errors.length * Math.pow(2, this.errors.length);
        console.error(`Failed to load Google Maps script, retrying in ${delay3} ms.`);
        setTimeout(() => {
          this.deleteScript();
          this.setScript();
        }, delay3);
      } else {
        this.onerrorEvent = e5;
        this.callback();
      }
    }
    callback() {
      this.done = true;
      this.loading = false;
      this.callbacks.forEach((cb) => {
        cb(this.onerrorEvent);
      });
      this.callbacks = [];
    }
    execute() {
      this.resetIfRetryingFailed();
      if (this.loading) {
        return;
      }
      if (this.done) {
        this.callback();
      } else {
        if (window.google && window.google.maps && window.google.maps.version) {
          console.warn("Google Maps already loaded outside @googlemaps/js-api-loader. This may result in undesirable behavior as options and script parameters may not match.");
          this.callback();
          return;
        }
        this.loading = true;
        this.setScript();
      }
    }
  };

  // assets/scripts/modules/Map.js
  var _GMap = class _GMap extends _default {
    constructor(m3) {
      super(m3);
      this.$el = this.el;
      this.$container = this.$("container")[0];
      this.$accordions = Array.from(this.$("accordion"));
      this.$panel = this.$("panel")[0];
      this.$markers = [];
      this.fetchUrl = this.getData("fetch-url") || null;
      this.apiKey = this.getData("api-key") || null;
      this.locations = [];
      this.activeLocation = this.createEmptyLocation();
      this.hasLocationActive = false;
      this.offsetX = 0;
      this.zoom = this.calculateZoom();
      this.handleResize = this.handleResize.bind(this);
      this.handleAccordionClick = this.handleAccordionClick.bind(this);
    }
    ///////////////
    // Lifecycle
    ///////////////
    init() {
      if (!this.apiKey) return;
      this.initMap();
      this.bindEvents();
      this.updateOffset();
    }
    destroy() {
      super.destroy();
      this.unbindEvents();
      this.map = null;
    }
    ///////////////
    // Events
    ///////////////
    bindEvents() {
      this.unbindScreenListener = $screenDebounce.listen(this.handleResize);
      this.$accordions.forEach(($el) => $el.addEventListener("click", this.handleAccordionClick));
    }
    unbindEvents() {
      var _a;
      (_a = this.unbindScreenListener) == null ? void 0 : _a.call(this);
      this.$accordions.forEach(($el) => $el.removeEventListener("click", this.handleAccordionClick));
    }
    ///////////////
    // Map Initialization
    ///////////////
    initMap() {
      return __async(this, null, function* () {
        const loader = new Loader({ apiKey: this.apiKey, version: "weekly" });
        try {
          yield loader.load();
          const { Map: Map2 } = yield google.maps.importLibrary("maps");
          const { AdvancedMarkerElement } = yield google.maps.importLibrary("marker");
          const options = {
            mapId: _GMap.SETTINGS.mapId,
            disableDefaultUI: true,
            scrollwheel: false,
            zoom: this.zoom.initial,
            center: _GMap.SETTINGS.center
          };
          this.map = new Map2(this.$container, options);
          setTimeout(() => {
            this.map.setCenter(this.offsetCenter(_GMap.SETTINGS.center, this.zoom.initial, this.offsetX));
          }, 5);
          const data2 = yield this.fetchLocations();
          this.locations = data2;
          for (const location2 of this.locations.items) {
            const [lat, lng] = location2.coordinates.map(parseFloat);
            if (!lat || !lng) {
              console.warn(`Invalid coordinates for location ${location2.name}`);
              continue;
            }
            const markerEl = document.createElement("div");
            markerEl.dataset.locationId = location2.id;
            markerEl.classList.add("c-map_marker");
            this.$markers.push(markerEl);
            const marker = new AdvancedMarkerElement({
              map: this.map,
              position: { lat, lng },
              content: markerEl
            });
            marker.addListener("click", () => {
              const id = location2.id;
              const accordionEl = this.$accordions.find(($el) => $el.dataset.locationId === id);
              const accordionModuleID = accordionEl == null ? void 0 : accordionEl.dataset.moduleAccordion;
              const selected = { id, latLng: { lat, lng }, $markerEl: markerEl, accordionModuleID };
              if (this.activeLocation.id === id) {
                this.deactivateLocation(selected, true);
                this.call("shrink", null, "Accordion", accordionModuleID);
              } else {
                this.activateLocation(selected);
                this.call("open", null, "Accordion", accordionModuleID);
              }
            });
          }
        } catch (e5) {
          console.error("Google Maps failed to load:", e5);
        }
      });
    }
    ///////////////
    // Data Fetching
    ///////////////
    fetchLocations() {
      return __async(this, null, function* () {
        try {
          const response = yield fetch(`${window.location.origin}${this.fetchUrl}`);
          if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
          return yield response.json();
        } catch (error) {
          console.error("Error fetching office locations:", error);
          return [];
        }
      });
    }
    ///////////////
    // Callbacks
    ///////////////
    handleAccordionClick(e5) {
      const $el = e5.currentTarget;
      const id = $el.dataset.locationId;
      const accordionModuleID = $el.dataset.moduleAccordion;
      const location2 = this.locations.items.find((item) => item.id === id);
      const $markerEl = this.$markers.find((el) => el.dataset.locationId === id);
      if (!location2 || !$markerEl) return;
      const latLng = {
        lat: parseFloat(location2.coordinates[0]),
        lng: parseFloat(location2.coordinates[1])
      };
      const selected = { id, latLng, $markerEl, accordionModuleID };
      if (this.activeLocation.id === id) {
        this.deactivateLocation(selected, true);
      } else {
        this.activateLocation(selected);
      }
    }
    handleResize({ width: width2 }) {
      this.updateOffset();
      this.zoom = this.calculateZoom(width2);
      const zoom = this.hasLocationActive ? this.zoom.active : this.zoom.initial;
      const center = this.hasLocationActive ? this.activeLocation.latLng : _GMap.SETTINGS.center;
      if (this.map.getZoom() !== zoom) this.map.setZoom(zoom);
      this.map.panTo(this.offsetCenter(center, zoom, this.offsetX));
    }
    ///////////////
    // Map Logic
    ///////////////
    activateLocation(location2) {
      const { id, latLng, $markerEl, accordionModuleID } = location2;
      if (this.hasLocationActive) {
        this.deactivateLocation(this.activeLocation);
        this.call("shrink", null, "Accordion", this.activeLocation.accordionModuleID);
      }
      $markerEl == null ? void 0 : $markerEl.classList.add("is-active");
      if (this.map.getZoom() === this.zoom.initial) this.map.setZoom(this.zoom.active);
      this.map.panTo(this.offsetCenter(latLng, this.zoom.active, this.offsetX));
      this.activeLocation = location2;
      this.hasLocationActive = true;
    }
    deactivateLocation(location2, reset = false) {
      const { $markerEl } = location2;
      $markerEl == null ? void 0 : $markerEl.classList.remove("is-active");
      if (reset) {
        this.map.setZoom(this.zoom.initial);
        this.map.panTo(this.offsetCenter(_GMap.SETTINGS.center, this.zoom.initial, this.offsetX));
        this.activeLocation = this.createEmptyLocation();
        this.hasLocationActive = false;
      }
    }
    ///////////////
    // Utils
    ///////////////
    offsetCenter(latLng, zoom, offsetX = 0, offsetY = 0) {
      const scale2 = Math.pow(2, zoom);
      const worldPoint = this.map.getProjection().fromLatLngToPoint(latLng);
      const pixelOffset = new google.maps.Point(offsetX / scale2, offsetY / scale2);
      const newPoint = new google.maps.Point(
        worldPoint.x - pixelOffset.x,
        worldPoint.y + pixelOffset.y
      );
      return this.map.getProjection().fromPointToLatLng(newPoint);
    }
    updateOffset() {
      this.offsetX = window.innerWidth > BREAKPOINTS.FROM_SM ? this.$panel.offsetWidth / 2 || 0 : 0;
    }
    calculateZoom(width2 = window.innerWidth) {
      const base = width2 > BREAKPOINTS.FROM_SM ? _GMap.SETTINGS.zoom.desktop : _GMap.SETTINGS.zoom.mobile;
      return { initial: base, active: base + 1 };
    }
    createEmptyLocation() {
      return { id: null, latLng: {}, $markerEl: null, accordionModuleID: null };
    }
  };
  // Static config
  __publicField(_GMap, "SETTINGS", {
    mapId: "f59becc718d694cb",
    center: { lat: 38, lng: -95 },
    zoom: { desktop: 4, mobile: 3 }
  });
  var GMap = _GMap;

  // assets/scripts/modules/Menu.js
  var _Menu = class _Menu extends _default {
    constructor(m3) {
      super(m3);
      this.onActivate = this.onActivate.bind(this);
      this.onPostActivate = this.onPostActivate.bind(this);
      this.onDeactivate = this.onDeactivate.bind(this);
      this.onPostDeactivate = this.onPostDeactivate.bind(this);
      this.onMenuOpenChange = this.onMenuOpenChange.bind(this);
      this.onOpen = this.onOpen.bind(this);
      this.onClose = this.onClose.bind(this);
      this.$close = this.$("close")[0];
      this.$container = this.$("container")[0];
      this.$head = this.$("head")[0];
      this.focusTrap = createFocusTrap([this.$head, this.$container, ".c-header.-is-fixed"], {
        onActivate: this.onActivate,
        onPostActivate: this.onPostActivate,
        onDeactivate: this.onDeactivate,
        onPostDeactivate: this.onPostDeactivate,
        clickOutsideDeactivates: true
      });
    }
    // =============================================================================
    // Lifecycle
    // =============================================================================
    init() {
      this.bindEvents();
    }
    destroy() {
      super.destroy();
      this.unbindEvents();
    }
    // =============================================================================
    // Events
    // =============================================================================
    bindEvents() {
      var _a;
      this.unbindMenuOpenListener = $hasMenuOpen.listen(this.onMenuOpenChange);
      (_a = this.$close) == null ? void 0 : _a.addEventListener("click", this.onClose);
      this.openEvent = delegateEvent(document.body, "click", _Menu.SELECTOR, this.onOpen);
    }
    unbindEvents() {
      var _a, _b, _c, _d;
      (_a = this.unbindMenuOpenListener) == null ? void 0 : _a.call(this);
      (_b = this.$close) == null ? void 0 : _b.removeEventListener("click", this.onClose);
      (_d = (_c = this.openEvent).abort) == null ? void 0 : _d.call(_c);
    }
    // =============================================================================
    // Callbacks
    // =============================================================================
    onActivate() {
      this.el.setAttribute("aria-hidden", false);
    }
    onPostActivate() {
      var _a;
      (_a = this.$triggerCta) == null ? void 0 : _a.setAttribute("aria-expanded", true);
    }
    onDeactivate() {
      $hasMenuOpen.set(false);
      this.el.setAttribute("aria-hidden", true);
    }
    onPostDeactivate() {
      var _a;
      (_a = this.$triggerCta) == null ? void 0 : _a.setAttribute("aria-expanded", false);
    }
    onMenuOpenChange(hasMenuOpen) {
      if (hasMenuOpen) {
        document.documentElement.classList.add(_Menu.ACTIVE_CLASS);
      } else {
        document.documentElement.classList.remove(_Menu.ACTIVE_CLASS);
      }
    }
    onOpen(e5) {
      this.$triggerCta = e5 == null ? void 0 : e5.target;
      this.open();
    }
    onClose() {
      this.close();
    }
    // =============================================================================
    // Methods
    // =============================================================================
    open() {
      var _a;
      if ($hasMenuOpen.get()) return;
      (_a = this.$container) == null ? void 0 : _a.scrollTo(0, 0);
      $hasMenuOpen.set(true);
      requestAnimationFrame(() => {
        var _a2, _b;
        (_b = (_a2 = this.focusTrap) == null ? void 0 : _a2.activate) == null ? void 0 : _b.call(_a2);
      });
    }
    close() {
      var _a, _b;
      if (!$hasMenuOpen.get()) return;
      this.$triggerCta = null;
      (_b = (_a = this.focusTrap) == null ? void 0 : _a.deactivate) == null ? void 0 : _b.call(_a);
    }
  };
  __publicField(_Menu, "ACTIVE_CLASS", "has-menu-open");
  __publicField(_Menu, "SELECTOR", "[data-menu-open]");
  var Menu = _Menu;

  // assets/scripts/modules/NavSelect.js
  var NavSelect = class extends _default {
    constructor(m3) {
      super(m3);
      // =============================================================================
      // Callbacks
      // =============================================================================
      __publicField(this, "onChange", (e5) => {
        this.call("goTo", e5.target.value, "Load");
      });
      this.$select = this.$("select")[0];
    }
    // =============================================================================
    // Lifecycle
    // =============================================================================
    init() {
      this.bindEvents();
    }
    destroy() {
      super.destroy();
      this.unbindEvents();
    }
    // =============================================================================
    // Events
    // =============================================================================
    bindEvents() {
      this.$select.addEventListener("change", this.onChange);
    }
    unbindEvents() {
      this.$select.removeEventListener("change", this.onChange);
    }
  };

  // assets/scripts/modules/Player.js
  var _Player = class _Player extends _default {
    constructor(m3) {
      super(m3);
      this.onTogglePlay = this.onTogglePlay.bind(this);
      this.onToggleSound = this.onToggleSound.bind(this);
      this.onVideoEnded = this.onVideoEnded.bind(this);
      this.onVideoClick = this.onVideoClick.bind(this);
      this.onTimelineInput = this.onTimelineInput.bind(this);
      this.onTimelineChange = this.onTimelineChange.bind(this);
      this.updateRaf = this.updateRaf.bind(this);
      this.onPlayerOpenChange = this.onPlayerOpenChange.bind(this);
      this.onOpen = this.onOpen.bind(this);
      this.onClose = this.onClose.bind(this);
      this.onActivate = this.onActivate.bind(this);
      this.onPostActivate = this.onPostActivate.bind(this);
      this.onDeactivate = this.onDeactivate.bind(this);
      this.onPostDeactivate = this.onPostDeactivate.bind(this);
      this.$video = this.$("video")[0];
      this.$toggle = this.$("toggle")[0];
      this.$sound = this.$("sound")[0];
      this.$input = this.$("input")[0];
      this.$close = this.$("close")[0];
      this.isMuted = false;
      this.isPlaying = false;
      this.playerId = this.el.dataset.playerId;
      this.progress = {
        default: 0,
        smooth: 0
      };
      this.lerp = 1;
      this.isRafPlaying = false;
      this.rafIncrement = 0;
      this.focusTrap = createFocusTrap(this.el, {
        onActivate: this.onActivate,
        onPostActivate: this.onPostActivate,
        onDeactivate: this.onDeactivate,
        onPostDeactivate: this.onPostDeactivate,
        clickOutsideDeactivates: true
      });
    }
    // //////////
    // Lifecycle
    // //////////
    init() {
      this.bindEvents();
      if (window.matchMedia(`(hover: none)`).matches) {
        this.$video.setAttribute("controls", "controls");
      }
    }
    destroy() {
      this.unbindEvents();
      super.destroy();
    }
    // //////////
    // Events
    // //////////
    bindEvents() {
      var _a;
      this.unbindOpenEvent = delegateEvent(document.body, "click", _Player.SELECTOR, this.onOpen);
      this.unbindPlayerOpenListener = $hasPlayerOpen.listen(this.onPlayerOpenChange);
      (_a = this.$close) == null ? void 0 : _a.addEventListener("click", this.onClose);
      if (window.matchMedia(`(hover: hover)`).matches) {
        this.$toggle.addEventListener("click", this.onTogglePlay);
        this.$sound.addEventListener("click", this.onToggleSound);
        this.$video.addEventListener("click", this.onVideoClick);
        this.$video.addEventListener("ended", this.onVideoEnded);
        this.$input.addEventListener("input", this.onTimelineInput);
        this.$input.addEventListener("change", this.onTimelineChange);
      }
    }
    unbindEvents() {
      var _a, _b, _c, _d;
      (_b = (_a = this.unbindOpenEvent).abort) == null ? void 0 : _b.call(_a);
      (_c = this.unbindPlayerOpenListener) == null ? void 0 : _c.call(this);
      (_d = this.$close) == null ? void 0 : _d.addEventListener("click", this.onClose);
      if (window.matchMedia(`(hover: hover)`).matches) {
        this.$toggle.removeEventListener("click", this.onTogglePlay);
        this.$sound.removeEventListener("click", this.onToggleSound);
        this.$video.removeEventListener("click", this.onVideoClick);
        this.$video.removeEventListener("ended", this.onVideoEnded);
        this.$input.removeEventListener("input", this.onTimelineInput);
        this.$input.removeEventListener("change", this.onTimelineChange);
      }
    }
    // //////////
    // Callbacks
    // //////////
    onTimelineInput(e5) {
      this.$video.pause();
      this.lerp = _Player.LERP;
      const { value: value2 } = e5.target;
      this.$video.currentTime = this.$video.duration * parseFloat(value2);
      this.updateProgress();
      this.playRaf();
    }
    onTimelineChange(e5) {
      this.isPlaying && this.$video.play();
    }
    onTogglePlay(e5) {
      if (this.$video.paused || this.$video.ended) {
        this.play();
      } else {
        this.pause();
      }
    }
    onToggleSound() {
      this.isMuted ? this.playAudio() : this.muteAudio();
      this.isMuted = !this.isMuted;
    }
    onVideoEnded() {
      this.reset();
    }
    onVideoClick() {
      this.$toggle.click();
      this.$toggle.focus();
    }
    onActivate() {
      this.el.setAttribute("aria-hidden", false);
    }
    onPostActivate() {
      var _a;
      (_a = this.$triggerCta) == null ? void 0 : _a.setAttribute("aria-expanded", true);
      this.play();
    }
    onDeactivate() {
      this.el.classList.remove(_Player.CLASS.ACTIVE);
      document.documentElement.classList.remove(_Player.CLASS.GLOBAL_ACTIVE);
      $hasPlayerOpen.set({
        state: false,
        id: null
      });
      this.el.setAttribute("aria-hidden", true);
      this.pause();
    }
    onPostDeactivate() {
      var _a;
      (_a = this.$triggerCta) == null ? void 0 : _a.setAttribute("aria-expanded", false);
    }
    onPlayerOpenChange(hasPlayerOpen) {
      if (hasPlayerOpen.state && hasPlayerOpen.id === this.playerId) {
        this.el.classList.add(_Player.CLASS.ACTIVE);
        document.documentElement.classList.add(_Player.CLASS.GLOBAL_ACTIVE);
        requestAnimationFrame(() => {
          var _a, _b;
          (_b = (_a = this.focusTrap) == null ? void 0 : _a.activate) == null ? void 0 : _b.call(_a);
        });
      }
    }
    onOpen(e5) {
      var _a, _b;
      this.$triggerCta = e5 == null ? void 0 : e5.target;
      const playerId = (_b = (_a = this.$triggerCta) == null ? void 0 : _a.dataset) == null ? void 0 : _b.playerId;
      this.open(playerId);
    }
    onClose() {
      this.close();
    }
    // //////////
    // Methods
    // //////////
    play() {
      this.$video.play();
      !this.isMuted && this.playAudio();
      this.el.classList.add(_Player.CLASS.PLAYING);
      this.isPlaying = true;
      this.playRaf();
    }
    pause() {
      this.$video.pause();
      this.el.classList.remove(_Player.CLASS.PLAYING);
      this.isPlaying = false;
    }
    playAudio() {
      this.el.classList.remove(_Player.CLASS.MUTED);
      this.unMute(this.$video);
    }
    muteAudio() {
      this.el.classList.add(_Player.CLASS.MUTED);
      this.mute(this.$video, null);
    }
    updateRaf() {
      this.updateProgress();
      this.progress.smooth += (this.progress.default - this.progress.smooth) * this.lerp;
      this.updateTimeline();
      if (this.lerp != 1 && roundNumber(this.progress.smooth, 3) == roundNumber(this.progress.default, 3)) {
        this.lerp = 1;
      }
      if (!this.isPlaying && roundNumber(this.progress.smooth, 3) == roundNumber(this.progress.default, 3)) {
        this.rafIncrement++;
        if (this.rafIncrement >= 30) {
          this.pauseRaf();
        }
      }
    }
    reset() {
      this.el.classList.remove(_Player.CLASS.PLAYING);
      this.isPlaying = false;
      this.progress.default = 0;
      this.progress.smooth = 0;
      this.$input.value = 0;
      this.$video.currentTime = 0;
    }
    updateProgress() {
      if (this.$video.duration != null && this.$video.duration > 0) {
        this.progress.default = this.$video.currentTime / this.$video.duration;
      } else {
        this.progress.default = 0;
      }
      this.$input.value = this.progress.default;
    }
    updateTimeline() {
      this.el.style.setProperty("--progress", this.progress.smooth);
    }
    // RAF
    ///////////////
    playRaf() {
      if (this.isRafPlaying) return;
      this.isRafPlaying = true;
      this.rafIncrement = 0;
      gsapWithCSS.ticker.add(this.updateRaf);
    }
    pauseRaf() {
      if (!this.isRafPlaying) return;
      this.isRafPlaying = false;
      gsapWithCSS.ticker.remove(this.updateRaf);
    }
    // Audio
    ///////////////
    unMute(media, fromStart = false, autoplay = false, callback = null) {
      if (this.interval) clearInterval(this.interval);
      if (fromStart) media.currentTime = 0;
      if (autoplay) media.play();
      let volume = 0;
      media.muted = false;
      media.volume = 0;
      this.interval = setInterval(() => {
        if (volume < 1) {
          volume += 0.05;
          media.volume = clamp4(0, 1, volume).toFixed(2);
        } else {
          clearInterval(this.interval);
          callback == null ? void 0 : callback();
        }
      }, 50);
    }
    /**
     * Progressive mute media.
     *
     * @param {HTMLMediaElement} media - The media element to play.
     * @return {void}
     */
    mute(media, callback = null) {
      if (this.interval) clearInterval(this.interval);
      let volume = media.volume || 1;
      this.interval = setInterval(() => {
        if (volume > 0) {
          volume -= 0.05;
          media.volume = clamp4(0, 1, volume).toFixed(2);
        } else {
          clearInterval(this.interval);
          media.muted = true;
          callback == null ? void 0 : callback();
        }
      }, 50);
    }
    open(playerId) {
      if ($hasPlayerOpen.value.state) return;
      $hasPlayerOpen.set({
        state: true,
        id: playerId
      });
    }
    close() {
      var _a, _b;
      if (!$hasPlayerOpen.value.state) return;
      this.$triggerCta = null;
      (_b = (_a = this.focusTrap) == null ? void 0 : _a.deactivate) == null ? void 0 : _b.call(_a);
    }
  };
  __publicField(_Player, "CLASS", {
    PLAYING: "is-playing",
    MUTED: "is-muted",
    ACTIVE: "is-active",
    GLOBAL_ACTIVE: "has-player-open"
  });
  __publicField(_Player, "SELECTOR", "[data-player-open]");
  __publicField(_Player, "LERP", 0.1);
  var Player = _Player;

  // assets/scripts/modules/PlayerCta.js
  var PlayerCta_default = class extends _default {
    constructor(m3) {
      super(m3);
      this.onResize = this.onResize.bind(this);
      this.$area = this.$("area")[0];
      this.$wrapper = this.$("wrapper")[0];
      this.diffWidth = 0;
      this.diffHeight = 0;
      this.ratioWidth = 0;
      this.progress = 0;
    }
    // =============================================================================
    // Lifecycle
    // =============================================================================
    init() {
      this.setMetrics();
      this.bindEvents();
    }
    destroy() {
      super.destroy();
      this.unbindEvents();
    }
    // =============================================================================
    // Events
    // =============================================================================
    bindEvents() {
      this.unbindScreenListener = $screenDebounce.subscribe(this.onResize);
    }
    unbindEvents() {
      var _a;
      (_a = this.unbindScreenListener) == null ? void 0 : _a.call(this);
    }
    // =============================================================================
    // Callbacks
    // =============================================================================
    onResize({ width: width2, height: height2 }) {
      this.setMetrics();
    }
    // =============================================================================
    // Methods
    // =============================================================================
    setMetrics() {
      const areaWidth = this.$area.offsetWidth;
      const areaHeight = this.$area.offsetHeight;
      const wrapperWidth = this.$wrapper.offsetWidth;
      const wrapperHeight = this.$wrapper.offsetHeight;
      this.diffWidth = wrapperWidth - areaWidth;
      this.diffHeight = wrapperHeight - areaHeight;
      this.ratioWidth = areaWidth / wrapperWidth;
      this.setStyles();
    }
    setStyles() {
      requestAnimationFrame(() => {
        this.el.style.setProperty("--ratio", this.ratioWidth);
        this.el.style.setProperty("--diff-width", `${this.diffWidth}px`);
        this.el.style.setProperty("--diff-height", `${this.diffHeight}px`);
      });
    }
  };

  // assets/scripts/modules/Process.js
  var import_lottie_web = __toESM(require_lottie(), 1);
  var Process = class extends _default {
    constructor(m3) {
      super(m3);
      this.$lottieContainer = this.$("lottieContainer")[0];
      this.lottiePath = this.getData("path");
      this.lottieAnim = null;
      this.$items = this.$("item");
      this.$sticky = this.$("sticky");
      this.currentStep = -1;
      this.totalSteps = this.$items.length;
      this.lottieTotalFrames = 0;
      this.currentFrame = -1;
      this.stepsRange = [
        {
          in: 0,
          out: 160
        },
        {
          in: 161,
          out: 280
        },
        {
          in: 281,
          out: 369
        },
        {
          in: 370,
          out: 480
        }
      ];
    }
    // =============================================================================
    // Lifecycle
    // =============================================================================
    init() {
      if (this.lottiePath) {
        this.loadLottie().then(() => {
          this.lottieTotalFrames = this.lottieAnim.totalFrames;
        });
      }
    }
    destroy() {
    }
    ///////////////
    // Callbacks
    ///////////////
    onScrollProgress(progress) {
      const currentFrame = Math.round(
        gsapWithCSS.utils.mapRange(0, 1, 0, this.lottieTotalFrames, progress)
      );
      if (currentFrame != this.currentFrame) {
        this.lottieAnim.goToAndStop(currentFrame, true);
        this.computeCurrentStep(currentFrame);
        this.currentFrame = currentFrame;
      }
    }
    ///////////////
    // Methods
    ///////////////
    loadLottie() {
      return new Promise((resolve) => {
        this.lottieAnim = import_lottie_web.default.loadAnimation({
          path: this.lottiePath,
          container: this.$lottieContainer,
          renderer: "svg",
          loop: false,
          autoplay: false,
          rendererSettings: {
            preserveAspectRatio: "xMidYMid slice"
          }
        });
        this.lottieAnim.addEventListener("DOMLoaded", resolve);
      });
    }
    computeCurrentStep(currentFrame) {
      this.stepsRange.forEach((step, index2) => {
        if (currentFrame >= step.in && currentFrame <= step.out && !this.$items[index2].classList.contains("is-active")) {
          this.$items[index2].classList.add("is-active");
        } else if ((currentFrame < step.in || currentFrame > step.out) && this.$items[index2].classList.contains("is-active")) {
          if (index2 == this.totalSteps - 1 && currentFrame > step.out) return;
          this.$items[index2].classList.remove("is-active");
        }
        if (currentFrame >= step.out && !this.$items[index2].classList.contains("is-past")) {
          if (index2 == this.totalSteps - 1) return;
          this.$items[index2].classList.add("is-past");
        } else if (currentFrame < step.out && this.$items[index2].classList.contains("is-past")) {
          this.$items[index2].classList.remove("is-past");
        }
      });
    }
  };
  __publicField(Process, "CLASS", {
    IS_ACTIVE: "is-active"
  });

  // assets/scripts/modules/ProjectAnchors.js
  var _ProjectAnchors = class _ProjectAnchors extends _default {
    constructor(m3) {
      super(m3);
      this.$links = this.$("link");
    }
    /* Lifecycle */
    init() {
    }
    destroy() {
      super.destroy();
    }
    onUpdateIndicator(e5) {
      const { target, way } = e5;
      if (way === "enter") {
        this.$links.forEach((link) => {
          const href = link.getAttribute("href");
          if (href === `#${target.id}`) {
            link.classList.add("is-active");
          } else {
            link.classList.remove("is-active");
          }
        });
      } else if (way === "leave") {
        this.$links.forEach((link) => {
          const href = link.getAttribute("href");
          if (href === `#${target.id}`) {
            link.classList.remove("is-active");
          }
        });
      }
    }
    // =============================================================================
    // Callbacks
    // =============================================================================
    onInview(e5) {
      document.documentElement.classList.toggle(_ProjectAnchors.INVIEW_CLASS, e5.way == "enter");
    }
  };
  __publicField(_ProjectAnchors, "INVIEW_CLASS", "has-project-anchors-inview");
  var ProjectAnchors = _ProjectAnchors;

  // assets/scripts/modules/SectorAnchors.js
  var _SectorAnchors = class _SectorAnchors extends _default {
    constructor(m3) {
      super(m3);
      this.onResize = this.onResize.bind(this);
      this.$links = this.$("link");
      this.$list = this.$("list")[0];
      this.$threshold = this.$("threshold")[0];
    }
    // =============================================================================
    // Lifecycle
    // =============================================================================
    init() {
      this.bindEvents();
    }
    destroy() {
      super.destroy();
      this.unbindEvents();
    }
    // =============================================================================
    // Events
    // =============================================================================
    bindEvents() {
      this.unbindScreenListener = $screenDebounce.subscribe(this.onResize);
    }
    unbindEvents() {
      var _a;
      (_a = this.unbindScreenListener) == null ? void 0 : _a.call(this);
    }
    // =============================================================================
    // Callbacks
    // =============================================================================
    onUpdateIndicator(e5) {
      const { target, way } = e5;
      if (way === "enter") {
        this.$links.forEach(($link) => {
          const href = $link.getAttribute("href");
          if (href === `#${target.id}`) {
            $link.classList.add("is-active");
            this.scrollToBar($link);
          } else {
            $link.classList.remove("is-active");
          }
        });
      } else if (way === "leave") {
        this.$links.forEach(($link) => {
          const href = $link.getAttribute("href");
          if (href === `#${target.id}`) {
            $link.classList.remove("is-active");
          }
        });
      }
    }
    onInview(e5) {
      document.documentElement.classList.toggle(_SectorAnchors.INVIEW_CLASS, e5.way == "enter");
    }
    onResize() {
      this.setThresholdHeight();
    }
    // =============================================================================
    // Methods
    // =============================================================================
    scrollToBar($target) {
      const offsetLeft = $target.offsetLeft;
      this.$list.scrollTo({
        left: offsetLeft,
        behavior: "smooth"
      });
    }
    setThresholdHeight() {
      this.el.style.setProperty("--threshold-height", `${this.$threshold.offsetHeight}px`);
    }
  };
  __publicField(_SectorAnchors, "INVIEW_CLASS", "has-sector-anchors-inview");
  var SectorAnchors = _SectorAnchors;

  // assets/scripts/utils/image.js
  var getImageMetadata = ($img) => ({
    url: $img.src,
    width: $img.naturalWidth,
    height: $img.naturalHeight,
    ratio: $img.naturalWidth / $img.naturalHeight
  });
  var loadImage = (url, options = {}) => {
    return new Promise((resolve, reject) => {
      const $img = new Image();
      if (options.crossOrigin) {
        $img.crossOrigin = options.crossOrigin;
      }
      const loadCallback = () => {
        resolve(__spreadValues({
          element: $img
        }, getImageMetadata($img)));
      };
      if ($img.decode) {
        $img.src = url;
        $img.decode().then(loadCallback).catch((e5) => {
          reject(e5);
        });
      } else {
        $img.onload = loadCallback;
        $img.onerror = (e5) => {
          reject(e5);
        };
        $img.src = url;
      }
    });
  };
  var LAZY_LOADED_IMAGES = [];
  var lazyLoadImage = ($el, url, callback) => __async(void 0, null, function* () {
    let src = url ? url : $el.dataset.src;
    let loadedImage = LAZY_LOADED_IMAGES.find((image) => image.url === src);
    if (!loadedImage) {
      loadedImage = yield loadImage(src);
      if (!loadedImage.url) {
        return;
      }
      LAZY_LOADED_IMAGES.push(loadedImage);
    }
    if ($el.src === src) {
      return;
    }
    if ($el.tagName === "IMG") {
      $el.src = loadedImage.url;
    } else {
      $el.style.backgroundImage = `url(${loadedImage.url})`;
    }
    requestAnimationFrame(() => {
      let lazyParent = $el.closest(`.${CSS_CLASS.LAZY_CONTAINER}`);
      if (lazyParent) {
        lazyParent.classList.add(CSS_CLASS.LAZY_LOADED);
        lazyParent.style.backgroundImage = "";
      }
      $el.classList.add(CSS_CLASS.LAZY_LOADED);
      callback == null ? void 0 : callback();
    });
  });

  // node_modules/lenis/dist/lenis.mjs
  function clamp5(t4, i6, e5) {
    return Math.max(t4, Math.min(i6, e5));
  }
  var Animate = class {
    constructor() {
      this.isRunning = false, this.value = 0, this.from = 0, this.to = 0, this.duration = 0, this.currentTime = 0;
    }
    advance(t4) {
      var i6;
      if (!this.isRunning) return;
      let e5 = false;
      if (this.duration && this.easing) {
        this.currentTime += t4;
        const i7 = clamp5(0, this.currentTime / this.duration, 1);
        e5 = i7 >= 1;
        const s4 = e5 ? 1 : this.easing(i7);
        this.value = this.from + (this.to - this.from) * s4;
      } else this.lerp ? (this.value = function damp(t5, i7, e6, s4) {
        return function lerp2(t6, i8, e7) {
          return (1 - e7) * t6 + e7 * i8;
        }(t5, i7, 1 - Math.exp(-e6 * s4));
      }(this.value, this.to, 60 * this.lerp, t4), Math.round(this.value) === this.to && (this.value = this.to, e5 = true)) : (this.value = this.to, e5 = true);
      e5 && this.stop(), null === (i6 = this.onUpdate) || void 0 === i6 || i6.call(this, this.value, e5);
    }
    stop() {
      this.isRunning = false;
    }
    fromTo(t4, i6, { lerp: e5, duration: s4, easing: o5, onStart: n6, onUpdate: l6 }) {
      this.from = this.value = t4, this.to = i6, this.lerp = e5, this.duration = s4, this.easing = o5, this.currentTime = 0, this.isRunning = true, null == n6 || n6(), this.onUpdate = l6;
    }
  };
  var Dimensions = class {
    constructor({ wrapper: t4, content: i6, autoResize: e5 = true, debounce: s4 = 250 } = {}) {
      this.width = 0, this.height = 0, this.scrollWidth = 0, this.scrollHeight = 0, this.resize = () => {
        this.onWrapperResize(), this.onContentResize();
      }, this.onWrapperResize = () => {
        this.wrapper === window ? (this.width = window.innerWidth, this.height = window.innerHeight) : this.wrapper instanceof HTMLElement && (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight);
      }, this.onContentResize = () => {
        this.wrapper === window ? (this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth) : this.wrapper instanceof HTMLElement && (this.scrollHeight = this.wrapper.scrollHeight, this.scrollWidth = this.wrapper.scrollWidth);
      }, this.wrapper = t4, this.content = i6, e5 && (this.debouncedResize = /* @__PURE__ */ function debounce2(t5, i7) {
        let e6;
        return function() {
          let s5 = arguments, o5 = this;
          clearTimeout(e6), e6 = setTimeout(function() {
            t5.apply(o5, s5);
          }, i7);
        };
      }(this.resize, s4), this.wrapper === window ? window.addEventListener("resize", this.debouncedResize, false) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(this.debouncedResize), this.contentResizeObserver.observe(this.content)), this.resize();
    }
    destroy() {
      var t4, i6;
      null === (t4 = this.wrapperResizeObserver) || void 0 === t4 || t4.disconnect(), null === (i6 = this.contentResizeObserver) || void 0 === i6 || i6.disconnect(), window.removeEventListener("resize", this.debouncedResize, false);
    }
    get limit() {
      return { x: this.scrollWidth - this.width, y: this.scrollHeight - this.height };
    }
  };
  var Emitter = class {
    constructor() {
      this.events = {};
    }
    emit(t4, ...i6) {
      let e5 = this.events[t4] || [];
      for (let t5 = 0, s4 = e5.length; t5 < s4; t5++) e5[t5](...i6);
    }
    on(t4, i6) {
      var e5;
      return (null === (e5 = this.events[t4]) || void 0 === e5 ? void 0 : e5.push(i6)) || (this.events[t4] = [i6]), () => {
        var e6;
        this.events[t4] = null === (e6 = this.events[t4]) || void 0 === e6 ? void 0 : e6.filter((t5) => i6 !== t5);
      };
    }
    off(t4, i6) {
      var e5;
      this.events[t4] = null === (e5 = this.events[t4]) || void 0 === e5 ? void 0 : e5.filter((t5) => i6 !== t5);
    }
    destroy() {
      this.events = {};
    }
  };
  var t3 = 100 / 6;
  var VirtualScroll = class {
    constructor(i6, { wheelMultiplier: e5 = 1, touchMultiplier: s4 = 1 }) {
      this.lastDelta = { x: 0, y: 0 }, this.windowWidth = 0, this.windowHeight = 0, this.onTouchStart = (t4) => {
        const { clientX: i7, clientY: e6 } = t4.targetTouches ? t4.targetTouches[0] : t4;
        this.touchStart.x = i7, this.touchStart.y = e6, this.lastDelta = { x: 0, y: 0 }, this.emitter.emit("scroll", { deltaX: 0, deltaY: 0, event: t4 });
      }, this.onTouchMove = (t4) => {
        var i7, e6, s5, o5;
        const { clientX: n6, clientY: l6 } = t4.targetTouches ? t4.targetTouches[0] : t4, r6 = -(n6 - (null !== (e6 = null === (i7 = this.touchStart) || void 0 === i7 ? void 0 : i7.x) && void 0 !== e6 ? e6 : 0)) * this.touchMultiplier, h2 = -(l6 - (null !== (o5 = null === (s5 = this.touchStart) || void 0 === s5 ? void 0 : s5.y) && void 0 !== o5 ? o5 : 0)) * this.touchMultiplier;
        this.touchStart.x = n6, this.touchStart.y = l6, this.lastDelta = { x: r6, y: h2 }, this.emitter.emit("scroll", { deltaX: r6, deltaY: h2, event: t4 });
      }, this.onTouchEnd = (t4) => {
        this.emitter.emit("scroll", { deltaX: this.lastDelta.x, deltaY: this.lastDelta.y, event: t4 });
      }, this.onWheel = (i7) => {
        let { deltaX: e6, deltaY: s5, deltaMode: o5 } = i7;
        e6 *= 1 === o5 ? t3 : 2 === o5 ? this.windowWidth : 1, s5 *= 1 === o5 ? t3 : 2 === o5 ? this.windowHeight : 1, e6 *= this.wheelMultiplier, s5 *= this.wheelMultiplier, this.emitter.emit("scroll", { deltaX: e6, deltaY: s5, event: i7 });
      }, this.onWindowResize = () => {
        this.windowWidth = window.innerWidth, this.windowHeight = window.innerHeight;
      }, this.element = i6, this.wheelMultiplier = e5, this.touchMultiplier = s4, this.touchStart = { x: null, y: null }, this.emitter = new Emitter(), window.addEventListener("resize", this.onWindowResize, false), this.onWindowResize(), this.element.addEventListener("wheel", this.onWheel, { passive: false }), this.element.addEventListener("touchstart", this.onTouchStart, { passive: false }), this.element.addEventListener("touchmove", this.onTouchMove, { passive: false }), this.element.addEventListener("touchend", this.onTouchEnd, { passive: false });
    }
    on(t4, i6) {
      return this.emitter.on(t4, i6);
    }
    destroy() {
      this.emitter.destroy(), window.removeEventListener("resize", this.onWindowResize, false), this.element.removeEventListener("wheel", this.onWheel), this.element.removeEventListener("touchstart", this.onTouchStart), this.element.removeEventListener("touchmove", this.onTouchMove), this.element.removeEventListener("touchend", this.onTouchEnd);
    }
  };
  var Lenis = class {
    constructor({ wrapper: t4 = window, content: i6 = document.documentElement, wheelEventsTarget: e5 = t4, eventsTarget: s4 = e5, smoothWheel: o5 = true, syncTouch: n6 = false, syncTouchLerp: l6 = 0.075, touchInertiaMultiplier: r6 = 35, duration: h2, easing: a5 = (t5) => Math.min(1, 1.001 - Math.pow(2, -10 * t5)), lerp: c4 = 0.1, infinite: d3 = false, orientation: u3 = "vertical", gestureOrientation: p3 = "vertical", touchMultiplier: m3 = 1, wheelMultiplier: v2 = 1, autoResize: g3 = true, prevent: w3, virtualScroll: S3, __experimental__naiveDimensions: f3 = false } = {}) {
      this.__isScrolling = false, this.__isStopped = false, this.__isLocked = false, this.userData = {}, this.lastVelocity = 0, this.velocity = 0, this.direction = 0, this.onPointerDown = (t5) => {
        1 === t5.button && this.reset();
      }, this.onVirtualScroll = (t5) => {
        if ("function" == typeof this.options.virtualScroll && false === this.options.virtualScroll(t5)) return;
        const { deltaX: i7, deltaY: e6, event: s5 } = t5;
        if (this.emitter.emit("virtual-scroll", { deltaX: i7, deltaY: e6, event: s5 }), s5.ctrlKey) return;
        const o6 = s5.type.includes("touch"), n7 = s5.type.includes("wheel");
        this.isTouching = "touchstart" === s5.type || "touchmove" === s5.type;
        if (this.options.syncTouch && o6 && "touchstart" === s5.type && !this.isStopped && !this.isLocked) return void this.reset();
        const l7 = 0 === i7 && 0 === e6, r7 = "vertical" === this.options.gestureOrientation && 0 === e6 || "horizontal" === this.options.gestureOrientation && 0 === i7;
        if (l7 || r7) return;
        let h3 = s5.composedPath();
        h3 = h3.slice(0, h3.indexOf(this.rootElement));
        const a6 = this.options.prevent;
        if (h3.find((t6) => {
          var i8, e7, s6, l8, r8;
          return t6 instanceof Element && ("function" == typeof a6 && (null == a6 ? void 0 : a6(t6)) || (null === (i8 = t6.hasAttribute) || void 0 === i8 ? void 0 : i8.call(t6, "data-lenis-prevent")) || o6 && (null === (e7 = t6.hasAttribute) || void 0 === e7 ? void 0 : e7.call(t6, "data-lenis-prevent-touch")) || n7 && (null === (s6 = t6.hasAttribute) || void 0 === s6 ? void 0 : s6.call(t6, "data-lenis-prevent-wheel")) || (null === (l8 = t6.classList) || void 0 === l8 ? void 0 : l8.contains("lenis")) && !(null === (r8 = t6.classList) || void 0 === r8 ? void 0 : r8.contains("lenis-stopped")));
        })) return;
        if (this.isStopped || this.isLocked) return void s5.preventDefault();
        if (!(this.options.syncTouch && o6 || this.options.smoothWheel && n7)) return this.isScrolling = "native", void this.animate.stop();
        s5.preventDefault();
        let c5 = e6;
        "both" === this.options.gestureOrientation ? c5 = Math.abs(e6) > Math.abs(i7) ? e6 : i7 : "horizontal" === this.options.gestureOrientation && (c5 = i7);
        const d4 = o6 && this.options.syncTouch, u4 = o6 && "touchend" === s5.type && Math.abs(c5) > 5;
        u4 && (c5 = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + c5, Object.assign({ programmatic: false }, d4 ? { lerp: u4 ? this.options.syncTouchLerp : 1 } : { lerp: this.options.lerp, duration: this.options.duration, easing: this.options.easing }));
      }, this.onNativeScroll = () => {
        if (clearTimeout(this.__resetVelocityTimeout), delete this.__resetVelocityTimeout, this.__preventNextNativeScrollEvent) delete this.__preventNextNativeScrollEvent;
        else if (false === this.isScrolling || "native" === this.isScrolling) {
          const t5 = this.animatedScroll;
          this.animatedScroll = this.targetScroll = this.actualScroll, this.lastVelocity = this.velocity, this.velocity = this.animatedScroll - t5, this.direction = Math.sign(this.animatedScroll - t5), this.isScrolling = "native", this.emit(), 0 !== this.velocity && (this.__resetVelocityTimeout = setTimeout(() => {
            this.lastVelocity = this.velocity, this.velocity = 0, this.isScrolling = false, this.emit();
          }, 400));
        }
      }, window.lenisVersion = "1.1.9", t4 && t4 !== document.documentElement && t4 !== document.body || (t4 = window), this.options = { wrapper: t4, content: i6, wheelEventsTarget: e5, eventsTarget: s4, smoothWheel: o5, syncTouch: n6, syncTouchLerp: l6, touchInertiaMultiplier: r6, duration: h2, easing: a5, lerp: c4, infinite: d3, gestureOrientation: p3, orientation: u3, touchMultiplier: m3, wheelMultiplier: v2, autoResize: g3, prevent: w3, virtualScroll: S3, __experimental__naiveDimensions: f3 }, this.animate = new Animate(), this.emitter = new Emitter(), this.dimensions = new Dimensions({ wrapper: t4, content: i6, autoResize: g3 }), this.updateClassName(), this.userData = {}, this.time = 0, this.velocity = this.lastVelocity = 0, this.isLocked = false, this.isStopped = false, this.isScrolling = false, this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener("scroll", this.onNativeScroll, false), this.options.wrapper.addEventListener("pointerdown", this.onPointerDown, false), this.virtualScroll = new VirtualScroll(s4, { touchMultiplier: m3, wheelMultiplier: v2 }), this.virtualScroll.on("scroll", this.onVirtualScroll);
    }
    destroy() {
      this.emitter.destroy(), this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, false), this.options.wrapper.removeEventListener("pointerdown", this.onPointerDown, false), this.virtualScroll.destroy(), this.dimensions.destroy(), this.cleanUpClassName();
    }
    on(t4, i6) {
      return this.emitter.on(t4, i6);
    }
    off(t4, i6) {
      return this.emitter.off(t4, i6);
    }
    setScroll(t4) {
      this.isHorizontal ? this.rootElement.scrollLeft = t4 : this.rootElement.scrollTop = t4;
    }
    resize() {
      this.dimensions.resize();
    }
    emit() {
      this.emitter.emit("scroll", this);
    }
    reset() {
      this.isLocked = false, this.isScrolling = false, this.animatedScroll = this.targetScroll = this.actualScroll, this.lastVelocity = this.velocity = 0, this.animate.stop();
    }
    start() {
      this.isStopped && (this.isStopped = false, this.reset());
    }
    stop() {
      this.isStopped || (this.isStopped = true, this.animate.stop(), this.reset());
    }
    raf(t4) {
      const i6 = t4 - (this.time || t4);
      this.time = t4, this.animate.advance(1e-3 * i6);
    }
    scrollTo(t4, { offset: i6 = 0, immediate: e5 = false, lock: s4 = false, duration: o5 = this.options.duration, easing: n6 = this.options.easing, lerp: l6 = this.options.lerp, onStart: r6, onComplete: h2, force: a5 = false, programmatic: c4 = true, userData: d3 = {} } = {}) {
      if (!this.isStopped && !this.isLocked || a5) {
        if ("string" == typeof t4 && ["top", "left", "start"].includes(t4)) t4 = 0;
        else if ("string" == typeof t4 && ["bottom", "right", "end"].includes(t4)) t4 = this.limit;
        else {
          let e6;
          if ("string" == typeof t4 ? e6 = document.querySelector(t4) : t4 instanceof HTMLElement && (null == t4 ? void 0 : t4.nodeType) && (e6 = t4), e6) {
            if (this.options.wrapper !== window) {
              const t5 = this.rootElement.getBoundingClientRect();
              i6 -= this.isHorizontal ? t5.left : t5.top;
            }
            const s5 = e6.getBoundingClientRect();
            t4 = (this.isHorizontal ? s5.left : s5.top) + this.animatedScroll;
          }
        }
        if ("number" == typeof t4 && (t4 += i6, t4 = Math.round(t4), this.options.infinite ? c4 && (this.targetScroll = this.animatedScroll = this.scroll) : t4 = clamp5(0, t4, this.limit), t4 !== this.targetScroll)) {
          if (this.userData = d3, e5) return this.animatedScroll = this.targetScroll = t4, this.setScroll(this.scroll), this.reset(), this.preventNextNativeScrollEvent(), this.emit(), null == h2 || h2(this), void (this.userData = {});
          c4 || (this.targetScroll = t4), this.animate.fromTo(this.animatedScroll, t4, { duration: o5, easing: n6, lerp: l6, onStart: () => {
            s4 && (this.isLocked = true), this.isScrolling = "smooth", null == r6 || r6(this);
          }, onUpdate: (t5, i7) => {
            this.isScrolling = "smooth", this.lastVelocity = this.velocity, this.velocity = t5 - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = t5, this.setScroll(this.scroll), c4 && (this.targetScroll = t5), i7 || this.emit(), i7 && (this.reset(), this.emit(), null == h2 || h2(this), this.userData = {}, this.preventNextNativeScrollEvent());
          } });
        }
      }
    }
    preventNextNativeScrollEvent() {
      this.__preventNextNativeScrollEvent = true, requestAnimationFrame(() => {
        delete this.__preventNextNativeScrollEvent;
      });
    }
    get rootElement() {
      return this.options.wrapper === window ? document.documentElement : this.options.wrapper;
    }
    get limit() {
      return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"];
    }
    get isHorizontal() {
      return "horizontal" === this.options.orientation;
    }
    get actualScroll() {
      return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop;
    }
    get scroll() {
      return this.options.infinite ? function modulo(t4, i6) {
        return (t4 % i6 + i6) % i6;
      }(this.animatedScroll, this.limit) : this.animatedScroll;
    }
    get progress() {
      return 0 === this.limit ? 1 : this.scroll / this.limit;
    }
    get isScrolling() {
      return this.__isScrolling;
    }
    set isScrolling(t4) {
      this.__isScrolling !== t4 && (this.__isScrolling = t4, this.updateClassName());
    }
    get isStopped() {
      return this.__isStopped;
    }
    set isStopped(t4) {
      this.__isStopped !== t4 && (this.__isStopped = t4, this.updateClassName());
    }
    get isLocked() {
      return this.__isLocked;
    }
    set isLocked(t4) {
      this.__isLocked !== t4 && (this.__isLocked = t4, this.updateClassName());
    }
    get isSmooth() {
      return "smooth" === this.isScrolling;
    }
    get className() {
      let t4 = "lenis";
      return this.isStopped && (t4 += " lenis-stopped"), this.isLocked && (t4 += " lenis-locked"), this.isScrolling && (t4 += " lenis-scrolling"), "smooth" === this.isScrolling && (t4 += " lenis-smooth"), t4;
    }
    updateClassName() {
      this.cleanUpClassName(), this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim();
    }
    cleanUpClassName() {
      this.rootElement.className = this.rootElement.className.replace(/lenis(-\w+)?/g, "").trim();
    }
  };

  // node_modules/locomotive-scroll/dist/locomotive-scroll.modern.mjs
  function s3() {
    return s3 = Object.assign ? Object.assign.bind() : function(t4) {
      for (var s4 = 1; s4 < arguments.length; s4++) {
        var e5 = arguments[s4];
        for (var i6 in e5) ({}).hasOwnProperty.call(e5, i6) && (t4[i6] = e5[i6]);
      }
      return t4;
    }, s3.apply(null, arguments);
  }
  var e4 = class {
    constructor({ scrollElements: t4, rootMargin: s4 = "-1px -1px -1px -1px", IORaf: e5 }) {
      this.scrollElements = void 0, this.rootMargin = void 0, this.IORaf = void 0, this.observer = void 0, this.scrollElements = t4, this.rootMargin = s4, this.IORaf = e5, this._init();
    }
    _init() {
      this.observer = new IntersectionObserver((t4) => {
        t4.forEach((t5) => {
          const s4 = this.scrollElements.find((s5) => s5.$el === t5.target);
          t5.isIntersecting ? (s4 && (s4.isAlreadyIntersected = true), this._setInview(t5)) : s4 && s4.isAlreadyIntersected && this._setOutOfView(t5);
        });
      }, { rootMargin: this.rootMargin });
      for (const t4 of this.scrollElements) this.observe(t4.$el);
    }
    destroy() {
      this.observer.disconnect();
    }
    observe(t4) {
      t4 && this.observer.observe(t4);
    }
    unobserve(t4) {
      t4 && this.observer.unobserve(t4);
    }
    _setInview(t4) {
      const s4 = this.scrollElements.find((s5) => s5.$el === t4.target);
      this.IORaf && (null == s4 || s4.setInteractivityOn()), !this.IORaf && (null == s4 || s4.setInview());
    }
    _setOutOfView(t4) {
      const s4 = this.scrollElements.find((s5) => s5.$el === t4.target);
      this.IORaf && (null == s4 || s4.setInteractivityOff()), !this.IORaf && (null == s4 || s4.setOutOfView()), null != s4 && s4.attributes.scrollRepeat || this.IORaf || this.unobserve(t4.target);
    }
  };
  function i5(t4, s4, e5, i6, r6) {
    return e5 + ((r6 - t4) / (s4 - t4) * (i6 - e5) || 0);
  }
  function r5(t4, s4) {
    return t4.reduce((t5, e5) => Math.abs(e5 - s4) < Math.abs(t5 - s4) ? e5 : t5);
  }
  var l5 = class {
    constructor({ $el: t4, id: s4, modularInstance: e5, subscribeElementUpdateFn: i6, unsubscribeElementUpdateFn: r6, needRaf: l6, scrollOrientation: n6 }) {
      var o5, a5, c4, h2, d3;
      this.$el = void 0, this.id = void 0, this.needRaf = void 0, this.attributes = void 0, this.scrollOrientation = void 0, this.isAlreadyIntersected = void 0, this.intersection = void 0, this.metrics = void 0, this.currentScroll = void 0, this.translateValue = void 0, this.progress = void 0, this.lastProgress = void 0, this.modularInstance = void 0, this.progressModularModules = void 0, this.isInview = void 0, this.isInteractive = void 0, this.isInFold = void 0, this.isFirstResize = void 0, this.subscribeElementUpdateFn = void 0, this.unsubscribeElementUpdateFn = void 0, this.$el = t4, this.id = s4, this.needRaf = l6, this.scrollOrientation = n6, this.modularInstance = e5, this.subscribeElementUpdateFn = i6, this.unsubscribeElementUpdateFn = r6, this.attributes = { scrollClass: null != (o5 = this.$el.dataset.scrollClass) ? o5 : "is-inview", scrollOffset: null != (a5 = this.$el.dataset.scrollOffset) ? a5 : "0,0", scrollPosition: null != (c4 = this.$el.dataset.scrollPosition) ? c4 : "start,end", scrollModuleProgress: null != this.$el.dataset.scrollModuleProgress, scrollCssProgress: null != this.$el.dataset.scrollCssProgress, scrollEventProgress: null != (h2 = this.$el.dataset.scrollEventProgress) ? h2 : null, scrollSpeed: null != this.$el.dataset.scrollSpeed ? parseFloat(this.$el.dataset.scrollSpeed) : null, scrollRepeat: null != this.$el.dataset.scrollRepeat, scrollCall: null != (d3 = this.$el.dataset.scrollCall) ? d3 : null, scrollCallSelf: null != this.$el.dataset.scrollCallSelf, scrollIgnoreFold: null != this.$el.dataset.scrollIgnoreFold, scrollEnableTouchSpeed: null != this.$el.dataset.scrollEnableTouchSpeed }, this.intersection = { start: 0, end: 0 }, this.metrics = { offsetStart: 0, offsetEnd: 0, bcr: {} }, this.currentScroll = "vertical" === this.scrollOrientation ? window.scrollY : window.scrollX, this.translateValue = 0, this.progress = 0, this.lastProgress = null, this.progressModularModules = [], this.isInview = false, this.isInteractive = false, this.isAlreadyIntersected = false, this.isInFold = false, this.isFirstResize = true, this._init();
    }
    _init() {
      this.needRaf && (this.modularInstance && this.attributes.scrollModuleProgress && this._getProgressModularModules(), this._resize());
    }
    onResize({ currentScroll: t4 }) {
      this.currentScroll = t4, this._resize();
    }
    onRender({ currentScroll: t4, smooth: s4 }) {
      const e5 = "vertical" === this.scrollOrientation ? window.innerHeight : window.innerWidth;
      if (this.currentScroll = t4, this._computeProgress(), this.attributes.scrollSpeed && !isNaN(this.attributes.scrollSpeed)) if (this.attributes.scrollEnableTouchSpeed || s4) {
        if (this.isInFold) {
          const t5 = Math.max(0, this.progress);
          this.translateValue = t5 * e5 * this.attributes.scrollSpeed * -1;
        } else {
          const t5 = i5(0, 1, -1, 1, this.progress);
          this.translateValue = t5 * e5 * this.attributes.scrollSpeed * -1;
        }
        this.$el.style.transform = "vertical" === this.scrollOrientation ? `translate3d(0, ${this.translateValue}px, 0)` : `translate3d(${this.translateValue}px, 0, 0)`;
      } else this.translateValue && (this.$el.style.transform = "translate3d(0, 0, 0)"), this.translateValue = 0;
    }
    setInview() {
      if (this.isInview) return;
      this.isInview = true, this.$el.classList.add(this.attributes.scrollClass);
      const t4 = this._getScrollCallFrom();
      this.attributes.scrollCall && this._dispatchCall("enter", t4);
    }
    setOutOfView() {
      if (!this.isInview || !this.attributes.scrollRepeat) return;
      this.isInview = false, this.$el.classList.remove(this.attributes.scrollClass);
      const t4 = this._getScrollCallFrom();
      this.attributes.scrollCall && this._dispatchCall("leave", t4);
    }
    setInteractivityOn() {
      this.isInteractive || (this.isInteractive = true, this.subscribeElementUpdateFn(this));
    }
    setInteractivityOff() {
      this.isInteractive && (this.isInteractive = false, this.unsubscribeElementUpdateFn(this), null != this.lastProgress && this._computeProgress(r5([0, 1], this.lastProgress)));
    }
    _resize() {
      this.metrics.bcr = this.$el.getBoundingClientRect(), this._computeMetrics(), this._computeIntersection(), this.isFirstResize && (this.isFirstResize = false, this.isInFold && this.setInview());
    }
    _computeMetrics() {
      const { top: t4, left: s4, height: e5, width: i6 } = this.metrics.bcr, r6 = "vertical" === this.scrollOrientation ? window.innerHeight : window.innerWidth, l6 = "vertical" === this.scrollOrientation ? e5 : i6;
      this.metrics.offsetStart = this.currentScroll + ("vertical" === this.scrollOrientation ? t4 : s4) - this.translateValue, this.metrics.offsetEnd = this.metrics.offsetStart + l6, this.isInFold = this.metrics.offsetStart < r6 && !this.attributes.scrollIgnoreFold;
    }
    _computeIntersection() {
      const t4 = "vertical" === this.scrollOrientation ? window.innerHeight : window.innerWidth, s4 = "vertical" === this.scrollOrientation ? this.metrics.bcr.height : this.metrics.bcr.width, e5 = this.attributes.scrollOffset.split(","), i6 = null != e5[0] ? e5[0].trim() : "0", r6 = null != e5[1] ? e5[1].trim() : "0", l6 = this.attributes.scrollPosition.split(",");
      let n6 = null != l6[0] ? l6[0].trim() : "start";
      const o5 = null != l6[1] ? l6[1].trim() : "end", a5 = i6.includes("%") ? t4 * parseInt(i6.replace("%", "").trim()) * 0.01 : parseInt(i6), c4 = r6.includes("%") ? t4 * parseInt(r6.replace("%", "").trim()) * 0.01 : parseInt(r6);
      switch (this.isInFold && (n6 = "fold"), n6) {
        case "start":
        default:
          this.intersection.start = this.metrics.offsetStart - t4 + a5;
          break;
        case "middle":
          this.intersection.start = this.metrics.offsetStart - t4 + a5 + 0.5 * s4;
          break;
        case "end":
          this.intersection.start = this.metrics.offsetStart - t4 + a5 + s4;
          break;
        case "fold":
          this.intersection.start = 0;
      }
      switch (o5) {
        case "start":
          this.intersection.end = this.metrics.offsetStart - c4;
          break;
        case "middle":
          this.intersection.end = this.metrics.offsetStart - c4 + 0.5 * s4;
          break;
        default:
          this.intersection.end = this.metrics.offsetStart - c4 + s4;
      }
      if (this.intersection.end <= this.intersection.start) switch (o5) {
        case "start":
        default:
          this.intersection.end = this.intersection.start + 1;
          break;
        case "middle":
          this.intersection.end = this.intersection.start + 0.5 * s4;
          break;
        case "end":
          this.intersection.end = this.intersection.start + s4;
      }
    }
    _computeProgress(t4) {
      const s4 = null != t4 ? t4 : (e5 = i5(this.intersection.start, this.intersection.end, 0, 1, this.currentScroll)) < 0 ? 0 : e5 > 1 ? 1 : e5;
      var e5;
      if (this.progress = s4, s4 != this.lastProgress) {
        if (this.lastProgress = s4, this.attributes.scrollCssProgress && this._setCssProgress(s4), this.attributes.scrollEventProgress && this._setCustomEventProgress(s4), this.attributes.scrollModuleProgress) for (const t5 of this.progressModularModules) this.modularInstance && this.modularInstance.call("onScrollProgress", s4, t5.moduleName, t5.moduleId);
        s4 > 0 && s4 < 1 && this.setInview(), 0 === s4 && this.setOutOfView(), 1 === s4 && this.setOutOfView();
      }
    }
    _setCssProgress(t4 = 0) {
      this.$el.style.setProperty("--progress", t4.toString());
    }
    _setCustomEventProgress(t4 = 0) {
      const s4 = this.attributes.scrollEventProgress;
      if (!s4) return;
      const e5 = new CustomEvent(s4, { detail: { target: this.$el, progress: t4 } });
      window.dispatchEvent(e5);
    }
    _getProgressModularModules() {
      if (!this.modularInstance) return;
      const t4 = Object.keys(this.$el.dataset).filter((t5) => t5.includes("module")), s4 = Object.entries(this.modularInstance.modules);
      if (t4.length) for (const e5 of t4) {
        const t5 = this.$el.dataset[e5];
        if (!t5) return;
        for (const e6 of s4) {
          const [s5, i6] = e6;
          t5 in i6 && this.progressModularModules.push({ moduleName: s5, moduleId: t5 });
        }
      }
    }
    _getScrollCallFrom() {
      const t4 = r5([this.intersection.start, this.intersection.end], this.currentScroll);
      return this.intersection.start === t4 ? "start" : "end";
    }
    _dispatchCall(t4, s4) {
      var e5, i6;
      const r6 = null == (e5 = this.attributes.scrollCall) ? void 0 : e5.split(","), l6 = null == (i6 = this.attributes) ? void 0 : i6.scrollCallSelf;
      if (r6 && r6.length > 1) {
        var n6;
        const [e6, i7, o5] = r6;
        let a5;
        a5 = l6 ? this.$el.dataset[`module${i7.trim()}`] : o5, this.modularInstance && this.modularInstance.call(e6.trim(), { target: this.$el, way: t4, from: s4 }, i7.trim(), null == (n6 = a5) ? void 0 : n6.trim());
      } else if (r6) {
        const [e6] = r6, i7 = new CustomEvent(e6, { detail: { target: this.$el, way: t4, from: s4 } });
        window.dispatchEvent(i7);
      }
    }
  };
  var n5 = ["scrollOffset", "scrollPosition", "scrollModuleProgress", "scrollCssProgress", "scrollEventProgress", "scrollSpeed"];
  var o4 = class {
    constructor({ $el: t4, modularInstance: s4, triggerRootMargin: e5, rafRootMargin: i6, scrollOrientation: r6 }) {
      this.$scrollContainer = void 0, this.modularInstance = void 0, this.triggerRootMargin = void 0, this.rafRootMargin = void 0, this.scrollElements = void 0, this.triggeredScrollElements = void 0, this.RAFScrollElements = void 0, this.scrollElementsToUpdate = void 0, this.IOTriggerInstance = void 0, this.IORafInstance = void 0, this.scrollOrientation = void 0, t4 ? (this.$scrollContainer = t4, this.modularInstance = s4, this.scrollOrientation = r6, this.triggerRootMargin = null != e5 ? e5 : "-1px -1px -1px -1px", this.rafRootMargin = null != i6 ? i6 : "100% 100% 100% 100%", this.scrollElements = [], this.triggeredScrollElements = [], this.RAFScrollElements = [], this.scrollElementsToUpdate = [], this._init()) : console.error("Please provide a DOM Element as scrollContainer");
    }
    _init() {
      const t4 = this.$scrollContainer.querySelectorAll("[data-scroll]"), s4 = Array.from(t4);
      this._subscribeScrollElements(s4), this.IOTriggerInstance = new e4({ scrollElements: [...this.triggeredScrollElements], rootMargin: this.triggerRootMargin, IORaf: false }), this.IORafInstance = new e4({ scrollElements: [...this.RAFScrollElements], rootMargin: this.rafRootMargin, IORaf: true });
    }
    destroy() {
      this.IOTriggerInstance.destroy(), this.IORafInstance.destroy(), this._unsubscribeAllScrollElements();
    }
    onResize({ currentScroll: t4 }) {
      for (const s4 of this.RAFScrollElements) s4.onResize({ currentScroll: t4 });
    }
    onRender({ currentScroll: t4, smooth: s4 }) {
      for (const e5 of this.scrollElementsToUpdate) e5.onRender({ currentScroll: t4, smooth: s4 });
    }
    removeScrollElements(t4) {
      const s4 = t4.querySelectorAll("[data-scroll]");
      if (s4.length) {
        for (let t5 = 0; t5 < this.triggeredScrollElements.length; t5++) {
          const e5 = this.triggeredScrollElements[t5];
          Array.from(s4).indexOf(e5.$el) > -1 && (this.IOTriggerInstance.unobserve(e5.$el), this.triggeredScrollElements.splice(t5, 1));
        }
        for (let t5 = 0; t5 < this.RAFScrollElements.length; t5++) {
          const e5 = this.RAFScrollElements[t5];
          Array.from(s4).indexOf(e5.$el) > -1 && (this.IORafInstance.unobserve(e5.$el), this.RAFScrollElements.splice(t5, 1));
        }
        s4.forEach((t5) => {
          const s5 = this.scrollElementsToUpdate.find((s6) => s6.$el === t5), e5 = this.scrollElements.find((s6) => s6.$el === t5);
          s5 && this._unsubscribeElementUpdate(s5), e5 && (this.scrollElements = this.scrollElements.filter((t6) => t6.id != e5.id));
        });
      }
    }
    addScrollElements(t4) {
      const s4 = t4.querySelectorAll("[data-scroll]"), e5 = [];
      this.scrollElements.forEach((t5) => {
        e5.push(t5.id);
      });
      const i6 = Math.max(...e5, 0) + 1, r6 = Array.from(s4);
      this._subscribeScrollElements(r6, i6, true);
    }
    _subscribeScrollElements(t4, s4 = 0, e5 = false) {
      for (let i6 = 0; i6 < t4.length; i6++) {
        const r6 = t4[i6], n6 = this._checkRafNeeded(r6), o5 = new l5({ $el: r6, id: s4 + i6, scrollOrientation: this.scrollOrientation, modularInstance: this.modularInstance, subscribeElementUpdateFn: this._subscribeElementUpdate.bind(this), unsubscribeElementUpdateFn: this._unsubscribeElementUpdate.bind(this), needRaf: n6 });
        this.scrollElements.push(o5), n6 ? (this.RAFScrollElements.push(o5), e5 && (this.IORafInstance.scrollElements.push(o5), this.IORafInstance.observe(o5.$el))) : (this.triggeredScrollElements.push(o5), e5 && (this.IOTriggerInstance.scrollElements.push(o5), this.IOTriggerInstance.observe(o5.$el)));
      }
    }
    _unsubscribeAllScrollElements() {
      this.scrollElements = [], this.RAFScrollElements = [], this.triggeredScrollElements = [], this.scrollElementsToUpdate = [];
    }
    _subscribeElementUpdate(t4) {
      this.scrollElementsToUpdate.push(t4);
    }
    _unsubscribeElementUpdate(t4) {
      this.scrollElementsToUpdate = this.scrollElementsToUpdate.filter((s4) => s4.id != t4.id);
    }
    _checkRafNeeded(t4) {
      let s4 = [...n5];
      const e5 = (t5) => {
        s4 = s4.filter((s5) => s5 != t5);
      };
      if (t4.dataset.scrollOffset) {
        if ("0,0" != t4.dataset.scrollOffset.split(",").map((t5) => t5.replace("%", "").trim()).join(",")) return true;
        e5("scrollOffset");
      } else e5("scrollOffset");
      if (t4.dataset.scrollPosition) {
        if ("top,bottom" != t4.dataset.scrollPosition.trim()) return true;
        e5("scrollPosition");
      } else e5("scrollPosition");
      if (t4.dataset.scrollSpeed && !isNaN(parseFloat(t4.dataset.scrollSpeed))) return true;
      e5("scrollSpeed");
      for (const e6 of s4) if (e6 in t4.dataset) return true;
      return false;
    }
  };
  var a4 = class {
    constructor({ resizeElements: t4, resizeCallback: s4 = () => {
    } }) {
      this.$resizeElements = void 0, this.isFirstObserve = void 0, this.observer = void 0, this.resizeCallback = void 0, this.$resizeElements = t4, this.resizeCallback = s4, this.isFirstObserve = true, this._init();
    }
    _init() {
      this.observer = new ResizeObserver((t4) => {
        var s4;
        !this.isFirstObserve && (null == (s4 = this.resizeCallback) || s4.call(this)), this.isFirstObserve = false;
      });
      for (const t4 of this.$resizeElements) this.observer.observe(t4);
    }
    destroy() {
      this.observer.disconnect();
    }
  };
  var c3 = class {
    constructor({ lenisOptions: t4 = {}, modularInstance: s4, triggerRootMargin: e5, rafRootMargin: i6, autoResize: r6 = true, autoStart: l6 = true, scrollCallback: n6 = () => {
    }, initCustomTicker: o5, destroyCustomTicker: a5 } = {}) {
      this.rafPlaying = void 0, this.lenisInstance = void 0, this.coreInstance = void 0, this.lenisOptions = void 0, this.modularInstance = void 0, this.triggerRootMargin = void 0, this.rafRootMargin = void 0, this.rafInstance = void 0, this.autoResize = void 0, this.autoStart = void 0, this.ROInstance = void 0, this.initCustomTicker = void 0, this.destroyCustomTicker = void 0, this._onRenderBind = void 0, this._onResizeBind = void 0, this._onScrollToBind = void 0;
      for (const [s5] of Object.entries(t4)) ["wrapper", "content", "infinite"].includes(s5) && console.warn(`Warning: Key "${s5}" is not possible to edit in Locomotive Scroll.`);
      Object.assign(this, { lenisOptions: t4, modularInstance: s4, triggerRootMargin: e5, rafRootMargin: i6, autoResize: r6, autoStart: l6, scrollCallback: n6, initCustomTicker: o5, destroyCustomTicker: a5 }), this._onRenderBind = this._onRender.bind(this), this._onScrollToBind = this._onScrollTo.bind(this), this._onResizeBind = this._onResize.bind(this), this.rafPlaying = false, this._init();
    }
    _init() {
      var e5;
      this.lenisInstance = new Lenis(s3({}, this.lenisOptions, { wrapper: window, content: document.documentElement, infinite: false })), null == (e5 = this.lenisInstance) || e5.on("scroll", this.scrollCallback), document.documentElement.setAttribute("data-scroll-orientation", this.lenisInstance.options.orientation), requestAnimationFrame(() => {
        this.coreInstance = new o4({ $el: this.lenisInstance.rootElement, modularInstance: this.modularInstance, triggerRootMargin: this.triggerRootMargin, rafRootMargin: this.rafRootMargin, scrollOrientation: this.lenisInstance.options.orientation }), this._bindEvents(), this.initCustomTicker && !this.destroyCustomTicker ? console.warn("initCustomTicker callback is declared, but destroyCustomTicker is not. Please pay attention. It could cause trouble.") : !this.initCustomTicker && this.destroyCustomTicker && console.warn("destroyCustomTicker callback is declared, but initCustomTicker is not. Please pay attention. It could cause trouble."), this.autoStart && this.start();
      });
    }
    destroy() {
      var t4;
      this.stop(), this._unbindEvents(), this.lenisInstance.destroy(), null == (t4 = this.coreInstance) || t4.destroy(), requestAnimationFrame(() => {
        var t5;
        null == (t5 = this.coreInstance) || t5.destroy();
      });
    }
    _bindEvents() {
      this._bindScrollToEvents(), this.autoResize && ("ResizeObserver" in window ? this.ROInstance = new a4({ resizeElements: [document.body], resizeCallback: this._onResizeBind }) : window.addEventListener("resize", this._onResizeBind));
    }
    _unbindEvents() {
      this._unbindScrollToEvents(), this.autoResize && ("ResizeObserver" in window ? this.ROInstance && this.ROInstance.destroy() : window.removeEventListener("resize", this._onResizeBind));
    }
    _bindScrollToEvents(t4) {
      const s4 = t4 || this.lenisInstance.rootElement, e5 = null == s4 ? void 0 : s4.querySelectorAll("[data-scroll-to]");
      (null == e5 ? void 0 : e5.length) && e5.forEach((t5) => {
        t5.addEventListener("click", this._onScrollToBind, false);
      });
    }
    _unbindScrollToEvents(t4) {
      const s4 = t4 || this.lenisInstance.rootElement, e5 = null == s4 ? void 0 : s4.querySelectorAll("[data-scroll-to]");
      (null == e5 ? void 0 : e5.length) && e5.forEach((t5) => {
        t5.removeEventListener("click", this._onScrollToBind, false);
      });
    }
    _onResize() {
      requestAnimationFrame(() => {
        var t4;
        null == (t4 = this.coreInstance) || t4.onResize({ currentScroll: this.lenisInstance.scroll });
      });
    }
    _onRender() {
      var t4, s4;
      null == (t4 = this.lenisInstance) || t4.raf(Date.now()), null == (s4 = this.coreInstance) || s4.onRender({ currentScroll: this.lenisInstance.scroll, smooth: this.lenisInstance.options.smoothWheel });
    }
    _onScrollTo(t4) {
      var s4;
      t4.preventDefault();
      const e5 = null != (s4 = t4.currentTarget) ? s4 : null;
      if (!e5) return;
      const i6 = e5.getAttribute("data-scroll-to-href") || e5.getAttribute("href"), r6 = e5.getAttribute("data-scroll-to-offset") || 0, l6 = e5.getAttribute("data-scroll-to-duration") || this.lenisInstance.options.duration;
      i6 && this.scrollTo(i6, { offset: "string" == typeof r6 ? parseInt(r6) : r6, duration: "string" == typeof l6 ? parseInt(l6) : l6 });
    }
    start() {
      var t4;
      this.rafPlaying || (null == (t4 = this.lenisInstance) || t4.start(), this.rafPlaying = true, this.initCustomTicker ? this.initCustomTicker(this._onRenderBind) : this._raf());
    }
    stop() {
      var t4;
      this.rafPlaying && (null == (t4 = this.lenisInstance) || t4.stop(), this.rafPlaying = false, this.destroyCustomTicker ? this.destroyCustomTicker(this._onRenderBind) : this.rafInstance && cancelAnimationFrame(this.rafInstance));
    }
    removeScrollElements(t4) {
      var s4;
      t4 ? (this._unbindScrollToEvents(t4), null == (s4 = this.coreInstance) || s4.removeScrollElements(t4)) : console.error("Please provide a DOM Element as $oldContainer");
    }
    addScrollElements(t4) {
      var s4;
      t4 ? (null == (s4 = this.coreInstance) || s4.addScrollElements(t4), requestAnimationFrame(() => {
        this._bindScrollToEvents(t4);
      })) : console.error("Please provide a DOM Element as $newContainer");
    }
    resize() {
      this._onResizeBind();
    }
    scrollTo(t4, s4) {
      var e5;
      null == (e5 = this.lenisInstance) || e5.scrollTo(t4, { offset: null == s4 ? void 0 : s4.offset, lerp: null == s4 ? void 0 : s4.lerp, duration: null == s4 ? void 0 : s4.duration, immediate: null == s4 ? void 0 : s4.immediate, lock: null == s4 ? void 0 : s4.lock, force: null == s4 ? void 0 : s4.force, easing: null == s4 ? void 0 : s4.easing, onComplete: null == s4 ? void 0 : s4.onComplete });
    }
    _raf() {
      this._onRenderBind(), this.rafInstance = requestAnimationFrame(() => this._raf());
    }
  };

  // assets/scripts/modules/Scroll.js
  var Scroll_default = class extends _default {
    constructor(m3) {
      super(m3);
      this.onScrollBind = this.onScroll.bind(this);
    }
    init() {
      this.scroll = new c3({
        modularInstance: this,
        scrollCallback: this.onScrollBind
      });
      if (history.scrollRestoration) {
        history.scrollRestoration = "manual";
        window.scrollTo(0, 0);
      }
      this.scroll.lenisInstance.options.content.addEventListener("wheel", (event2) => {
        const targets = event2.composedPath();
        const stopPropagation = targets.some((target) => target.id === "cc-main");
        if (stopPropagation) {
          event2.stopPropagation();
        }
      });
    }
    ///////////////
    // Callbacks
    ///////////////
    onScroll({ scroll, velocity: velocity2, progress }) {
      if (progress > this.lastProgress) {
        if (this.scrollDirection != 1) {
          this.scrollDirection = 1;
          $html.classList.remove("is-scrolling-up");
        }
      } else {
        if (this.scrollDirection != -1) {
          this.scrollDirection = -1;
          $html.classList.add("is-scrolling-up");
        }
      }
      if (this.scrollDirection < 0 && scroll > 300) {
        $html.classList.add("has-header-fixed-visible");
      } else {
        $html.classList.remove("has-header-fixed-visible");
      }
      this.lastProgress = progress;
    }
    /**
     * Lazy load the related image.
     *
     * @see ../utils/image.js
     *
     * It is recommended to wrap your `<img>` into an element with the
     * CSS class name `.c-lazy`. The CSS class name modifier `.-lazy-loaded`
     * will be applied on both the image and the parent wrapper.
     *
     * ```html
     * <div class="c-lazy o-ratio u-4:3">
     *     <img data-scroll data-scroll-call="lazyLoad, Scroll, main" data-src="http://picsum.photos/640/480?v=1" alt="" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" />
     * </div>
     * ```
     *
     * @param {LocomotiveScroll} args - The Locomotive Scroll instance.
     */
    lazyLoad(args) {
      lazyLoadImage(args.target, null, () => {
      });
    }
    removeScrollElements($oldContainer) {
      var _a;
      (_a = this.scroll) == null ? void 0 : _a.removeScrollElements($oldContainer);
    }
    addScrollElements($newContainer) {
      var _a;
      (_a = this.scroll) == null ? void 0 : _a.addScrollElements($newContainer);
    }
    scrollTo(params) {
      var _a;
      let { target, options } = params;
      (_a = this.scroll) == null ? void 0 : _a.scrollTo(target, options);
    }
    resize() {
      var _a;
      (_a = this.scroll) == null ? void 0 : _a.resize();
    }
    destroy() {
      this.scroll.destroy();
    }
  };

  // assets/scripts/modules/Timeline.js
  var _Timeline = class _Timeline extends _default {
    constructor(m3) {
      super(m3);
      this.onResize = this.onResize.bind(this);
      this.$items = Array.from(this.$("item"));
      this.$years = Array.from(this.$("year"));
      this.progress = 0;
      this.wHeight = window.innerHeight;
      this.metrics = [];
    }
    // =============================================================================
    // Lifecycle
    // =============================================================================
    init() {
      whenReady(FONT.EAGER).then((fonts) => this.onFontsLoaded(fonts));
      this.bindEvents();
      requestAnimationFrame(() => {
        this.call("resize", null, "Scroll");
        requestAnimationFrame(() => {
          if (window.matchMedia(_Timeline.MQ_FROM_MEDIUM).matches) {
            this.setMetrics();
          }
        });
      });
    }
    destroy() {
      super.destroy();
      this.unbindEvents();
    }
    // =============================================================================
    // Events
    // =============================================================================
    bindEvents() {
      this.unbindScreenListener = $screenDebounce.subscribe(this.onResize);
    }
    unbindEvents() {
      var _a;
      (_a = this.unbindScreenListener) == null ? void 0 : _a.call(this);
    }
    // =============================================================================
    // Callbacks
    // =============================================================================
    onFontsLoaded(fonts) {
      if (window.matchMedia(_Timeline.MQ_FROM_MEDIUM).matches) {
        this.setMetrics();
      }
    }
    onResize({ width: width2, height: height2 }) {
      this.wHeight = height2;
      if (window.matchMedia(_Timeline.MQ_FROM_MEDIUM).matches) {
        this.setMetrics();
      }
    }
    onScrollProgress(progress) {
      if (window.matchMedia(_Timeline.MQ_FROM_MEDIUM).matches) {
        this.progress = progress;
        this.setStepProgress();
      }
    }
    // =============================================================================
    // Methods
    // =============================================================================
    setMetrics() {
      let acc = 0;
      const totalHeight = this.el.offsetHeight;
      this.metrics = this.$items.map(($item) => {
        const itemHeight = $item.offsetHeight;
        const itemMetrics = {
          progressStart: acc / totalHeight,
          progressEnd: (acc + this.wHeight) / totalHeight
        };
        acc += itemHeight;
        return itemMetrics;
      });
    }
    setStepProgress() {
      this.$years.forEach(($year, i6) => {
        var _a;
        const { progressStart, progressEnd } = this.metrics[i6];
        const { progressStart: progressStartNext, progressEnd: progressEndNext } = (_a = this.metrics[i6 + 1]) != null ? _a : {};
        const halfStartProgress = i6 === 0 ? 0.5 : clamp4(0, 0.5, mapRange3(progressStart, progressEnd, 0, 0.5, this.progress));
        const halfEnd = this.metrics[i6 + 1] ? clamp4(0, 0.5, mapRange3(progressStartNext, progressEndNext, 0, 0.5, this.progress)) : 0;
        const progressesStarts = [
          clamp4(
            0,
            0.5,
            mapRange3(0, 0.5 - _Timeline.STAGGER_OFFSET * 3, 0, 0.5, halfStartProgress)
          ),
          clamp4(
            0,
            0.5,
            mapRange3(0, 0.5 - _Timeline.STAGGER_OFFSET * 2, 0, 0.5, halfStartProgress)
          ),
          clamp4(
            0,
            0.5,
            mapRange3(0, 0.5 - _Timeline.STAGGER_OFFSET, 0, 0.5, halfStartProgress)
          ),
          halfStartProgress
        ];
        const progressesEnds = [
          clamp4(0, 0.5, mapRange3(0, 0.5 - _Timeline.STAGGER_OFFSET * 3, 0, 0.5, halfEnd)),
          clamp4(0, 0.5, mapRange3(0, 0.5 - _Timeline.STAGGER_OFFSET * 2, 0, 0.5, halfEnd)),
          clamp4(0, 0.5, mapRange3(0, 0.5 - _Timeline.STAGGER_OFFSET, 0, 0.5, halfEnd)),
          halfEnd
        ];
        for (let i7 = 0; i7 < 4; i7++) {
          const progressStart2 = progressesStarts[i7];
          const progressEnd2 = progressesEnds[i7];
          $year.style.setProperty(
            `--progress-${i7}`,
            roundNumber(progressStart2 + progressEnd2, 4)
          );
        }
      });
    }
  };
  __publicField(_Timeline, "STAGGER_OFFSET", 0.1);
  __publicField(_Timeline, "MQ_FROM_MEDIUM", `(min-width: 1000px)`);
  var Timeline2 = _Timeline;

  // assets/scripts/modules/VideoInline.js
  var VideoInline = class extends _default {
    constructor(m3) {
      super(m3);
      this.onMenuOpenChange = this.onMenuOpenChange.bind(this);
      this.onPlayerOpenChange = this.onPlayerOpenChange.bind(this);
      this.$video = this.el;
      this.isInview = false;
    }
    // =============================================================================
    // Lifecycle
    // =============================================================================
    init() {
      this.bindEvents();
    }
    destroy() {
      this.unbindEvents();
      super.destroy();
    }
    // =============================================================================
    // Lifecycle
    // =============================================================================
    bindEvents() {
      this.unbindMenuOpenListener = $hasMenuOpen.listen(this.onMenuOpenChange);
      this.unbindPlayerOpenListener = $hasPlayerOpen.listen(this.onPlayerOpenChange);
    }
    unbindEvents() {
      var _a, _b;
      (_a = this.unbindMenuOpenListener) == null ? void 0 : _a.call(this);
      (_b = this.unbindPlayerOpenListener) == null ? void 0 : _b.call(this);
    }
    // =============================================================================
    // Callbacks
    // =============================================================================
    onMenuOpenChange(hasMenuOpen) {
      if (hasMenuOpen) {
        this.pause();
      } else {
        if (this.isInview) this.play();
      }
    }
    onPlayerOpenChange(hasPlayerOpen) {
      if (hasPlayerOpen.state) {
        this.pause();
      } else {
        if (this.isInview) this.play();
      }
    }
    onInview({ way }) {
      if (way === "enter" && !this.isInview) {
        this.$video.muted = true;
        this.play();
        this.isInview = true;
      } else if (way === "leave" && this.isInview) {
        this.pause();
        this.isInview = false;
      }
    }
    // =============================================================================
    // Methods
    // =============================================================================
    play() {
      return __async(this, null, function* () {
        var _a, _b, _c, _d;
        try {
          if (this.$video.paused && $isAutoplayable.value) {
            yield this.$video.play();
            $isAutoplayable.set(true);
          }
        } catch (err) {
          this.$video.classList.add("is-first-playing");
          (_b = (_a = this.$video) == null ? void 0 : _a.parentNode) == null ? void 0 : _b.classList.add("is-first-playing");
          $isAutoplayable.set(false);
        }
        if (!$isAutoplayable.value) {
          this.$video.classList.add("is-first-playing");
          (_d = (_c = this.$video) == null ? void 0 : _c.parentNode) == null ? void 0 : _d.classList.add("is-first-playing");
        }
      });
    }
    pause() {
      if (!this.$video.paused) this.$video.pause();
    }
  };

  // assets/scripts/globals.js
  var import_svg4everybody = __toESM(require_svg4everybody(), 1);
  var gridHelper2;
  (() => __async(void 0, null, function* () {
    if (ENV.IS_DEV) {
      const gridHelperModule = yield Promise.resolve().then(() => (init_grid_helper(), grid_helper_exports));
      gridHelper2 = gridHelperModule == null ? void 0 : gridHelperModule.gridHelper;
    }
  }))();
  function globals_default() {
    (0, import_svg4everybody.default)();
    gridHelper2 == null ? void 0 : gridHelper2();
  }

  // assets/scripts/app.js
  var app = new main_esm_default({
    modules: modules_exports
  });
  function init4() {
    globals_default();
    setViewportSizes();
    app.init(app);
    $html.classList.add(CSS_CLASS.FIRST_LOADED);
    $html.classList.add(CSS_CLASS.LOADED, CSS_CLASS.READY);
    $html.classList.remove(CSS_CLASS.LOADING);
    if (isFontLoadingAPIAvailable) {
      loadFonts(FONT.EAGER, ENV.IS_DEV).then((eagerFonts) => {
        $html.classList.add(CSS_CLASS.FONTS_LOADED);
      });
    }
  }
  $screen.subscribe(() => {
    setViewportSizes();
  });
  function setViewportSizes() {
    const documentStyles = document.documentElement.style;
    const vw = document.body.clientWidth * 0.01;
    documentStyles.setProperty("--vw", `${vw}px`);
    if (ENV.SUPPORTS_VH) {
      return;
    }
    const svh = document.documentElement.clientHeight * 0.01;
    documentStyles.setProperty("--svh", `${svh}px`);
    const dvh = window.innerHeight * 0.01;
    documentStyles.setProperty("--dvh", `${dvh}px`);
    if (document.body) {
      const fixed = document.createElement("div");
      fixed.style.width = "1px";
      fixed.style.height = "100vh";
      fixed.style.position = "fixed";
      fixed.style.left = "0";
      fixed.style.top = "0";
      fixed.style.bottom = "0";
      fixed.style.visibility = "hidden";
      document.body.appendChild(fixed);
      var fixedHeight = fixed.clientHeight;
      fixed.remove();
      const lvh = fixedHeight * 0.01;
      documentStyles.setProperty("--lvh", `${lvh}px`);
    }
  }
  window.addEventListener("load", () => {
    const $style = document.getElementById("main-css");
    if ($style) {
      if ($style.isLoaded) {
        init4();
      } else {
        $style.addEventListener("load", init4);
      }
    } else {
      console.warn('The "main-css" stylesheet not found');
    }
  });
})();
/*! Bundled license information:

lottie-web/build/player/lottie.js:
  (*!
   Transformation Matrix v2.0
   (c) Epistemex 2014-2015
   www.epistemex.com
   By Ken Fyrstenberg
   Contributions by leeoniya.
   License: MIT, header required.
   *)

svg4everybody/dist/svg4everybody.js:
  (*! svg4everybody v2.1.9 | github.com/jonathantneal/svg4everybody *)

gsap/gsap-core.js:
  (*!
   * GSAP 3.12.5
   * https://gsap.com
   *
   * @license Copyright 2008-2024, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/CSSPlugin.js:
  (*!
   * CSSPlugin 3.12.5
   * https://gsap.com
   *
   * Copyright 2008-2024, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/utils/strings.js:
  (*!
   * strings: 3.12.5
   * https://gsap.com
   *
   * Copyright 2008-2024, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/SplitText.js:
  (*!
   * SplitText: 3.12.5
   * https://gsap.com
   *
   * @license Copyright 2008-2024, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

vanilla-cookieconsent/dist/cookieconsent.esm.js:
  (*!
  * CookieConsent 3.0.1
  * https://github.com/orestbida/cookieconsent
  * Author Orest Bida
  * Released under the MIT License
  *)

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.2.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 7.6.2
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)
*/
//# sourceMappingURL=app.js.map
